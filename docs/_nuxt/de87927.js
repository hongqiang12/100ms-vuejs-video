/*! For license information please see LICENSES */
(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{400:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n(402),o=n(453);const c="__op";function l(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const l=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=c;const d=(...e)=>{r.a.startScope(n);try{const t=l(...e);return Object(o.x)(t)&&console.error("Cannot return a Promise inside of tidy."),r.a.endScope(t),t}catch(e){throw r.a.endScope(null),e}};return Object.defineProperty(d,"name",{value:n,configurable:!0}),d}},401:function(e,t,n){"use strict";n.d(t,"c",(function(){return h})),n.d(t,"a",(function(){return x})),n.d(t,"b",(function(){return v}));var r=n(402),o=n(409),c=n(417),l=n(453),d=n(404);function h(e,t){let n=e;if(Object(l.A)(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||Object(l.A)(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&Object(o.b)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&f(e,r,[]),r}function f(e,t,n){if(n=n||[],!Array.isArray(e)&&!Object(l.A)(e))return void Object(l.b)(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));Object(l.b)(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),Object(l.b)(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let i=0;i<e.length;++i)f(e[i],r,n.concat(i))}function m(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function x(e,t,n,o="numeric"){if(e instanceof c.a)return m(o,e.dtype,t,n),e;let f=Object(l.r)(e);if("string"!==f&&["bool","int32","float32"].indexOf(o)>=0&&(f=o),m(o,f,t,n),null==e||!Object(l.A)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const x=h(e,f);Object(l.A)(e)||Array.isArray(e)||(e=[e]);const v="string"!==f?Object(d.toTypedArray)(e,f):Object(l.m)(e,[],!0);return r.a.makeTensor(v,x,f)}function v(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,i)=>x(e,`${t}[${i}]`,n,r)))}},402:function(e,t,n){"use strict";n.d(t,"b",(function(){return k})),n.d(t,"a",(function(){return E}));var r=n(461),o=n(409),c=n(491),l=n(403),d=n(492),h=n(460),f=n(404),m=n(453);class x{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new y)}profileKernel(e,t,n){let r;const c=()=>{r=n()};let l;const d=f.now();if(this.backendTimer.timerAvailable())l=this.backendTimer.time(c);else{c();for(const output of r)output.dataSync();l=Promise.resolve({kernelMs:f.now()-d})}if(Object(o.b)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<r.length;i++){const output=r[i];output.data().then((t=>{v(t,output.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:l.then((e=>e.kernelMs)),extraInfo:l.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:o,extraInfo:c}=e;n.forEach((e=>{Promise.all([e.data(),r,c]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],o,n[2])}))}))}}function v(e,t,n){if("float32"!==t)return!1;for(let i=0;i<e.length;i++){const t=e[i];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class y{logKernelProfile(e,t,n,r,o,c){const time="number"==typeof r?m.L(`${r}ms`,9):r.error,l=m.L(e,25),d=t.rank,h=t.size,f=m.L(t.shape.toString(),14);let x="";for(const e in o){const input=o[e];if(null!=input){const n=input.shape||t.shape,r=n.length;x+=`${e}: ${r}D ${r>0?n:""} `}}console.log(`%c${l}\t%c${time}\t%c${d}D ${f}\t%c${h}\t%c${x}\t%c${c}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var w=n(417),C=n(410);function I(e){return null!=e.kernelName}class ${constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class S{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new $}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let i=0;i<e.length;i++){const t=e[i];if(await this.initializeBackend(t).success)return void await this.setBackend(t)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(h.b(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new x(this.backendInstance),!0}setupRegisteredKernels(){Object(d.c)(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){Object(d.c)(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof r.b||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,h.b(`Initialization of backend ${e} failed`),h.b(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return h.b(`Initialization of backend ${e} failed`),h.b(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((a,b)=>this.registryFactory[b].priority-this.registryFactory[a].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let i=0;i<e.length;i++){const t=e[i],{success:n,asyncInit:r}=this.initializeBackend(t);if(r||n)return{name:t,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,o=this.readSync(t),c=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,o,n.shape,n.dtype,c),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return S.nextTensorId++}nextVariableId(){return S.nextVariableId++}clone(e){const t=E.runKernel(l.qb,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return E.runKernel(l.w,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=Object(d.b)(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let o=0;n.forEach((e=>{o+="complex64"===e.dtype?3:1}));const c=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],l=r-t-o-c;if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),o=this.state.numBytes,c=this.state.numTensors;let l,h;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const f=I(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(I(e)){const{kernelName:t,inputs:o,attrs:c}=e;null==this.backendName&&this.backend;const f=Object(d.b)(t,this.backendName);m.b(null!=f,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),l=()=>{const e=this.backend.numDataIds();h=f.kernelFunc({inputs:o,attrs:c,backend:this.backend});const l=Array.isArray(h)?h:[h];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,l);const d=l.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,o,d);n=this.saveTensorsForBackwardMode(e)}return d}}else{const{forwardFunc:t}=e,o=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};l=()=>{const e=this.backend.numDataIds();h=this.tidy((()=>t(this.backend,o)));const n=Array.isArray(h)?h:[h];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,e,n),n}}const{inputs:x,attrs:v}=e,y=I(e)?null:e.backwardsFunc;let w;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(w=this.profiler.profileKernel(f,x,(()=>l())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(w),t=w.outputs):t=l()})),r&&this.addTapeNode(f,x,t,y,n,v),this.state.profiling&&this.state.activeProfile.kernels.push({name:f,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-c,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(x).map((e=>null!=x[e]?x[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:w.timeMs,extraInfo:w.extraInfo}),Array.isArray(h)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=Object(d.a)(e);if(null!=r){const e=r.inputsToSave||[],o=r.outputsToSave||[];let c;r.saveAllInputs?(m.b(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),c=Object.keys(t).map((e=>t[e]))):c=e.map((e=>t[e]));const l=n.filter(((e,i)=>o[i]));return c.concat(l)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let o=e;"string"===n&&m.z(e[0])&&(o=e.map((e=>f.encodeString(e))));const c=r.write(o,t,n),l=new w.a(t,n,c,this.nextTensorId());if(this.trackTensor(l,r),"string"===n){const e=this.state.tensorInfo.get(c),t=Object(m.f)(o);this.state.numBytes+=t-e.bytes,e.bytes=t}return l}makeTensorFromDataId(e,t,n,r){const o={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(o,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:o}=e,c=new w.a(r,o,n,this.nextTensorId());return this.trackTensor(c,t),c}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const o=new w.c(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(a,e){this.state.numTensors++,"string"===a.dtype&&this.state.numStringTensors++;let t=0;"complex64"!==a.dtype&&"string"!==a.dtype&&(t=a.size*m.g(a.dtype)),this.state.numBytes+=t,this.state.tensorInfo.has(a.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(a.dataId,{backend:e||this.backend,dtype:a.dtype,shape:a.shape,bytes:t})),a instanceof w.c||this.track(a)}incRef(a,e){this.trackTensor(a,e),this.backend.incRef(a.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(a){if(!this.state.tensorInfo.has(a.dataId))return;const e=this.state.tensorInfo.get(a.dataId);if(this.state.numTensors--,"string"===a.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==a.dtype&&"string"!==a.dtype){const e=a.size*m.g(a.dtype);this.state.numBytes-=e}e.backend.disposeData(a.dataId)&&this.removeDataId(a.dataId,e.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,o,c){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:o},h=Object(d.a)(e);null!=h&&(r=h.gradFunc),null!=r&&(l.gradient=e=>(e=e.map(((e,i)=>{if(null==e){const output=n[i],e=m.F(output.size,output.dtype);return this.makeTensor(e,output.shape,output.dtype)}return e})),r(e.length>1?e:e[0],o,c))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Object(C.a)(e),n=new Set(t.map((e=>e.id)));for(let i=0;i<this.state.activeScope.track.length;i++){const e=this.state.activeScope.track[i];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n,r=!1){if(m.b(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const o=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));m.b(o instanceof w.a,(()=>"The result y returned by f() must be a tensor."));const c=function(e,t,n){const r={},o={};for(let i=0;i<t.length;i++)r[t[i].id]=!0;for(let i=0;i<e.length;i++){const n=e[i],c=n.inputs;for(const e in c){const input=c[e];let l=!1;for(let e=0;e<t.length;e++)if(r[input.id]){n.outputs.forEach((output=>r[output.id]=!0)),l=!0,o[n.id]=!0;break}if(l)break}}const c={};c[n.id]=!0;const l={};for(let i=e.length-1;i>=0;i--){const t=e[i],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(c[t.outputs[e].id]){for(const e in n)c[n[e].id]=!0,l[t.id]=!0;break}}const d=[];for(let i=0;i<e.length;i++){const t=e[i];if(o[t.id]&&l[t.id]){const e={};for(const n in t.inputs){const o=t.inputs[n];r[o.id]&&(e[n]=o)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,d.push(n)}}return d}(this.state.activeTape,t,o);if(!r&&0===c.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[o.id]=null==n?function(e){const t=Object(m.D)(Object(m.O)(e),"float32");return E.makeTensor(t,e,"float32")}(o.shape):n,function(e,t,n,r){for(let i=t.length-1;i>=0;i--){const o=t[i],c=[];if(o.outputs.forEach((t=>{const n=e[t.id];null!=n?c.push(n):c.push(null)})),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const l=o.gradient(c);for(const t in o.inputs){if(!(t in l))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(l)}.`);const c=n((()=>l[t]()));if("float32"!==c.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${c.dtype}'`);const d=o.inputs[t];if(!m.a(c.shape,d.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${t}' has shape '${c.shape}', which does not match the shape of the input '${d.shape}'`);if(null==e[d.id])e[d.id]=c;else{const t=e[d.id];e[d.id]=r(t,c),t.dispose()}}}}(e,c,(e=>this.tidy(e)),T);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:o,grads:r}}))}customGrad(e){return m.b(m.u(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;m.b(t.every((e=>e instanceof w.a)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};t.forEach(((input,i)=>{r[i]=input}));return this.runKernelFunc({forwardFunc:(r,o)=>(n=e(...t,o),m.b(n.value instanceof w.a,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),m.b(m.u(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,r)=>{const o=n.gradFunc(e,r),c=Array.isArray(o)?o:[o];m.b(c.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),m.b(c.every((e=>e instanceof w.a)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const l={};return c.forEach(((e,i)=>{l[i]=()=>e})),l},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Object(f.now)(),n=await this.backend.time(e);return n.wallMs=Object(f.now)()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new $;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function k(){const e=Object(c.b)();if(null==e._tfengine){const t=new o.a(e);e._tfengine=new S(t)}return Object(o.c)(e._tfengine.ENV),Object(w.f)((()=>e._tfengine)),e._tfengine}S.nextTensorId=0,S.nextVariableId=0;const E=k();function T(a,b){const e={a:a,b:b};return E.runKernel(l.d,e)}},403:function(e,t,n){"use strict";n.d(t,"a",(function(){return r})),n.d(t,"b",(function(){return o})),n.d(t,"c",(function(){return c})),n.d(t,"d",(function(){return l})),n.d(t,"e",(function(){return d})),n.d(t,"f",(function(){return h})),n.d(t,"g",(function(){return f})),n.d(t,"h",(function(){return m})),n.d(t,"i",(function(){return x})),n.d(t,"j",(function(){return v})),n.d(t,"k",(function(){return y})),n.d(t,"l",(function(){return w})),n.d(t,"n",(function(){return C})),n.d(t,"m",(function(){return I})),n.d(t,"o",(function(){return $})),n.d(t,"r",(function(){return S})),n.d(t,"p",(function(){return k})),n.d(t,"q",(function(){return E})),n.d(t,"s",(function(){return T})),n.d(t,"t",(function(){return R})),n.d(t,"u",(function(){return O})),n.d(t,"v",(function(){return A})),n.d(t,"w",(function(){return N})),n.d(t,"x",(function(){return _})),n.d(t,"y",(function(){return F})),n.d(t,"z",(function(){return D})),n.d(t,"A",(function(){return P})),n.d(t,"B",(function(){return L})),n.d(t,"C",(function(){return B})),n.d(t,"D",(function(){return M})),n.d(t,"E",(function(){return j})),n.d(t,"F",(function(){return U})),n.d(t,"G",(function(){return W})),n.d(t,"H",(function(){return V})),n.d(t,"I",(function(){return z})),n.d(t,"J",(function(){return G})),n.d(t,"L",(function(){return H})),n.d(t,"M",(function(){return X})),n.d(t,"K",(function(){return K})),n.d(t,"N",(function(){return Y})),n.d(t,"O",(function(){return Z})),n.d(t,"P",(function(){return Q})),n.d(t,"Q",(function(){return J})),n.d(t,"R",(function(){return ee})),n.d(t,"S",(function(){return te})),n.d(t,"T",(function(){return ne})),n.d(t,"kc",(function(){return re})),n.d(t,"U",(function(){return oe})),n.d(t,"V",(function(){return ie})),n.d(t,"W",(function(){return ae})),n.d(t,"Y",(function(){return se})),n.d(t,"X",(function(){return ue})),n.d(t,"Z",(function(){return ce})),n.d(t,"ab",(function(){return le})),n.d(t,"bb",(function(){return de})),n.d(t,"cb",(function(){return he})),n.d(t,"db",(function(){return pe})),n.d(t,"eb",(function(){return fe})),n.d(t,"fb",(function(){return ge})),n.d(t,"gb",(function(){return me})),n.d(t,"ib",(function(){return be})),n.d(t,"mb",(function(){return xe})),n.d(t,"lb",(function(){return ve})),n.d(t,"nb",(function(){return ye})),n.d(t,"ob",(function(){return we})),n.d(t,"qb",(function(){return Ce})),n.d(t,"pb",(function(){return Ie})),n.d(t,"rb",(function(){return $e})),n.d(t,"sb",(function(){return Se})),n.d(t,"tb",(function(){return ke})),n.d(t,"ub",(function(){return Ee})),n.d(t,"xb",(function(){return Te})),n.d(t,"yb",(function(){return Re})),n.d(t,"zb",(function(){return Oe})),n.d(t,"Ab",(function(){return Ae})),n.d(t,"Bb",(function(){return Ne})),n.d(t,"Cb",(function(){return _e})),n.d(t,"Db",(function(){return Fe})),n.d(t,"Eb",(function(){return De})),n.d(t,"Fb",(function(){return Pe})),n.d(t,"vb",(function(){return Le})),n.d(t,"wb",(function(){return Be})),n.d(t,"Gb",(function(){return Me})),n.d(t,"Mb",(function(){return je})),n.d(t,"Hb",(function(){return Ue})),n.d(t,"Kb",(function(){return We})),n.d(t,"Ib",(function(){return Ve})),n.d(t,"Jb",(function(){return ze})),n.d(t,"Lb",(function(){return Ge})),n.d(t,"Nb",(function(){return He})),n.d(t,"Ob",(function(){return Xe})),n.d(t,"Pb",(function(){return qe})),n.d(t,"Qb",(function(){return Ke})),n.d(t,"Rb",(function(){return Ye})),n.d(t,"Sb",(function(){return Ze})),n.d(t,"Tb",(function(){return Qe})),n.d(t,"Ub",(function(){return Je})),n.d(t,"Yb",(function(){return et})),n.d(t,"Vb",(function(){return tt})),n.d(t,"Wb",(function(){return nt})),n.d(t,"Xb",(function(){return ot})),n.d(t,"ac",(function(){return it})),n.d(t,"Zb",(function(){return at})),n.d(t,"bc",(function(){return st})),n.d(t,"cc",(function(){return ut})),n.d(t,"dc",(function(){return ct})),n.d(t,"ec",(function(){return lt})),n.d(t,"fc",(function(){return ht})),n.d(t,"gc",(function(){return pt})),n.d(t,"hc",(function(){return ft})),n.d(t,"ic",(function(){return gt})),n.d(t,"jc",(function(){return mt})),n.d(t,"lc",(function(){return bt})),n.d(t,"mc",(function(){return xt})),n.d(t,"oc",(function(){return vt})),n.d(t,"rc",(function(){return yt})),n.d(t,"sc",(function(){return wt})),n.d(t,"pc",(function(){return Ct})),n.d(t,"qc",(function(){return It})),n.d(t,"nc",(function(){return $t})),n.d(t,"tc",(function(){return St})),n.d(t,"vc",(function(){return kt})),n.d(t,"wc",(function(){return Et})),n.d(t,"xc",(function(){return Tt})),n.d(t,"yc",(function(){return Rt})),n.d(t,"zc",(function(){return Ot})),n.d(t,"Ac",(function(){return At})),n.d(t,"Fc",(function(){return Nt})),n.d(t,"Dc",(function(){return _t})),n.d(t,"Ec",(function(){return Ft})),n.d(t,"Cc",(function(){return Dt})),n.d(t,"Bc",(function(){return Pt})),n.d(t,"Hc",(function(){return Lt})),n.d(t,"Pc",(function(){return Bt})),n.d(t,"Yc",(function(){return Mt})),n.d(t,"Ic",(function(){return jt})),n.d(t,"Oc",(function(){return Ut})),n.d(t,"Gc",(function(){return Wt})),n.d(t,"Jc",(function(){return Vt})),n.d(t,"Kc",(function(){return zt})),n.d(t,"Lc",(function(){return Gt})),n.d(t,"Mc",(function(){return Ht})),n.d(t,"Nc",(function(){return Xt})),n.d(t,"Rc",(function(){return qt})),n.d(t,"Qc",(function(){return Kt})),n.d(t,"Tc",(function(){return Yt})),n.d(t,"Uc",(function(){return Zt})),n.d(t,"Vc",(function(){return Qt})),n.d(t,"Wc",(function(){return Jt})),n.d(t,"Xc",(function(){return en})),n.d(t,"Zc",(function(){return tn})),n.d(t,"ad",(function(){return nn})),n.d(t,"bd",(function(){return rn})),n.d(t,"cd",(function(){return on})),n.d(t,"dd",(function(){return an})),n.d(t,"ed",(function(){return sn})),n.d(t,"fd",(function(){return un})),n.d(t,"gd",(function(){return cn})),n.d(t,"hd",(function(){return ln})),n.d(t,"id",(function(){return dn})),n.d(t,"Sc",(function(){return hn})),n.d(t,"hb",(function(){return pn})),n.d(t,"uc",(function(){return fn})),n.d(t,"jd",(function(){return gn})),n.d(t,"jb",(function(){return mn})),n.d(t,"kb",(function(){return bn}));const r="Abs",o="Acos",c="Acosh",l="Add",d="AddN",h="All",f="Any",m="ArgMax",x="ArgMin",v="Asin",y="Asinh",w="Atan",C="Atanh",I="Atan2",$="AvgPool",S="AvgPoolGrad",k="AvgPool3D",E="AvgPool3DGrad",T="BatchMatMul",R="BatchToSpaceND",O="Bincount",A="BroadcastArgs",N="Cast",_="Ceil",F="ClipByValue",D="Complex",P="ComplexAbs",L="Concat",B="Conv2D",M="Conv2DBackpropFilter",j="Conv2DBackpropInput",U="Conv3D",W="Conv3DBackpropFilterV2",V="Conv3DBackpropInputV2",z="Cos",G="Cosh",H="Cumprod",X="Cumsum",K="CropAndResize",Y="DenseBincount",Z="DepthToSpace",Q="DepthwiseConv2dNative",J="DepthwiseConv2dNativeBackpropFilter",ee="DepthwiseConv2dNativeBackpropInput",te="Diag",ne="Dilation2D",re="RealDiv",oe="Einsum",ie="Elu",ae="EluGrad",se="Erf",ue="Equal",ce="Exp",le="ExpandDims",de="Expm1",he="FFT",pe="Fill",fe="FlipLeftRight",ge="Floor",me="FloorDiv",be="FusedBatchNorm",xe="GatherV2",ve="GatherNd",ye="Greater",we="GreaterEqual",Ce="Identity",Ie="IFFT",$e="Imag",Se="IsFinite",ke="IsInf",Ee="IsNan",Te="LeakyRelu",Re="Less",Oe="LessEqual",Ae="LinSpace",Ne="Log",_e="Log1p",Fe="LogicalAnd",De="LogicalNot",Pe="LogicalOr",Le="LRN",Be="LRNGrad",Me="Max",je="Maximum",Ue="MaxPool",We="MaxPoolGrad",Ve="MaxPool3D",ze="MaxPool3DGrad",Ge="MaxPoolWithArgmax",He="Mean",Xe="Min",qe="Minimum",Ke="MirrorPad",Ye="Mod",Ze="Multinomial",Qe="Multiply",Je="Neg",et="NotEqual",tt="NonMaxSuppressionV3",nt="NonMaxSuppressionV4",ot="NonMaxSuppressionV5",it="OnesLike",at="OneHot",st="Pack",ut="PadV2",ct="Pow",lt="Prelu",ht="Prod",pt="RaggedGather",ft="RaggedTensorToTensor",gt="Range",mt="Real",bt="Reciprocal",xt="Relu",vt="Reshape",yt="ResizeNearestNeighbor",wt="ResizeNearestNeighborGrad",Ct="ResizeBilinear",It="ResizeBilinearGrad",$t="Relu6",St="Reverse",kt="Round",Et="Rsqrt",Tt="ScatterNd",Rt="SearchSorted",Ot="Select",At="Selu",Nt="Slice",_t="Sin",Ft="Sinh",Dt="Sign",Pt="Sigmoid",Lt="Softplus",Bt="Sqrt",Mt="Sum",jt="SpaceToBatchND",Ut="SplitV",Wt="Softmax",Vt="SparseFillEmptyRows",zt="SparseReshape",Gt="SparseSegmentMean",Ht="SparseSegmentSum",Xt="SparseToDense",qt="SquaredDifference",Kt="Square",Yt="StridedSlice",Zt="StringNGrams",Qt="StringSplit",Jt="StringToHashBucketFast",en="Sub",tn="Tan",nn="Tanh",rn="Tile",on="TopK",an="Transform",sn="Transpose",un="Unique",cn="Unpack",ln="UnsortedSegmentSum",dn="ZerosLike",hn="Step",pn="FromPixels",fn="RotateWithOffset",gn="_FusedMatMul",mn="FusedConv2D",bn="FusedDepthwiseConv2D"},404:function(e,t,n){"use strict";n.r(t),n.d(t,"shuffle",(function(){return o.M})),n.d(t,"shuffleCombo",(function(){return o.N})),n.d(t,"clamp",(function(){return o.i})),n.d(t,"nearestLargerEven",(function(){return o.H})),n.d(t,"swap",(function(){return o.S})),n.d(t,"sum",(function(){return o.R})),n.d(t,"randUniform",(function(){return o.J})),n.d(t,"distSquared",(function(){return o.l})),n.d(t,"assert",(function(){return o.b})),n.d(t,"assertShapesMatch",(function(){return o.e})),n.d(t,"assertNonNull",(function(){return o.d})),n.d(t,"flatten",(function(){return o.m})),n.d(t,"sizeFromShape",(function(){return o.O})),n.d(t,"isScalarShape",(function(){return o.y})),n.d(t,"arraysEqual",(function(){return o.a})),n.d(t,"isInt",(function(){return o.v})),n.d(t,"tanh",(function(){return o.T})),n.d(t,"sizeToSquarishShape",(function(){return o.P})),n.d(t,"createShuffledIndices",(function(){return o.k})),n.d(t,"rightPad",(function(){return o.L})),n.d(t,"repeatedTry",(function(){return o.K})),n.d(t,"inferFromImplicitShape",(function(){return o.s})),n.d(t,"parseAxisParam",(function(){return o.I})),n.d(t,"squeezeShape",(function(){return o.Q})),n.d(t,"getTypedArrayFromDType",(function(){return o.o})),n.d(t,"getArrayFromDType",(function(){return o.n})),n.d(t,"checkConversionForErrors",(function(){return o.h})),n.d(t,"isValidDtype",(function(){return o.B})),n.d(t,"hasEncodingLoss",(function(){return o.p})),n.d(t,"isTypedArray",(function(){return o.A})),n.d(t,"bytesPerElement",(function(){return o.g})),n.d(t,"bytesFromStringArray",(function(){return o.f})),n.d(t,"isString",(function(){return o.z})),n.d(t,"isBoolean",(function(){return o.t})),n.d(t,"isNumber",(function(){return o.w})),n.d(t,"inferDtype",(function(){return o.r})),n.d(t,"isFunction",(function(){return o.u})),n.d(t,"nearestDivisor",(function(){return o.G})),n.d(t,"computeStrides",(function(){return o.j})),n.d(t,"toNestedArray",(function(){return o.U})),n.d(t,"makeOnesTypedArray",(function(){return o.D})),n.d(t,"makeZerosTypedArray",(function(){return o.F})),n.d(t,"makeZerosNestedTypedArray",(function(){return o.E})),n.d(t,"assertNonNegativeIntegerDimensions",(function(){return o.c})),n.d(t,"locToIndex",(function(){return o.C})),n.d(t,"indexToLoc",(function(){return o.q})),n.d(t,"isPromise",(function(){return o.x})),n.d(t,"hexToLong",(function(){return d})),n.d(t,"fingerPrint64",(function(){return S})),n.d(t,"createScalarValue",(function(){return k})),n.d(t,"toTypedArray",(function(){return E})),n.d(t,"now",(function(){return T})),n.d(t,"fetch",(function(){return R})),n.d(t,"encodeString",(function(){return O})),n.d(t,"decodeString",(function(){return A}));var r=n(409),o=n(453),c=n(671);const l=n.n(c).a||c;function d(e){return l.fromString(e,!0,16)}const h=d("c3a5c85c97cb3127"),f=d("b492b66fbe98f273"),m=d("9ae16a3b2f90404f");function x(e){return e.xor(e.shru(47))}function v(s,e,t){const n=s.slice(e,e+t);return l.fromBytes(Array.from(n),!0,!0)}function y(s,e){return v(s,e,8)}function w(s,e){return v(s,e,4)}function C(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function I(u,e,t=d("9ddfea08eb382d69")){let a=u.xor(e).mul(t);a=a.xor(a.shru(47));let b=e.xor(a).mul(t);return b=b.xor(b.shru(47)),b=b.mul(t),b}function $(s,e,a,b){return function(e,t,n,r,a,b){a=a.add(e),b=C(b.add(a).add(r),21);const o=a;return a=(a=a.add(t)).add(n),b=b.add(C(a,44)),[a.add(r),b.add(o)]}(y(s,e),y(s,e+8),y(s,e+16),y(s,e+24),a,b)}function S(s,e=s.length){const t=l.fromNumber(81,!0);if(e<=32)return e<=16?function(s,e=s.length){if(e>=8){const t=m.add(2*e),a=y(s,0).add(m),b=y(s,e-8);return I(C(b,37).mul(t).add(a),C(a,25).add(b).mul(t),t)}if(e>=4){const t=m.add(2*e);return I(w(s,0).shl(3).add(e),w(s,e-4),t)}if(e>0){const t=s[0]+(s[e>>1]<<8),n=e+(s[e-1]<<2);return x(m.mul(t).xor(h.mul(n))).mul(m)}return m}(s,e):function(s,e=s.length){const t=m.add(2*e),a=y(s,0).mul(f),b=y(s,8),n=y(s,e-8).mul(t),r=y(s,e-16).mul(m);return I(C(a.add(b),43).add(C(n,30)).add(r),a.add(C(b.add(m),18)).add(n),t)}(s,e);if(e<=64)return function(s,e=s.length){const t=m.add(2*e),a=y(s,0).mul(m),b=y(s,8),n=y(s,e-8).mul(t),r=y(s,e-16).mul(m),o=C(a.add(b),43).add(C(n,30)).add(r),c=I(o,a.add(C(b.add(m),18)).add(n),t),l=y(s,16).mul(t),d=y(s,24),g=o.add(y(s,e-32)).mul(t),h=c.add(y(s,e-24)).mul(t);return I(C(l.add(d),43).add(C(g,30)).add(h),l.add(C(d.add(a),18)).add(g),t)}(s,e);let n=t,r=t.mul(f).add(113),o=x(r.mul(m).add(113)).mul(m),c=[l.UZERO,l.UZERO],d=[l.UZERO,l.UZERO];n=n.mul(m).add(y(s,0));let v=0;const S=64*(e-1>>6),k=S+(e-1&63)-63;do{n=C(n.add(r).add(c[0]).add(y(s,v+8)),37).mul(f),r=C(r.add(c[1]).add(y(s,v+48)),42).mul(f),n=n.xor(d[1]),r=r.add(c[0]).add(y(s,v+40)),o=C(o.add(d[0]),33).mul(f),c=$(s,v,c[1].mul(f),n.add(d[0])),d=$(s,v+32,o.add(d[1]),r.add(y(s,v+16))),[o,n]=[n,o],v+=64}while(v!==S);const E=f.add(o.and(255).shl(1));return v=k,d[0]=d[0].add(e-1&63),c[0]=c[0].add(d[0]),d[0]=d[0].add(c[0]),n=C(n.add(r).add(c[0]).add(y(s,v+8)),37).mul(E),r=C(r.add(c[1]).add(y(s,v+48)),42).mul(E),n=n.xor(d[1].mul(9)),r=r.add(c[0].mul(9).add(y(s,v+40))),o=C(o.add(d[0]),33).mul(E),c=$(s,v,c[1].mul(E),n.add(d[0])),d=$(s,v+32,o.add(d[1]),r.add(y(s,v+16))),[o,n]=[n,o],I(I(c[0],d[0],E).add(x(r).mul(h)).add(o),I(c[1],d[1],E).add(n),E)}function k(e,t){return"string"===t?O(e):E([e],t)}function E(a,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(a)&&(a=o.m(a)),Object(r.b)().getBool("DEBUG")&&o.h(a,e),function(a,e){return a instanceof Float32Array&&"float32"===e||a instanceof Int32Array&&"int32"===e||a instanceof Uint8Array&&"bool"===e}(a,e))return a;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(a);if("int32"===e)return new Int32Array(a);if("bool"===e){const e=new Uint8Array(a.length);for(let i=0;i<e.length;++i)0!==Math.round(a[i])&&(e[i]=1);return e}throw new Error(`Unknown data type ${e}`)}function T(){return Object(r.b)().platform.now()}function R(path,e){return Object(r.b)().platform.fetch(path,e)}function O(s,e="utf-8"){return e=e||"utf-8",Object(r.b)().platform.encode(s,e)}function A(e,t="utf-8"){return t=t||"utf-8",Object(r.b)().platform.decode(e,t)}},409:function(e,t,n){"use strict";n.d(t,"a",(function(){return c})),n.d(t,"b",(function(){return d})),n.d(t,"c",(function(){return f}));var r=n(453);const o="tfjsflags";class c{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=l,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(d().getBool("IS_TEST")||d().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];d().getBool("IS_TEST")||d().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Object(r.x)(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(o in e){e[o].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)}))}}}function l(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((s,...e)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,e[0],e[1]),e.join("=")))),t}function d(){return h}let h=null;function f(e){h=e}},410:function(e,t,n){"use strict";n.d(t,"b",(function(){return c})),n.d(t,"a",(function(){return l}));var r=n(417),o=n(425);n(453);function c(a,b){if(a.dtype===b.dtype)return[a,b];const e=Object(o.b)(a.dtype,b.dtype);return[a.cast(e),b.cast(e)]}function l(e){const t=[];return d(e,t,new Set),t}function d(e,t,n){if(null==e)return;if(e instanceof r.a)return void t.push(e);if(o=e,!Array.isArray(o)&&"object"!=typeof o)return;var o;const c=e;for(const e in c){const r=c[e];n.has(r)||(n.add(r),d(r,t,n))}}},413:function(e,t,n){"use strict";(function(e){n.d(t,"e",(function(){return h})),n.d(t,"a",(function(){return x})),n.d(t,"b",(function(){return v})),n.d(t,"d",(function(){return y})),n.d(t,"c",(function(){return w})),n.d(t,"h",(function(){return C})),n.d(t,"f",(function(){return I})),n.d(t,"g",(function(){return $})),n.d(t,"i",(function(){return S}));var r=n(420),o=n(462),c=n(453),l=n(508);const d=4;function h(e,t){const n={};let h,f=0;for(const m of t){const t=m.name,x=m.dtype,v=m.shape,y=Object(c.O)(v);let w;if("quantization"in m){const n=m.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${m.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${m.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==x)throw new Error(`Weight ${m.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${x}.`)}const r=l.a[n.dtype],o=e.slice(f,f+y*r),c="uint8"===n.dtype?new Uint8Array(o):new Uint16Array(o);if("float32"===x)if("uint8"===n.dtype||"uint16"===n.dtype){w=new Float32Array(c.length);for(let i=0;i<c.length;i++){const e=c[i];w[i]=e*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===h&&(h=k()),w=h(c)}else{if("int32"!==x)throw new Error(`Unsupported dtype in weight '${t}': ${x}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);w=new Int32Array(c.length);for(let i=0;i<c.length;i++){const e=c[i];w[i]=Math.round(e*n.scale+n.min)}}f+=y*r}else if("string"===x){const t=Object(c.O)(m.shape);w=[];for(let i=0;i<t;i++){const t=new Uint32Array(e.slice(f,f+d))[0];f+=d;const n=new Uint8Array(e.slice(f,f+t));w.push(n),f+=t}}else{const c=l.a[x],d=e.slice(f,f+y*c);if("float32"===x)w=new Float32Array(d);else if("int32"===x)w=new Int32Array(d);else if("bool"===x)w=new Uint8Array(d);else{if("complex64"!==x)throw new Error(`Unsupported dtype in weight '${t}': ${x}`);{w=new Float32Array(d);const e=new Float32Array(w.length/2),image=new Float32Array(w.length/2);for(let i=0;i<e.length;i++)e[i]=w[2*i],image[i]=w[2*i+1];const c=Object(o.a)(e,v,"float32"),l=Object(o.a)(image,v,"float32");n[t]=Object(r.a)(c,l),c.dispose(),l.dispose()}}f+=y*c}"complex64"!==x&&(n[t]=Object(o.a)(w,v,x))}return n}const f=void 0!==e&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function m(t){return f?e.byteLength(t):new Blob([t]).size}function x(t){if(f)return e.from(t).toString("base64");const n=new Uint8Array(t);let s="";for(let i=0,e=n.length;i<e;i++)s+=String.fromCharCode(n[i]);return btoa(s)}function v(t){if(f){const n=e.from(t,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const s=atob(t),n=new Uint8Array(s.length);for(let i=0;i<s.length;++i)n.set([s.charCodeAt(i)],i);return n.buffer}function y(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));const n=new Uint8Array(t);let r=0;return e.forEach((e=>{n.set(new Uint8Array(e),r),r+=e.byteLength})),n.buffer}function w(path){for(path=path.trim();path.endsWith("/");)path=path.slice(0,path.length-1);const e=path.split("/");return e[e.length-1]}function C(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function I(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),function(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),r}(e,n,r)}function $(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:m(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:m(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function S(e){const t=[];for(const n of e)t.push(...n.weights);return t}function k(){const e=function(){const e=i=>{let e=i<<13,t=0;for(;0==(8388608&e);)t-=8388608,e<<=1;return e&=-8388609,t+=947912704,e|t},t=new Uint32Array(2048);t[0]=0;for(let i=1;i<1024;i++)t[i]=e(i);for(let i=1024;i<2048;i++)t[i]=939524096+(i-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let i=1;i<31;i++)e[i]=i<<23;for(let i=33;i<63;i++)e[i]=2147483648+(i-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let i=0;i<64;i++)e[i]=1024;return e[0]=e[32]=0,e}();return r=>{const o=new ArrayBuffer(4*r.length),c=new Uint32Array(o);for(let o=0;o<r.length;o++){const l=r[o],d=e[n[l>>10]+(1023&l)]+t[l>>10];c[o]=d}return new Float32Array(o)}}}).call(this,n(672).Buffer)},417:function(e,t,n){"use strict";n.d(t,"b",(function(){return w})),n.d(t,"f",(function(){return S})),n.d(t,"e",(function(){return k})),n.d(t,"d",(function(){return E})),n.d(t,"a",(function(){return T})),n.d(t,"c",(function(){return R}));var r=n(491),o=n(453);const c=20,l=3,d=7;function h(e,t,n,r){const c=Object(o.j)(t),l=function(e,t,n,r){const c=Object(o.O)(t),l=r[r.length-1],d=new Array(l).fill(0),h=t.length,m="complex64"===n?v(e):e;if(h>1)for(let e=0;e<c/l;e++){const t=e*l;for(let e=0;e<l;e++)d[e]=Math.max(d[e],f(m[t+e],0,n).length)}return d}(e,t,n,c),d=t.length,h=x(e,t,n,c,l),m=["Tensor"];return r&&(m.push(`  dtype: ${n}`),m.push(`  rank: ${d}`),m.push(`  shape: [${t}]`),m.push("  values:")),m.push(h.map((e=>"    "+e)).join("\n")),m.join("\n")}function f(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(d))} + ${parseFloat(e[1].toFixed(d))}j`:Object(o.z)(e)?`'${e}'`:"bool"===n?m(e):parseFloat(e.toFixed(d)).toString(),Object(o.L)(r,t)}function m(e){return 0===e?"false":"true"}function x(e,t,n,r,o,d=!0){const h="complex64"===n?2:1,y=t[0],w=t.length;if(0===w){if("complex64"===n){return[f(v(e)[0],0,n)]}return"bool"===n?[m(e[0])]:[e[0].toString()]}if(1===w){if(y>c){const t=l*h;let r=Array.from(e.slice(0,t)),c=Array.from(e.slice((y-l)*h,y*h));return"complex64"===n&&(r=v(r),c=v(c)),["["+r.map(((e,i)=>f(e,o[i],n))).join(", ")+", ..., "+c.map(((e,i)=>f(e,o[y-l+i],n))).join(", ")+"]"]}return["["+("complex64"===n?v(e):Array.from(e)).map(((e,i)=>f(e,o[i],n))).join(", ")+"]"]}const C=t.slice(1),I=r.slice(1),$=r[0]*h,S=[];if(y>c){for(let i=0;i<l;i++){const t=i*$,r=t+$;S.push(...x(e.slice(t,r),C,n,I,o,!1))}S.push("...");for(let i=y-l;i<y;i++){const t=i*$,r=t+$;S.push(...x(e.slice(t,r),C,n,I,o,i===y-1))}}else for(let i=0;i<y;i++){const t=i*$,r=t+$;S.push(...x(e.slice(t,r),C,n,I,o,i===y-1))}const k=2===w?",":"";S[0]="["+S[0]+k;for(let i=1;i<S.length-1;i++)S[i]=" "+S[i]+k;let E=",\n";for(let i=2;i<w;i++)E+="\n";return S[S.length-1]=" "+S[S.length-1]+"]"+(d?"":E),S}function v(e){const t=[];for(let i=0;i<e.length;i+=2)t.push([e[i],e[i+1]]);return t}var y=n(404);class w{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=o.O(e),null!=n){const e=n.length;o.b(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||o.n(t,this.size),this.strides=Object(o.j)(e)}set(e,...t){0===t.length&&(t=[0]),o.b(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let i=0;for(const t of e){if(t<0||t>=this.shape[i]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}i++}let t=e[e.length-1];for(let i=0;i<e.length-1;++i)t+=this.strides[i]*e[i];return this.values[t]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let i=0;i<e.length-1;++i)t+=this.strides[i]*e[i];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let i=0;i<t.length-1;++i)t[i]=Math.floor(e/this.strides[i]),e-=t[i]*this.strides[i];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return C().makeTensor(this.values,this.shape,this.dtype)}}let C=null,I=null,$=null;function S(e){C=e}function k(e){I=e}function E(e){$=e}class T{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=o.O(e),this.strides=Object(o.j)(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return I.buffer(this.shape,this.dtype,e)}bufferSync(){return I.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Object(o.U)(this.shape,e,"complex64"===this.dtype)}arraySync(){return Object(o.U)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const data=C().read(this.dataId);if("string"===this.dtype){const e=await data;try{return e.map((b=>y.decodeString(b)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return data}dataToGPU(e){return this.throwIfDisposed(),C().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const data=C().readSync(this.dataId);if("string"===this.dtype)try{return data.map((b=>y.decodeString(b)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return data}async bytes(){this.throwIfDisposed();const data=await C().read(this.dataId);return"string"===this.dtype?data:new Uint8Array(data.buffer)}dispose(){this.isDisposed||(C().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return I.print(this,e)}clone(){return this.throwIfDisposed(),I.clone(this)}toString(e=!1){return h(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),I.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),C().makeVariable(this,e,t,n)}}Object.defineProperty(T,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Object(r.a)("Tensor",(()=>T));class R extends T{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!o.a(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);C().disposeTensor(this),this.dataId=e.dataId,C().incRef(this,null)}dispose(){C().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(R,Symbol.hasInstance,{value:e=>e instanceof T&&null!=e.assign&&e.assign instanceof Function})},420:function(e,t,n){"use strict";n.d(t,"a",(function(){return h}));var r=n(402),o=n(403),c=n(401),l=n(453),d=n(400);const h=Object(d.a)({complex_:function(e,t){const n=Object(c.a)(e,"real","complex"),d=Object(c.a)(t,"imag","complex");l.e(n.shape,d.shape,`real and imag shapes, ${n.shape} and ${d.shape}, must match in call to tf.complex().`);const h={real:n,imag:d};return r.a.runKernel(o.z,h)}})},425:function(e,t,n){"use strict";var r,o,c,l,d;n.d(t,"b",(function(){return f})),n.d(t,"a",(function(){return m})),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(r||(r={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(o||(o={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(c||(c={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(l||(l={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(d||(d={}));const h={float32:l,int32:o,bool:c,complex64:d};function f(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return h[e][t]}function m(e){return f(e,"int32")}},453:function(e,t,n){"use strict";function r(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,d(e,t,n)}function o(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,d(e,n,r),d(t,n,r)}function c(e,t,n){return Math.max(e,Math.min(t,n))}function l(e){return e%2==0?e:e+1}function d(object,e,t){const n=object[e];object[e]=object[t],object[t]=n}function h(e){let t=0;for(let i=0;i<e.length;i++)t+=e[i];return t}function f(a,b){const e=Math.random();return b*e+(1-e)*a}function m(a,b){let e=0;for(let i=0;i<a.length;i++){const t=Number(a[i])-Number(b[i]);e+=t*t}return e}function x(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function v(e,t,n=""){x($(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function y(a){x(null!=a,(()=>"The input to the tensor constructor must be a non-null value."))}function w(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||M(e)&&!n)for(let i=0;i<e.length;++i)w(e[i],t,n);else t.push(e);return t}function C(e){if(0===e.length)return 1;let t=e[0];for(let i=1;i<e.length;i++)t*=e[i];return t}function I(e){return 0===e.length}function $(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(e[i]!==t[i])return!1;return!0}function S(a){return a%1==0}function k(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function E(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function T(e){const t=new Uint32Array(e);for(let i=0;i<e;++i)t[i]=i;return r(t),t}function R(a,e){return e<=a.length?a:a+" ".repeat(e-a.length)}function O(e,t=(e=>0),n,r=setTimeout){return new Promise(((o,c)=>{let l=0;const d=()=>{if(e())return void o();l++;const h=t(l);null!=n&&l>=n?c():r(d,h)};d()}))}function A(e,t){let n=1,r=-1;for(let i=0;i<e.length;++i)if(e[i]>=0)n*=e[i];else if(-1===e[i]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(e[i]<0)throw Error(`Shapes can not be < 0. Found ${e[i]} at dim ${i}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const o=e.slice();return o[r]=t/n,o}function N(e,t){const n=t.length;return x((e=null==e?t.map(((s,i)=>i)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),x(e.every((e=>S(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((a=>a<0?n+a:a))}function _(e,t){const n=[],r=[],o=null!=t&&Array.isArray(t)&&0===t.length,c=null==t||o?null:N(t,e).sort();let l=0;for(let i=0;i<e.length;++i){if(null!=c){if(c[l]===i&&1!==e[i])throw new Error(`Can't squeeze axis ${i} since its dim '${e[i]}' is not 1`);(null==c[l]||c[l]>i)&&1===e[i]&&(n.push(e[i]),r.push(i)),c[l]<=i&&l++}1!==e[i]&&(n.push(e[i]),r.push(i))}return{newShape:n,keptDims:r}}function F(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function D(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function P(e,t){for(let i=0;i<e.length;i++){const n=e[i];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function L(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function B(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function M(a){return a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array||a instanceof Uint8ClampedArray}function j(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function U(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function W(e){return"string"==typeof e||e instanceof String}function V(e){return"boolean"==typeof e}function z(e){return"number"==typeof e}function G(e){return Array.isArray(e)?G(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":z(e)?"float32":W(e)?"string":V(e)?"bool":"float32"}function H(e){return!!(e&&e.constructor&&e.call&&e.apply)}function X(e,t){for(let i=t;i<e;++i)if(e%i==0)return i;return e}function K(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let i=t-3;i>=0;--i)n[i]=n[i+1]*e[i+1];return n}function Y(e,t,a,n=!1){const r=new Array;if(1===t.length){const o=t[0]*(n?2:1);for(let i=0;i<o;i++)r[i]=a[e+i]}else{const o=t[0],c=t.slice(1),l=c.reduce(((e,t)=>e*t))*(n?2:1);for(let i=0;i<o;i++)r[i]=Y(e+i*l,c,a,n)}return r}function Z(e,a,t=!1){if(0===e.length)return a[0];const n=e.reduce(((e,t)=>e*t))*(t?2:1);if(0===n)return[];if(n!==a.length)throw new Error(`[${e}] does not match the input size ${a.length}${t?" for a complex tensor":""}.`);return Y(0,e,a,t)}function Q(e,t){const n=J(e,t);for(let i=0;i<n.length;i++)n[i]=1;return n}function J(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function ee(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return Z(e,new Float32Array(n));if("int32"===t)return Z(e,new Int32Array(n));if("bool"===t)return Z(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function te(e){e.forEach((t=>{x(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function ne(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let i=0;i<e.length-1;++i)r+=n[i]*e[i];return r}function re(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let i=0;i<r.length-1;++i)r[i]=Math.floor(e/n[i]),e-=r[i]*n[i];return r[r.length-1]=e,r}function oe(object){return object&&object.then&&"function"==typeof object.then}n.d(t,"M",(function(){return r})),n.d(t,"N",(function(){return o})),n.d(t,"i",(function(){return c})),n.d(t,"H",(function(){return l})),n.d(t,"S",(function(){return d})),n.d(t,"R",(function(){return h})),n.d(t,"J",(function(){return f})),n.d(t,"l",(function(){return m})),n.d(t,"b",(function(){return x})),n.d(t,"e",(function(){return v})),n.d(t,"d",(function(){return y})),n.d(t,"m",(function(){return w})),n.d(t,"O",(function(){return C})),n.d(t,"y",(function(){return I})),n.d(t,"a",(function(){return $})),n.d(t,"v",(function(){return S})),n.d(t,"T",(function(){return k})),n.d(t,"P",(function(){return E})),n.d(t,"k",(function(){return T})),n.d(t,"L",(function(){return R})),n.d(t,"K",(function(){return O})),n.d(t,"s",(function(){return A})),n.d(t,"I",(function(){return N})),n.d(t,"Q",(function(){return _})),n.d(t,"o",(function(){return F})),n.d(t,"n",(function(){return D})),n.d(t,"h",(function(){return P})),n.d(t,"B",(function(){return L})),n.d(t,"p",(function(){return B})),n.d(t,"A",(function(){return M})),n.d(t,"g",(function(){return j})),n.d(t,"f",(function(){return U})),n.d(t,"z",(function(){return W})),n.d(t,"t",(function(){return V})),n.d(t,"w",(function(){return z})),n.d(t,"r",(function(){return G})),n.d(t,"u",(function(){return H})),n.d(t,"G",(function(){return X})),n.d(t,"j",(function(){return K})),n.d(t,"U",(function(){return Z})),n.d(t,"D",(function(){return Q})),n.d(t,"F",(function(){return J})),n.d(t,"E",(function(){return ee})),n.d(t,"c",(function(){return te})),n.d(t,"C",(function(){return ne})),n.d(t,"q",(function(){return re})),n.d(t,"x",(function(){return oe}))},454:function(e,t,n){"use strict";(function(e){n(402);var t=n(493),r=n(409);const o=Object(r.b)();o.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),o.registerFlag("IS_BROWSER",(()=>t.isBrowser())),o.registerFlag("IS_NODE",(()=>void 0!==e&&void 0!==e.versions&&void 0!==e.versions.node)),o.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),o.registerFlag("PROD",(()=>!1)),o.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>o.getBool("DEBUG"))),o.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),o.registerFlag("IS_TEST",(()=>!1)),o.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),o.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),o.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1)),o.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),o.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1))}).call(this,n(263))},458:function(e,t,n){"use strict";n.d(t,"a",(function(){return vg})),n.d(t,"b",(function(){return yg}));var r={};n.r(r),n.d(r,"getBroadcastDims",(function(){return le})),n.d(r,"getReductionAxes",(function(){return de})),n.d(r,"assertAndGetBroadcastShape",(function(){return he}));var o={};n.r(o),n.d(o,"assertParamsValid",(function(){return ge})),n.d(o,"maskToAxes",(function(){return me})),n.d(o,"computeOutShape",(function(){return be})),n.d(o,"stridesWithElidedDims",(function(){return xe})),n.d(o,"getNormalizedAxes",(function(){return we})),n.d(o,"startIndicesWithElidedDims",(function(){return Ce})),n.d(o,"stopIndicesWithElidedDims",(function(){return Ie})),n.d(o,"stridesForAxis",(function(){return $e})),n.d(o,"startForAxis",(function(){return Se})),n.d(o,"stopForAxis",(function(){return ke})),n.d(o,"isSliceContinous",(function(){return Ee})),n.d(o,"computeFlatOffset",(function(){return Te})),n.d(o,"parseSliceParams",(function(){return Re})),n.d(o,"sliceInfo",(function(){return Oe}));var c={};n.r(c),n.d(c,"segOpComputeOptimalWindowSize",(function(){return Yr})),n.d(c,"computeOutShape",(function(){return Zr})),n.d(c,"collectGatherOpShapeInfo",(function(){return Qr}));var l={};n.r(l),n.d(l,"axesAreInnerMostDims",(function(){return Nt})),n.d(l,"combineLocations",(function(){return _t})),n.d(l,"computeOutAndReduceShapes",(function(){return Ft})),n.d(l,"expandShapeToKeepDim",(function(){return Dt})),n.d(l,"assertAxesAreInnerMostDims",(function(){return Pt})),n.d(l,"getAxesPermutation",(function(){return Lt})),n.d(l,"getUndoAxesPermutation",(function(){return Bt})),n.d(l,"getInnerMostAxes",(function(){return Mt})),n.d(l,"getBroadcastDims",(function(){return le})),n.d(l,"getReductionAxes",(function(){return de})),n.d(l,"assertAndGetBroadcastShape",(function(){return he})),n.d(l,"assertParamsConsistent",(function(){return xn})),n.d(l,"computeOutShape",(function(){return vn})),n.d(l,"computeDilation2DInfo",(function(){return yn})),n.d(l,"computePool2DInfo",(function(){return wn})),n.d(l,"computePool3DInfo",(function(){return Cn})),n.d(l,"computeConv2DInfo",(function(){return In})),n.d(l,"computeConv3DInfo",(function(){return $n})),n.d(l,"computeDefaultPad",(function(){return Sn})),n.d(l,"tupleValuesAreOne",(function(){return On})),n.d(l,"eitherStridesOrDilationsAreOne",(function(){return An})),n.d(l,"convertConv2DDataFormat",(function(){return Nn})),n.d(l,"checkPadOnDimRoundingMode",(function(){return _n})),n.d(l,"getFusedDyActivation",(function(){return jn})),n.d(l,"getFusedBiasGradient",(function(){return Un})),n.d(l,"applyActivation",(function(){return Wn})),n.d(l,"shouldFuse",(function(){return Vn})),n.d(l,"RowPartitionType",(function(){return zn})),n.d(l,"combineRaggedTensorToTensorShapes",(function(){return Gn})),n.d(l,"getRowPartitionTypesHelper",(function(){return Hn})),n.d(l,"getRaggedRank",(function(){return Xn})),n.d(l,"validateDefaultValueShape",(function(){return qn})),n.d(l,"PARALLELIZE_THRESHOLD",(function(){return Kn})),n.d(l,"computeOptimalWindowSize",(function(){return Yn})),n.d(l,"slice_util",(function(){return o})),n.d(l,"upcastType",(function(){return _e.b})),n.d(l,"getImageCenter",(function(){return Zn})),n.d(l,"getReshaped",(function(){return Qn})),n.d(l,"getPermuted",(function(){return Jn})),n.d(l,"getReshapedPermuted",(function(){return er})),n.d(l,"getSliceBeginCoords",(function(){return nr})),n.d(l,"getSliceSize",(function(){return rr})),n.d(l,"prepareAndValidate",(function(){return or})),n.d(l,"validateUpdateShape",(function(){return ir})),n.d(l,"validateInput",(function(){return ar})),n.d(l,"calculateShapes",(function(){return sr})),n.d(l,"SELU_SCALEALPHA",(function(){return ur})),n.d(l,"SELU_SCALE",(function(){return cr})),n.d(l,"ERF_P",(function(){return lr})),n.d(l,"ERF_A1",(function(){return dr})),n.d(l,"ERF_A2",(function(){return pr})),n.d(l,"ERF_A3",(function(){return fr})),n.d(l,"ERF_A4",(function(){return gr})),n.d(l,"ERF_A5",(function(){return mr})),n.d(l,"warn",(function(){return xr.b})),n.d(l,"log",(function(){return xr.a})),n.d(l,"mergeRealAndImagArrays",(function(){return vr})),n.d(l,"splitRealAndImagArrays",(function(){return yr})),n.d(l,"complexWithEvenIndex",(function(){return wr})),n.d(l,"complexWithOddIndex",(function(){return Cr})),n.d(l,"getComplexWithIndex",(function(){return Ir})),n.d(l,"assignToTypedArray",(function(){return $r})),n.d(l,"exponents",(function(){return Sr})),n.d(l,"exponent",(function(){return kr})),n.d(l,"decodeEinsumEquation",(function(){return Ar})),n.d(l,"getEinsumPermutation",(function(){return Nr})),n.d(l,"checkEinsumDimSizes",(function(){return _r})),n.d(l,"getEinsumComputePath",(function(){return Fr})),n.d(l,"isIdentityPermutation",(function(){return Dr})),n.d(l,"prepareSplitSize",(function(){return Lr})),n.d(l,"getSparseFillEmptyRowsIndicesDenseShapeMismatch",(function(){return Br})),n.d(l,"getSparseFillEmptyRowsNegativeIndexErrorMessage",(function(){return Mr})),n.d(l,"getSparseFillEmptyRowsOutOfRangeIndexErrorMessage",(function(){return jr})),n.d(l,"getSparseReshapeMultipleNegativeOneOutputDimErrorMessage",(function(){return Ur})),n.d(l,"getSparseReshapeNegativeOutputDimErrorMessage",(function(){return Wr})),n.d(l,"getSparseReshapeEmptyTensorZeroOutputDimErrorMessage",(function(){return Vr})),n.d(l,"getSparseReshapeInputOutputMultipleErrorMessage",(function(){return zr})),n.d(l,"getSparseReshapeInputOutputMismatchErrorMessage",(function(){return Gr})),n.d(l,"getSparseSegmentReductionNegativeSegmentIdsErrorMessage",(function(){return Hr})),n.d(l,"getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage",(function(){return Xr})),n.d(l,"getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage",(function(){return qr})),n.d(l,"getSparseSegmentReductionIndicesOutOfRangeErrorMessage",(function(){return Kr})),n.d(l,"segment_util",(function(){return c})),n.d(l,"fromUint8ToStringArray",(function(){return Jr})),n.d(l,"fromStringArrayToUint8",(function(){return eo}));var d={};n.r(d),n.d(d,"nonMaxSuppressionV3Impl",(function(){return ct})),n.d(d,"nonMaxSuppressionV4Impl",(function(){return lt})),n.d(d,"nonMaxSuppressionV5Impl",(function(){return ht})),n.d(d,"whereImpl",(function(){return no}));var h={};n.r(h),n.d(h,"simpleAbsImpl",(function(){return Ai})),n.d(h,"addImpl",(function(){return Ui})),n.d(h,"bincountImpl",(function(){return Vi})),n.d(h,"bincountReduceImpl",(function(){return zi})),n.d(h,"castImpl",(function(){return Li})),n.d(h,"ceilImpl",(function(){return qi})),n.d(h,"concatImpl",(function(){return Ki})),n.d(h,"equalImpl",(function(){return Yi})),n.d(h,"expImpl",(function(){return Zi})),n.d(h,"expm1Impl",(function(){return Qi})),n.d(h,"floorImpl",(function(){return Ji})),n.d(h,"gatherNdImpl",(function(){return ea})),n.d(h,"gatherV2Impl",(function(){return ta})),n.d(h,"greaterImpl",(function(){return na})),n.d(h,"greaterEqualImpl",(function(){return ra})),n.d(h,"lessImpl",(function(){return oa})),n.d(h,"lessEqualImpl",(function(){return ia})),n.d(h,"linSpaceImpl",(function(){return aa})),n.d(h,"logImpl",(function(){return sa})),n.d(h,"maxImpl",(function(){return ua})),n.d(h,"maximumImpl",(function(){return ca})),n.d(h,"minimumImpl",(function(){return la})),n.d(h,"multiplyImpl",(function(){return da})),n.d(h,"negImpl",(function(){return pa})),n.d(h,"notEqualImpl",(function(){return fa})),n.d(h,"prodImpl",(function(){return ma})),n.d(h,"raggedGatherImpl",(function(){return ya})),n.d(h,"raggedTensorToTensorImpl",(function(){return Sa})),n.d(h,"rangeImpl",(function(){return ka})),n.d(h,"rsqrtImpl",(function(){return Ea})),n.d(h,"scatterImpl",(function(){return Ta})),n.d(h,"sigmoidImpl",(function(){return Ra})),n.d(h,"sliceImpl",(function(){return Oa})),n.d(h,"sparseFillEmptyRowsImpl",(function(){return Aa})),n.d(h,"sparseReshapeImpl",(function(){return Na})),n.d(h,"sparseSegmentReductionImpl",(function(){return _a})),n.d(h,"sqrtImpl",(function(){return Fa})),n.d(h,"squaredDifferenceImpl",(function(){return Da})),n.d(h,"stridedSliceImpl",(function(){return Pa})),n.d(h,"stringNGramsImpl",(function(){return Ba})),n.d(h,"stringSplitImpl",(function(){return ja})),n.d(h,"stringToHashBucketFastImpl",(function(){return Ua})),n.d(h,"subImpl",(function(){return Wa})),n.d(h,"tileImpl",(function(){return za})),n.d(h,"topKImpl",(function(){return Xa})),n.d(h,"transposeImpl",(function(){return ga})),n.d(h,"uniqueImpl",(function(){return qa}));var f=n(505),m=n(412),x=n(402),v=(n(454),n(409)),y=n(413);class w{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==w.instance&&(w.instance=new w),w.instance}static registerSaveRouter(e){w.getInstance().saveRouters.push(e)}static registerLoadRouter(e){w.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return w.getHandlers(e,"save")}static getLoadHandlers(e,t){return w.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?w.getInstance().loadRouters:w.getInstance().saveRouters).forEach((t=>{const o=t(e,n);null!==o&&r.push(o)})),r}}const C="tensorflowjs",I="models_store",$="model_info_store";function S(){if(!Object(v.b)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function k(e){const t=e.result;t.createObjectStore(I,{keyPath:"modelPath"}),t.createObjectStore($,{keyPath:"modelPath"})}class E{constructor(e){if(this.indexedDB=S(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(C,1);r.onupgradeneeded=()=>k(r),r.onsuccess=()=>{const o=r.result;if(null==t){const t=o.transaction(I,"readonly"),r=t.objectStore(I).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return o.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(o.close(),n(r.error)),t.oncomplete=()=>o.close()}else{const r=Object(y.g)(t),c=o.transaction($,"readwrite");let l=c.objectStore($);const d=l.put({modelPath:this.modelPath,modelArtifactsInfo:r});let h;d.onsuccess=()=>{h=o.transaction(I,"readwrite");const d=h.objectStore(I).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r});d.onsuccess=()=>e({modelArtifactsInfo:r}),d.onerror=e=>{l=c.objectStore($);const t=l.delete(this.modelPath);t.onsuccess=()=>(o.close(),n(d.error)),t.onerror=e=>(o.close(),n(d.error))}},d.onerror=e=>(o.close(),n(d.error)),c.oncomplete=()=>{null==h?o.close():h.oncomplete=()=>o.close()}}},r.onerror=e=>n(r.error)}))}}E.URL_SCHEME="indexeddb://";const T=e=>{return Object(v.b)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(E.URL_SCHEME)?(t=e.slice(E.URL_SCHEME.length),new E(t)):null;var t};w.registerSaveRouter(T),w.registerLoadRouter(T);class R{constructor(){this.indexedDB=S()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(C,1);n.onupgradeneeded=()=>k(n),n.onsuccess=()=>{const r=n.result,o=r.transaction($,"readonly"),c=o.objectStore($).getAll();c.onsuccess=()=>{const t={};for(const e of c.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},c.onerror=e=>(r.close(),t(c.error)),o.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(path){var e;return path=(e=path).startsWith(E.URL_SCHEME)?e.slice(E.URL_SCHEME.length):e,new Promise(((e,t)=>{const n=this.indexedDB.open(C,1);n.onupgradeneeded=()=>k(n),n.onsuccess=()=>{const r=n.result,o=r.transaction($,"readwrite"),c=o.objectStore($),l=c.get(path);let d;l.onsuccess=()=>{if(null==l.result)return r.close(),t(new Error(`Cannot find model with path '${path}' in IndexedDB.`));{const n=c.delete(path),o=()=>{d=r.transaction(I,"readwrite");const n=d.objectStore(I).delete(path);n.onsuccess=()=>e(l.result.modelArtifactsInfo),n.onerror=e=>t(l.error)};n.onsuccess=o,n.onerror=e=>(o(),r.close(),t(l.error))}},l.onerror=e=>(r.close(),t(l.error)),o.oncomplete=()=>{null==d?r.close():d.oncomplete=()=>r.close()}},n.onerror=e=>t(n.error)}))}}var O=n(453);const A="/",N="tensorflowjs_models",_="info",F="model_topology",D="weight_specs",P="weight_data",L="model_metadata";function B(path){return{info:[N,path,_].join(A),topology:[N,path,F].join(A),weightSpecs:[N,path,D].join(A),weightData:[N,path,P].join(A),modelMetadata:[N,path,L].join(A)}}function M(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function j(e){const t=e.split(A);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(A)}class U{constructor(e){if(!Object(v.b)().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=B(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=Object(y.g)(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,Object(y.a)(e.weightData));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:r}}catch(e){throw M(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(null!=o){const e=JSON.parse(o);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const c=this.LS.getItem(this.keys.weightData);if(null==c)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Object(y.b)(c),t}}U.URL_SCHEME="localstorage://";const W=e=>{return Object(v.b)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(U.URL_SCHEME)?(t=e.slice(U.URL_SCHEME.length),new U(t)):null;var t};w.registerSaveRouter(W),w.registerLoadRouter(W);class V{constructor(){Object(O.b)(Object(v.b)().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Object(O.b)("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=N+A,n=A+_;for(let i=0;i<this.LS.length;++i){const r=this.LS.key(i);if(r.startsWith(t)&&r.endsWith(n)){e[j(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(path){var e;const t=B(path=(e=path).startsWith(U.URL_SCHEME)?e.slice(U.URL_SCHEME.length):e);if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${path}'`);const n=JSON.parse(this.LS.getItem(t.info));return M(t),n}}const z="://";class G{constructor(){this.managers={}}static getInstance(){return null==G.instance&&(G.instance=new G),G.instance}static registerManager(e,t){Object(O.b)(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(z)&&(e=e.slice(0,e.indexOf(z))),Object(O.b)(e.length>0,(()=>"scheme must not be an empty string."));const n=G.getInstance();Object(O.b)(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=G.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(G.getInstance().managers)}}class H{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(path,e){return fetch(path,e)}now(){return performance.now()}encode(text,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(text)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){window&&Object(v.b)().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}}if(Object(v.b)().get("IS_BROWSER")){Object(v.b)().setPlatform("browser",new H);try{G.registerManager(U.URL_SCHEME,new V)}catch(e){}try{G.registerManager(E.URL_SCHEME,new R)}catch(e){}}n(676);var X=n(417);function K(e,t="float32",n){return t=t||"float32",O.c(e),new X.b(e,t,n)}var Y=n(403),Z=n(401),Q=n(400);const J=Object(Q.a)({cast_:function(e,t){const n=Object(Z.a)(e,"x","cast");if(!O.B(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},o={dtype:t};return x.a.runKernel(Y.w,r,o)}});const ee=Object(Q.a)({clone_:function(e){const t={x:Object(Z.a)(e,"x","clone","string_or_numeric")};return x.a.runKernel(Y.qb,t)}});Object(x.b)();const te={buffer:K,cast:J,clone:ee,print:function(e,t=!1){console.log(e.toString(t))}};Object(X.e)(te);function ne(e){return new Promise((e=>setTimeout(e))).then(e)}class re{constructor(e){if(!Object(v.b)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(re.URL_SCHEME)&&(e=e.slice(re.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=Object(y.h)(e,n),o=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),c=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(c.download=this.modelJsonFileName,c.href=o,await ne((()=>c.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await ne((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Object(y.g)(e)}}}}re.URL_SCHEME="downloads://";function oe(e,t,n,r){!function(e){Object(O.b)(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){Object(O.b)(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),Object(O.b)(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),Object(O.b)(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let o=0;return Promise.all(e.map((c=>(c.then((c=>{const l=n+ ++o/e.length*(r-n);return t(l),c})),c))))}w.registerSaveRouter((e=>Object(v.b)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(re.URL_SCHEME)?function(e="model"){return new re(e)}(e.slice(re.URL_SCHEME.length)):null));n(508);async function ie(e,t){null==t&&(t={});const n=null==t.fetchFunc?Object(v.b)().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),o=(null==t.onProgress?await Promise.all(r):await oe(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(o):await oe(o,t.onProgress,.5,1)}class ae{constructor(path,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?(Object(O.b)("function"==typeof e.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=e.fetchFunc):this.fetch=Object(v.b)().platform.fetch,Object(O.b)(null!=path&&path.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(path)&&Object(O.b)(2===path.length,(()=>`URL paths for http must have a length of 2, (actual length is ${path.length}).`)),this.path=path,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=Object(y.h)(e,n);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const o=await this.fetch(this.path,t);if(o.ok)return{modelArtifactsInfo:Object(y.g)(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Object(y.f)(t,(e=>this.loadWeights(e)))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),o=n>t?e.substring(n):"";return[r+"/",o]}(t),o=this.weightPathPrefix||n,c=Object(y.i)(e),l=[],d=[];for(const t of e)for(const path of t.paths)null!=this.weightUrlConverter?d.push(this.weightUrlConverter(path)):l.push(o+path+r);this.weightUrlConverter&&l.push(...await Promise.all(d));const h=await ie(l,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[c,Object(y.d)(h)]}}function se(e){return null!=e.match(ae.URL_SCHEME_REGEX)}ae.URL_SCHEME_REGEX=/^https?:\/\//;const ue=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>se(e))):se(e),n)return ce(e,t)}return null};function ce(path,e){return new ae(path,e)}w.registerSaveRouter(ue),w.registerLoadRouter(ue);function le(e,t){const n=e.length,r=[];for(let i=0;i<n;i++){const o=n-1-i,a=e[o]||1;(t[t.length-1-i]||1)>1&&1===a&&r.unshift(o)}return r}function de(e,t){const n=[];for(let i=0;i<t.length;i++){const r=e[e.length-i-1],o=t.length-i-1,c=t[o];(null==r||1===r&&c>1)&&n.unshift(o)}return n}function he(e,t){const n=[],r=Math.max(e.length,t.length);for(let i=0;i<r;i++){let a=e[e.length-i-1];null==a&&(a=1);let b=t[t.length-i-1];if(null==b&&(b=1),1===a)n.unshift(b);else if(1===b)n.unshift(a);else{if(a!==b){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}n.unshift(a)}}return n}const pe=-2,fe=-1;function ge(input,e,t){const n=input.shape.length;O.b(n===e.length,(()=>`Error in slice${n}D: Length of begin ${e} must match the rank of the array (${n}).`)),O.b(n===t.length,(()=>`Error in slice${n}D: Length of size ${t} must match the rank of the array (${n}).`));for(let i=0;i<n;++i)O.b(e[i]+t[i]<=input.shape[i],(()=>`Error in slice${n}D: begin[${i}] + size[${i}] (${e[i]+t[i]}) would overflow input.shape[${i}] (${input.shape[i]})`))}function me(mask){const e=[];let t=0;for(;mask>0;)1&mask&&e.push(t),mask/=2,t++;return e}function be(e,t,n){const r=[];for(let o=0;o<e.length;o++)r[o]=Math.ceil((t[o]-e[o])/n[o]);return r}function xe(e,t,n,r){const o=[...e];for(let i=o.length;i<r.length;i++)o.push(1);for(let i=0;i<n;i++)0===i?o[t]=1:(o.splice(t,0,1),o.pop());return o}function ve(e,t,n){return n<=e?n:n-(t-1)}function ye(e,t){const n=[];for(let i=0;i<e;i++)n.push(t+i);return n}function we(e,t,n,r,o,c,l,d,h){const f=e.length;let m=new Array(f),x=new Array(f),v=new Array(f);if(t.length&&n>0){const h=t[0],f=n+1;m=Ce(l,h,f,r,e),x=Ie(d,h,f,o,e),v=xe(c,h,f,e)}else for(let t=0;t<f;t++)m[t]=Se(l,r,c,e,t,h),x[t]=ke(d,o,c,e,t,h),v[t]=$e(c,t,h);return{begin:m,end:x,strides:v}}function Ce(e,t,n,r,o){const c=[...o],l=ye(n,t);for(let o=0;o<c.length;o++)if(l.indexOf(o)>-1)c[o]=0;else{const l=ve(t,n,o);let d=r[l];e&1<<l&&(d=0),c[o]=d}return c}function Ie(e,t,n,r,o){const c=[...o],l=ye(n,t);for(let o=0;o<c.length;o++)if(l.indexOf(o)>-1)c[o]=Number.MAX_SAFE_INTEGER;else{const l=ve(t,n,o);let d=r[l];e&1<<l&&(d=Number.MAX_SAFE_INTEGER),c[o]=d}for(let i=0;i<c.length;i++){const e=o[i];c[i]<0&&(c[i]+=e),c[i]=O.i(0,c[i],o[i])}return c}function $e(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function Se(e,t,n,r,o,c){let l=t[o];const d=n[o]||1;(e&1<<o||c&1<<o||null==l)&&(l=d>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const h=r[o];return l<0&&(l+=h),l=O.i(0,l,h-1),l}function ke(e,t,n,r,o,c){let l=t[o];const d=n[o]||1;(e&1<<o||c&1<<o||null==l)&&(l=d>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const h=r[o];return l<0&&(l+=h),l=d>0?O.i(0,l,h):O.i(-1,l,h-1),l}function Ee(e,t,n){let r=n.length;for(let i=0;i<n.length;i++)if(n[i]>1){r=i;break}for(let i=r+1;i<n.length;i++)if(t[i]>0||n[i]!==e[i])return!1;return!0}function Te(e,t){let n=e.length>0?e[e.length-1]:1;for(let i=0;i<e.length-1;i++)n+=e[i]*t[i];return n}function Re(e,t,n){let r;const o=e.shape.length;let c;return r="number"==typeof t?[t,...new Array(o-1).fill(0)]:t.length<o?t.concat(new Array(o-t.length).fill(0)):t.slice(),r.forEach((e=>{O.b(-1!==e,(()=>"slice() does not support negative begin indexing."))})),c=null==n?new Array(o).fill(-1):"number"==typeof n?[n,...new Array(o-1).fill(-1)]:n.length<o?n.concat(new Array(o-n.length).fill(-1)):n,c=c.map(((t,i)=>t>=0?t:(O.b(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${i}.`)),e.shape[i]-r[i]))),[r,c]}function Oe(e,t,n,r,o,c,l,d,h){let f;if(null==r?(f=new Array(t.length),f.fill(1)):f=r,null!=l&&0!=(l&l-1))throw new Error("Multiple ellipses in slice is not allowed.");let m=!1;const x={dims:f.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:f.slice(),beginMask:o,endMask:c,ellipsisMask:l,newAxisMask:d,shrinkAxisMask:h};for(let i=0;i<x.dims;i++)m&&0!=(1<<i&d)&&x.numAddAxisAfterEllipsis++,1<<i&l&&(m=!0);m||(x.ellipsisMask|=1<<x.dims,x.dims++);const v={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let i=0;i<e.dims;i++)if(1<<i&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-i)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=i}else if(1<<i&e.newAxisMask)t.finalShapeGatherIndices.push(pe),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[i]),null!=e.end&&(t.end[n]=e.end[i]),t.strides[n]=e.strides[i],e.beginMask&1<<i&&(t.beginMask|=1<<n),e.endMask&1<<i&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<i?(t.finalShapeGatherIndices.push(fe),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(i)),t.inputShapeGatherIndicesSparse[n]=i,n++}}(x,v);let y=!0,w=!0,C=!0;const I=[],$=[];for(let i=0;i<e.length;++i){if(0===v.strides[i])throw Error(`strides[${i}] must be non-zero`);const t=!!(v.shrinkAxisMask&1<<i),n=e[i];if(-1===n){I.push(t?1:-1);continue}const r=[v.beginMask&1<<i,v.endMask&1<<i],o=[v.strides[i]>0?0:-1,v.strides[i]>0?n:n-1];if(t&&v.strides[i]<=0)throw Error("only stride 1 allowed on non-range indexing.");C=C&&1===v.strides[i];const c=!!(v.beginMask&1<<i&&v.endMask&1<<i);if(v.beginValid&&v.endValid){if(t){const e=v.begin[i]<0?n+v.begin[i]:v.begin[i];if(v.begin[i]=e,v.end[i]=v.begin[i]+1,e<0||e>=n)throw Error(`slice index ${v.begin[i]} of dimension ${i} out of bounds.`)}else v.begin[i]=Ae(v.begin[i],0,v.strides[i],n,r,o),v.end[i]=Ae(v.end[i],1,v.strides[i],n,r,o);const e=1===v.strides[i]&&0===v.begin[i]&&v.end[i]===n;y=y&&e,w=w&&(0===i&&1===v.strides[i]||e)}else y=y&&1===v.strides[i]&&c,w=w&&(0===i&&1===v.strides[i]||c);let l,d=!1;if(v.beginValid&&v.endValid?(l=v.end[i]-v.begin[i],d=!0):t?(l=1,d=!0):c&&n>=0&&(l=v.strides[i]<0?-n:n,d=!0),d){let e;e=0===l||l<0!=v.strides[i]<0?0:Math.trunc(l/v.strides[i])+(l%v.strides[i]!=0?1:0),I.push(e)}else I.push(-1)}for(let e=0;e<v.finalShapeGatherIndices.length;++e){const t=v.finalShapeGatherIndices[e];t>=0?$.push(I[t]):t===pe&&$.push(1)}return{finalShapeSparse:$.filter(((e,i)=>v.finalShapeGatherIndices[i]!==pe)),finalShape:$,isIdentity:y,sliceDim0:w,isSimpleSlice:C,begin:v.begin,end:v.end,strides:v.strides}}function Ae(e,t,n,r,o,c){if(o[t])return n>0?c[t]:c[t+1&1];{const t=e<0?r+e:e;return t<c[0]?c[0]:t>c[1]?c[1]:t}}var Ne=n(404),_e=n(425);const Fe=Object(Q.a)({reshape_:function(e,t){const n={x:Object(Z.a)(e,"x","reshape","string_or_numeric")},r={shape:t};return x.a.runKernel(Y.oc,n,r)}});const De=Object(Q.a)({broadcastTo_:function(e,t){let input=Object(Z.a)(e,"broadcastTo","x");const n=input.shape;if(t.some((e=>!(e>0)||e%1!=0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<input.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${input.rank}.`);if(t.length>input.rank){const e=input.shape.slice();for(;e.length<t.length;)e.unshift(1);input=Fe(input,e)}const r=input.shape,o=Array.from(t);for(let i=t.length-1;i>=0;i--)if(r[i]===t[i])o[i]=1;else if(1!==input.shape[i])throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);if(0===o.map(((e,i)=>e>1?i:-1)).filter((i=>i>=0)).length)return ee(input);const c={x:input},l={reps:o};return x.a.runKernel(Y.bd,c,l)}});var Pe=n(463);function Le(e,t){if((Object(O.A)(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Object(O.A)(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Object(Pe.a)(e,[],[],t)}var Be=n(420);function Me(e,t="float32"){if("complex64"===t){const t=Me(e,"float32"),n=Me(e,"float32");return Object(Be.a)(t,n)}const n=Object(O.F)(Object(O.O)(e),t);return x.a.makeTensor(n,e,t)}const je=Object(Q.a)({concat_:function(e,t=0){Object(O.b)(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=Object(Z.b)(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return ee(n[0]);const r=n,o={axis:t};return x.a.runKernel(Y.B,r,o)}});const Ue=Object(Q.a)({imag_:function(input){const e={input:Object(Z.a)(input,"input","imag")};return x.a.runKernel(Y.rb,e)}});const We=Object(Q.a)({real_:function(input){const e={input:Object(Z.a)(input,"input","real")};return x.a.runKernel(Y.jc,e)}});const Ve=Object(Q.a)({slice_:function(e,t,n){const r=Object(Z.a)(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const o={x:r},c={begin:t,size:n};return x.a.runKernel(Y.Fc,o,c)}});const ze=Object(Q.a)({split_:function(e,t,n=0){const r={x:Object(Z.a)(e,"x","split")},o={numOrSizeSplits:t,axis:n};return x.a.runKernel(Y.Oc,r,o)}});const Ge=Object(Q.a)({zerosLike_:function(e){const t={x:Object(Z.a)(e,"x","zerosLike")};return x.a.runKernel(Y.id,t)}});const He=Object(Q.a)({fft_:function(input){Object(O.b)("complex64"===input.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${input.dtype}.`));const e={input:input};return x.a.runKernel(Y.cb,e)}});const Xe=Object(Q.a)({rfft_:function(input,e){Object(O.b)("float32"===input.dtype,(()=>`The dtype for rfft() must be real value but got ${input.dtype}`));let t=input.shape[input.shape.length-1];const n=input.size/t;let r;if(null!=e&&e<t){const n=input.shape.map((e=>0)),o=input.shape.map((e=>e));o[input.shape.length-1]=e,r=Ve(input,n,o),t=e}else if(null!=e&&e>t){const n=input.shape.map((e=>e));n[input.shape.length-1]=e-t,r=je([input,Me(n)],input.shape.length-1),t=e}else r=input;const o=Ge(r),c=Fe(Object(Be.a)(r,o),[n,t]),l=He(c),d=Math.floor(t/2)+1,h=We(l),f=Ue(l),m=ze(h,[d,t-d],h.shape.length-1),x=ze(f,[d,t-d],f.shape.length-1),v=r.shape.slice();return v[r.shape.length-1]=d,Fe(Object(Be.a)(m[0],x[0]),v)}});const qe=Object(Q.a)({ifft_:function(input){Object(O.b)("complex64"===input.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${input.dtype}.`));const e={input:input};return x.a.runKernel(Y.pb,e)}});var Ke=n(410);const Ye=Object(Q.a)({mul_:function(a,b){let e=Object(Z.a)(a,"a","mul"),t=Object(Z.a)(b,"b","mul");[e,t]=Object(Ke.b)(e,t);const n={a:e,b:t};return x.a.runKernel(Y.Tb,n)}});const Ze=Object(Q.a)({reverse_:function(e,t){const n={x:Object(Z.a)(e,"x","reverse")},r={dims:t};return x.a.runKernel(Y.tc,n,r)}});Object(Q.a)({irfft_:function(input){const e=input.shape[input.shape.length-1],t=input.size/e;let n;if(e<=2){const r=Fe(input,[t,e]);n=qe(r)}else{const r=[t,2*(e-1)],o=Fe(We(input),[t,e]),c=Fe(Ue(input),[t,e]),l=Ze(Ve(o,[0,1],[t,e-2]),1),d=Ye(Ze(Ve(c,[0,1],[t,e-2]),1),Le(-1)),h=je([o,l],1),i=je([c,d],1),f=Fe(Object(Be.a)(h,i),[r[0],r[1]]);n=qe(f)}if(n=We(n),3===input.rank&&0!==input.shape[0]){const e=n,t=input.shape[0];n=Fe(n,[t,n.shape[0]/t,n.shape[1]]),e.dispose()}return n}});function Qe(e,t){Object(O.d)(e);const n=Object(Z.c)(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Object(Pe.a)(e,null,n,t)}function Je(e,a,b){const t=1-e%2,n=new Float32Array(e);for(let i=0;i<e;++i){const r=2*Math.PI*i/(e+t-1);n[i]=a-b*Math.cos(r)}return Qe(n,"float32")}Object(Q.a)({hammingWindow_:function(e){return Je(e,.54,.46)}});const et=Object(Q.a)({hannWindow_:function(e){return Je(e,.5,.5)}});function tt(e,t,n){const r={shape:e,value:t,dtype:n};return x.a.runKernel(Y.db,{},r)}function nt(e,t,n){if(Object(O.d)(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Object(Z.c)(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Object(Pe.a)(e,t,r,n)}const ot=Object(Q.a)({frame_:function(e,t,n,r=!1,o=0){let c=0;const output=[];for(;c+t<=e.size;)output.push(Ve(e,c,t)),c+=n;if(r)for(;c<e.size;){const r=c+t-e.size,l=je([Ve(e,c,t-r),tt([r],o)]);output.push(l),c+=n}return 0===output.length?nt([],[0,t]):Fe(je(output),[output.length,t])}});Object(Q.a)({stft_:function(e,t,n,r,o=et){var c;null==r&&(c=t,r=Math.floor(Math.pow(2,Math.ceil(Math.log(c)/Math.log(2)))));const l=ot(e,t,n),d=Ye(l,o(t));return Xe(d,r)}});Object(Q.a)({cropAndResize_:function(image,e,t,n,r="bilinear",o=0){const c=Object(Z.a)(image,"image","cropAndResize"),l=Object(Z.a)(e,"boxes","cropAndResize","float32"),d=Object(Z.a)(t,"boxInd","cropAndResize","int32"),h=l.shape[0];O.b(4===c.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${c.rank}.`)),O.b(2===l.rank&&4===l.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${h},4] but had shape ${l.shape}.`)),O.b(1===d.rank&&d.shape[0]===h,(()=>`Error in cropAndResize: boxInd must be have size [${h}] but had shape ${l.shape}.`)),O.b(2===n.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`)),O.b(n[0]>=1&&n[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${n}`)),O.b("bilinear"===r||"nearest"===r,(()=>`method must be bilinear or nearest, but was ${r}`));const f={image:c,boxes:l,boxInd:d},m={method:r,extrapolationValue:o,cropSize:n};return x.a.runKernel(Y.K,f,m)}});Object(Q.a)({flipLeftRight_:function(image){const e=Object(Z.a)(image,"image","flipLeftRight","float32");O.b(4===e.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`));const t={image:e};return x.a.runKernel(Y.eb,t,{})}});const it=Object(Q.a)({tile_:function(e,t){const n=Object(Z.a)(e,"x","tile","string_or_numeric");O.b(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},o={reps:t};return x.a.runKernel(Y.bd,r,o)}});Object(Q.a)({grayscaleToRGB_:function(image){const e=Object(Z.a)(image,"image","grayscaleToRGB"),t=e.rank-1,n=e.shape[t];O.b(e.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`)),O.b(1===n,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`));const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,it(e,r)}});Object(Q.a)({rotateWithOffset_:function(image,e,t=0,n=.5){const r=Object(Z.a)(image,"image","rotateWithOffset","float32");O.b(4===r.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`));const o={image:r},c={radians:e,fillValue:t,center:n};return x.a.runKernel(Y.uc,o,c)}});function at(e,t,n,r,o,c){null==r&&(r=.5),null==o&&(o=Number.NEGATIVE_INFINITY),null==c&&(c=0);const l=e.shape[0];return n=Math.min(n,l),O.b(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),O.b(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),O.b(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),O.b(1===t.rank,(()=>"scores must be a 1D tensor")),O.b(t.shape[0]===l,(()=>`scores has incompatible shape with boxes. Expected ${l}, but was ${t.shape[0]}`)),O.b(0<=c&&c<=1,(()=>`softNmsSigma must be in [0, 1], but was '${c}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:o,softNmsSigma:c}}Object(Q.a)({nonMaxSuppression_:function(e,t,n,r=.5,o=Number.NEGATIVE_INFINITY){const c=Object(Z.a)(e,"boxes","nonMaxSuppression","float32"),l=Object(Z.a)(t,"scores","nonMaxSuppression","float32"),d=at(c,l,n,r,o),h={maxOutputSize:n=d.maxOutputSize,iouThreshold:r=d.iouThreshold,scoreThreshold:o=d.scoreThreshold};return x.a.runKernel(Y.Vb,{boxes:c,scores:l},h)}});function st(e,element,t){const n=function(e,t,n){return function(e,t,n){let r=0,o=e.length,c=0,l=!1;for(;r<o;){c=r+(o-r>>>1);const d=n(t,e[c]);d>0?r=c+1:(o=c,l=!d)}return l?r:-r-1}(e,t,n||ut)}(e,element,t),r=n<0?-(n+1):n;e.splice(r,0,element)}function ut(a,b){return a>b?1:a<b?-1:0}function ct(e,t,n,r,o){return pt(e,t,n,r,o,0)}function lt(e,t,n,r,o,c){return pt(e,t,n,r,o,0,!1,c,!0)}function ht(e,t,n,r,o,c){return pt(e,t,n,r,o,c,!0)}function pt(e,t,n,r,o,c,l=!1,d=!1,h=!1){const f=[];for(let i=0;i<t.length;i++)t[i]>o&&f.push({score:t[i],boxIndex:i,suppressBeginIndex:0});f.sort(mt);const m=c>0?-.5/c:0,x=[],v=[];for(;x.length<n&&f.length>0;){const t=f.pop(),{score:n,boxIndex:c,suppressBeginIndex:l}=t;if(n<o)break;let d=!1;for(let n=x.length-1;n>=l;--n){const l=ft(e,c,x[n]);if(l>=r){d=!0;break}if(t.score=t.score*gt(r,m,l),t.score<=o)break}t.suppressBeginIndex=x.length,d||(t.score===n?(x.push(c),v.push(t.score)):t.score>o&&st(f,t,mt))}const y=x.length,w=n-y;d&&w>0&&(x.push(...new Array(w).fill(0)),v.push(...new Array(w).fill(0)));const C={selectedIndices:x};return l&&(C.selectedScores=v),h&&(C.validOutputs=y),C}function ft(e,i,t){const n=e.subarray(4*i,4*i+4),r=e.subarray(4*t,4*t+4),o=Math.min(n[0],n[2]),c=Math.min(n[1],n[3]),l=Math.max(n[0],n[2]),d=Math.max(n[1],n[3]),h=Math.min(r[0],r[2]),f=Math.min(r[1],r[3]),m=Math.max(r[0],r[2]),x=Math.max(r[1],r[3]),v=(l-o)*(d-c),y=(m-h)*(x-f);if(v<=0||y<=0)return 0;const w=Math.max(o,h),C=Math.max(c,f),I=Math.min(l,m),$=Math.min(d,x),S=Math.max(I-w,0)*Math.max($-C,0);return S/(v+y-S)}function gt(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function mt(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}Object(Q.a)({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,o=Number.NEGATIVE_INFINITY,c=0){const l=Object(Z.a)(e,"boxes","nonMaxSuppression"),d=Object(Z.a)(t,"scores","nonMaxSuppression"),h=at(l,d,n,r,o,c),f={boxes:l,scores:d},m={maxOutputSize:n=h.maxOutputSize,iouThreshold:r=h.iouThreshold,scoreThreshold:o=h.scoreThreshold,softNmsSigma:c=h.softNmsSigma},v=x.a.runKernel(Y.Xb,f,m);return{selectedIndices:v[0],selectedScores:v[1]}}});Object(Q.a)({nonMaxSuppressionPadded_:function(e,t,n,r=.5,o=Number.NEGATIVE_INFINITY,c=!1){const l=Object(Z.a)(e,"boxes","nonMaxSuppression"),d=Object(Z.a)(t,"scores","nonMaxSuppression"),h=at(l,d,n,r,o,null),f={boxes:l,scores:d},m={maxOutputSize:h.maxOutputSize,iouThreshold:h.iouThreshold,scoreThreshold:h.scoreThreshold,padToMaxOutputSize:c},v=x.a.runKernel(Y.Wb,f,m);return{selectedIndices:v[0],validOutputs:v[1]}}});Object(Q.a)({resizeBilinear_:function(e,t,n=!1,r=!1){const o=Object(Z.a)(e,"images","resizeBilinear");O.b(3===o.rank||4===o.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`)),O.b(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),O.b(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let c=o,l=!1;3===o.rank&&(l=!0,c=Fe(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const[]=t,d={images:c},h={alignCorners:n,halfPixelCenters:r,size:t},f=x.a.runKernel(Y.pc,d,h);return l?Fe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});Object(Q.a)({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const o=Object(Z.a)(e,"images","resizeNearestNeighbor");O.b(3===o.rank||4===o.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`)),O.b(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),O.b("float32"===o.dtype||"int32"===o.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),O.b(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let c=o,l=!1;3===o.rank&&(l=!0,c=Fe(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const[]=t,d={images:c},h={alignCorners:n,halfPixelCenters:r,size:t},f=x.a.runKernel(Y.rc,d,h);return l?Fe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const bt=Object(Q.a)({bincount_:function(e,t,n){const r=Object(Z.a)(e,"x","bincount"),o=Object(Z.a)(t,"weights","bincount");O.b("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),O.b(n>=0,(()=>`size must be non-negative, but got ${n}.`)),O.b(o.size===r.size||0===o.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${o.shape}.`));const c={x:r,weights:o},l={size:n};return x.a.runKernel(Y.u,c,l)}});const xt=Object(Q.a)({lessEqual_:function(a,b){let e=Object(Z.a)(a,"a","lessEqual","string_or_numeric"),t=Object(Z.a)(b,"b","lessEqual","string_or_numeric");[e,t]=Object(Ke.b)(e,t),he(e.shape,t.shape);const n={a:e,b:t};return x.a.runKernel(Y.zb,n)}});const vt=Object(Q.a)({greater_:function(a,b){let e=Object(Z.a)(a,"a","greater","string_or_numeric"),t=Object(Z.a)(b,"b","greater","string_or_numeric");[e,t]=Object(Ke.b)(e,t),he(e.shape,t.shape);const n={a:e,b:t};return x.a.runKernel(Y.nb,n)}});const yt=Object(Q.a)({sum_:function(e,t=null,n=!1){let r=Object(Z.a)(e,"x","sum");"bool"===r.dtype&&(r=J(r,"int32"));const o={x:r},c={axis:t,keepDims:n};return x.a.runKernel(Y.Yc,o,c)}});const wt=Object(Q.a)({add_:function(a,b){let e=Object(Z.a)(a,"a","add"),t=Object(Z.a)(b,"b","add");[e,t]=Object(Ke.b)(e,t);const n={a:e,b:t};return x.a.runKernel(Y.d,n)}});const Ct=Object(Q.a)({floorDiv_:function(a,b){let e=Object(Z.a)(a,"a","floorDiv"),t=Object(Z.a)(b,"b","floorDiv");[e,t]=Object(Ke.b)(e,t);const n={a:e,b:t};return x.a.runKernel(Y.gb,n)}});const div=Object(Q.a)({div_:function(a,b){let e=Object(Z.a)(a,"a","div"),t=Object(Z.a)(b,"b","div");if([e,t]=Object(Ke.b)(e,t),"int32"===e.dtype&&"int32"===t.dtype)return Ct(e,t);const n={a:e,b:t};return x.a.runKernel(Y.kc,n,{})}});const sub=Object(Q.a)({sub_:function(a,b){let e=Object(Z.a)(a,"a","sub"),t=Object(Z.a)(b,"b","sub");[e,t]=Object(Ke.b)(e,t);const n={a:e,b:t};return x.a.runKernel(Y.Xc,n)}});const It=Object(Q.a)({round_:function(e){const t={x:Object(Z.a)(e,"x","round")};return x.a.runKernel(Y.vc,t)}});const $t=Object(Q.a)({where_:function(e,a,b){const t=Object(Z.a)(a,"a","where"),n=Object(Z.a)(b,"b","where"),r=Object(Z.a)(e,"condition","where","bool"),o=he(he(r.shape,t.shape),n.shape),c={condition:De(r,o),t:De(t,o),e:De(n,o)};return x.a.runKernel(Y.zc,c)}});function St(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const o={start:e,stop:t,step:n,dtype:r};return x.a.runKernel(Y.ic,{},o)}var kt=n(462);Object(Q.a)({threshold_:function(image,e="binary",t=!1,n=.5){const r=Object(Z.a)(image,"image","threshold"),o=r.shape[0]*r.shape[1];let c,g,b,l,d=Ye(Qe([n]),255);if(O.b(3===r.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`)),O.b(3===r.shape[2]||1===r.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`)),O.b("int32"===r.dtype||"float32"===r.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`)),O.b("otsu"===e||"binary"===e,(()=>`Method must be binary or otsu, but was ${e}`)),3===r.shape[2]){[c,g,b]=ze(r,[1,1,1],-1);const e=Ye(c,.2989),t=Ye(g,.587),n=Ye(b,.114);l=wt(wt(e,t),n)}else l=image;if("otsu"===e){d=function(e,t){let n,r,o,c,l,d,h=Qe([-1]),f=Qe([0]),m=Qe([0]);for(let x=0;x<e.size-1;x++){n=Ve(e,0,x+1),r=Ve(e,x+1),l=div(yt(n),t),d=div(yt(r),t);const v=yt(Ye(n,St(0,n.size)));o=div(v,yt(n));const y=tt(r.shape,n.size),w=wt(St(0,r.size),y),C=Ye(r,w);c=div(yt(C),yt(r));const I=sub(o,c),$=sub(o,c),S=Ye(l,d);m=Ye(Ye(S,I),$);const k=vt(m,f);f=$t(k,m,f),h=$t(k,Qe([x]),h)}return h}(bt(J(It(l),"int32"),Object(kt.a)([]),256),o)}const h=t?xt(l,d):vt(l,d);return J(Ye(h,255),"int32")}});Object(Q.a)({transform_:function(image,e,t="nearest",n="constant",r=0,o){const c=Object(Z.a)(image,"image","transform","float32"),l=Object(Z.a)(e,"transforms","transform","float32");O.b(4===c.rank,(()=>`Error in transform: image must be rank 4,but got rank ${c.rank}.`)),O.b(2===l.rank&&(l.shape[0]===c.shape[0]||1===l.shape[0])&&8===l.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),O.b(null==o||2===o.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`));const d={image:c,transforms:l},h={interpolation:t,fillMode:n,fillValue:r,outputShape:o};return x.a.runKernel(Y.dd,d,h)}});const Et=Object(Q.a)({greaterEqual_:function(a,b){let e=Object(Z.a)(a,"a","greaterEqual","string_or_numeric"),t=Object(Z.a)(b,"b","greaterEqual","string_or_numeric");[e,t]=Object(Ke.b)(e,t),he(e.shape,t.shape);const n={a:e,b:t};return x.a.runKernel(Y.ob,n)}});const Tt=Object(Q.a)({logicalAnd_:function(a,b){const e=Object(Z.a)(a,"a","logicalAnd","bool"),t=Object(Z.a)(b,"b","logicalAnd","bool");he(e.shape,t.shape);const n={a:e,b:t};return x.a.runKernel(Y.Db,n)}});const Rt=Object(Q.a)({stack_:function(e,t=0){const n=Object(Z.b)(e,"tensors","stack","string_or_numeric");O.b(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&O.b(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,o={axis:t};return x.a.runKernel(Y.bc,r,o)}});const Ot=Object(Q.a)({unstack_:function(e,t=0){const n=Object(Z.a)(e,"x","unstack","string_or_numeric");O.b(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},o={axis:t};return x.a.runKernel(Y.gd,r,o)}});Object(Q.a)({bandPart_:function(a,e,t){Object(O.b)(e%1==0,(()=>`bandPart(): numLower must be an integer, got ${e}.`)),Object(O.b)(t%1==0,(()=>`bandPart(): numUpper must be an integer, got ${t}.`));const n=Object(Z.a)(a,"a","bandPart");Object(O.b)(n.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`));const r=n.shape,[o,c]=n.shape.slice(-2);if(!(e<=o))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`);if(!(t<=c))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${c}).`);e<0&&(e=o),t<0&&(t=c);const i=Fe(St(0,o,1,"int32"),[-1,1]),l=St(0,c,1,"int32"),d=sub(i,l),h=Tt(xt(d,Le(+e,"int32")),Et(d,Le(-t,"int32"))),f=Me([o,c],n.dtype);return Fe(Rt(Ot(Fe(n,[-1,o,c])).map((e=>$t(h,e,f)))),r)}});const At=Object(Q.a)({abs_:function(e){const t=Object(Z.a)(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return x.a.runKernel(Y.A,e)}{const e={x:t};return x.a.runKernel(Y.a,e)}}});function Nt(e,t){for(let i=0;i<e.length;++i)if(e[e.length-i-1]!==t-1-i)return!1;return!0}function _t(e,t,n){const r=e.length+t.length,o=[];let c=0,l=0;for(let d=0;d<r;d++)-1===n.indexOf(d)?o.push(e[c++]):o.push(t[l++]);return o}function Ft(e,t){const n=[],r=e.length;for(let o=0;o<r;o++)-1===t.indexOf(o)&&n.push(e[o]);return[n,t.map((t=>e[t]))]}function Dt(e,t){return _t(e,t.map((e=>1)),t)}function Pt(e,t,n){O.b(Nt(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function Lt(e,t){if(Nt(e,t))return null;const n=[];for(let i=0;i<t;++i)-1===e.indexOf(i)&&n.push(i);return e.forEach((e=>n.push(e))),n}function Bt(e){return e.map(((e,i)=>[i,e])).sort(((a,b)=>a[1]-b[1])).map((e=>e[0]))}function Mt(e,t){const n=[];for(let i=t-e;i<t;++i)n.push(i);return n}const jt=Object(Q.a)({max_:function(e,t=null,n=!1){const r={x:Object(Z.a)(e,"x","max")},o={reductionIndices:t,keepDims:n};return x.a.runKernel(Y.Gb,r,o)}});const Ut=Object(Q.a)({min_:function(e,t=null,n=!1){const r={x:Object(Z.a)(e,"x","min")},o={axis:t,keepDims:n};return x.a.runKernel(Y.Ob,r,o)}});const Wt=Object(Q.a)({pow_:function(base,e){let t=Object(Z.a)(base,"base","pow"),n=Object(Z.a)(e,"exp","pow");[t,n]=Object(Ke.b)(t,n);const r={a:t,b:n};return x.a.runKernel(Y.dc,r)}});const Vt=Object(Q.a)({sqrt_:function(e){const t={x:Object(Z.a)(e,"x","sqrt","float32")};return x.a.runKernel(Y.Pc,t)}});const zt=Object(Q.a)({square_:function(e){const t=Object(Z.a)(e,"x","square");return x.a.runKernel("Square",{x:t},{})}});function Gt(e,p,t=null){if(0===e.rank)return At(e);if(1!==e.rank&&null===t)return Gt(Fe(e,[-1]),p,t);if(1===e.rank||"number"==typeof t||Array.isArray(t)&&1===t.length){if(1===p)return yt(At(e),t);if(p===1/0)return jt(At(e),t);if(p===-1/0)return Ut(At(e),t);if("euclidean"===p||2===p)return Vt(yt(Wt(At(e),Le(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${p}`)}if(Array.isArray(t)&&2===t.length){if(1===p)return jt(yt(At(e),t[0]),t[1]-1);if(p===1/0)return jt(yt(At(e),t[1]),t[0]);if(p===-1/0)return Ut(yt(At(e),t[1]),t[0]);if("fro"===p||"euclidean"===p)return Vt(yt(zt(e),t));throw new Error(`Error in norm: invalid ord value: ${p}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Ht=Object(Q.a)({norm_:function(e,t="euclidean",n=null,r=!1){const o=Gt(e=Object(Z.a)(e,"x","norm"),t,n);let c=o.shape;if(r){const t=Object(O.I)(n,e.shape);c=Dt(o.shape,t)}return Fe(o,c)}});const Xt=Object(Q.a)({squeeze_:function(e,t){const n=Object(Z.a)(e,"x","squeeze","string_or_numeric");return Fe(n,Object(O.Q)(n.shape,t).newShape)}});Object(Q.a)({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Object(O.b)(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let i=1;i<e.length;++i)Object(O.b)(e[i].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[i].shape[0]} vs. ${n})`))}else t=!0,e=ze(e,e.shape[0],0).map((e=>Xt(e,[0])));Object(O.b)(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let i=0;i<e.length;++i)n.push(x.a.tidy((()=>{let e=r[i];if(i>0)for(let t=0;t<i;++t){const r=Ye(yt(Ye(n[t],e)),n[t]);e=sub(e,r)}return div(e,Ht(e,"euclidean"))})));return t?Rt(n,0):n}});function qt(){return x.a}function Kt(e,t){return x.a.tidy(e,t)}Object(X.d)((function(e){Object(v.b)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}));const Yt=Object(Q.a)({expandDims_:function(e,t=0){const n=Object(Z.a)(e,"x","expandDims","string_or_numeric");O.b(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},o={dim:t};return x.a.runKernel(Y.ab,r,o)}});const Zt=Object(Q.a)({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const o=K([e,t],r),c=e<=t?e:t;for(let i=0;i<c;++i)o.set(1,i,i);const l=Fe(o.toTensor(),[e,t]);if(null==n)return l;if(1===n.length)return it(Yt(l,0),[n[0],1,1]);if(2===n.length)return it(Yt(Yt(l,0),0),[n[0],n[1],1,1]);if(3===n.length)return it(Yt(Yt(Yt(l,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});const Qt=Object(Q.a)({matMul_:function(a,b,e=!1,t=!1){let n=Object(Z.a)(a,"a","matMul"),r=Object(Z.a)(b,"b","matMul");[n,r]=Object(Ke.b)(n,r);const o={a:n,b:r},c={transposeA:e,transposeB:t};return x.a.runKernel(Y.s,o,c)}});const Jt=Object(Q.a)({neg_:function(e){const t={x:Object(Z.a)(e,"x","neg")};return x.a.runKernel(Y.Ub,t)}});const en=Object(Q.a)({transpose_:function(e,t,n){const r=Object(Z.a)(e,"x","transpose");if(null==t&&(t=r.shape.map(((s,i)=>i)).reverse()),O.b(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{O.b(e>=0&&e<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${t}`))})),r.rank<=1)return r.clone();const o={x:r},c={perm:t};return"complex64"===r.dtype?Kt((()=>{let e=We(r),t=Ue(r);return e=x.a.runKernel(Y.ed,{x:e},c),t=x.a.runKernel(Y.ed,{x:t},c),n&&(t=Jt(t)),Object(Be.a)(e,t)})):x.a.runKernel(Y.ed,o,c)}});function tn(e,t=!1){return x.a.tidy((()=>{Object(O.b)(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let q=Zt(n),o=ee(e);const c=nt([[1]],[1,1]);let l=ee(c);const d=n>=r?r:n;for(let e=0;e<d;++e){const t=o,d=l,f=q;[l,o,q]=x.a.tidy((()=>{const t=Ve(o,[e,e],[n-e,1]),d=Ht(t),h=Ve(o,[e,e],[1,1]),s=$t(vt(h,0),nt([[-1]]),nt([[1]])),f=sub(h,Ye(s,d)),m=div(t,f);l=1===m.shape[0]?ee(c):je([c,Ve(m,[1,0],[m.shape[0]-1,m.shape[1]])],0);const x=Jt(div(Qt(s,f),d)),v=Ve(o,[e,0],[n-e,r]),y=Ye(x,l),w=en(l);if(0===e)o=sub(v,Qt(y,Qt(w,v)));else{const t=sub(v,Qt(y,Qt(w,v)));o=je([Ve(o,[0,0],[e,r]),t],0)}const C=en(y),I=Ve(q,[0,e],[n,q.shape[1]-e]);if(0===e)q=sub(I,Qt(Qt(I,l),C));else{const t=sub(I,Qt(Qt(I,l),C));q=je([Ve(q,[0,0],[n,e]),t],1)}return[l,o,q]})),h=[t,d,f],Object(Ke.a)(h).forEach((e=>e.dispose()))}var h;return!t&&n>r&&(q=Ve(q,[0,0],[n,r]),o=Ve(o,[0,0],[r,r])),[q,o]}))}Object(Q.a)({qr_:function(e,t=!1){if(Object(O.b)(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return tn(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=Ot(Fe(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),o=[],c=[];r.forEach((e=>{const[n,r]=tn(e,t);o.push(n),c.push(r)}));return[Fe(Rt(o,0),e.shape),Fe(Rt(c,0),e.shape)]}}});var nn;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(nn||(nn={}));const rn=Object(Q.a)({mean_:function(e,t=null,n=!1){const r={x:Object(Z.a)(e,"x","mean")},o={axis:t,keepDims:n};return x.a.runKernel(Y.Nb,r,o)}});const on=Object(Q.a)({notEqual_:function(a,b){let e=Object(Z.a)(a,"a","notEqual","string_or_numeric"),t=Object(Z.a)(b,"b","notEqual","string_or_numeric");[e,t]=Object(Ke.b)(e,t),he(e.shape,t.shape);const n={a:e,b:t};return x.a.runKernel(Y.Yb,n)}});function an(e,t="float32"){if("complex64"===t){const t=an(e,"float32"),n=Me(e,"float32");return Object(Be.a)(t,n)}const n=Object(O.D)(Object(O.O)(e),t);return x.a.makeTensor(n,e,t)}const sn=Object(Q.a)({computeWeightedLoss_:function(e,t,n=nn.SUM_BY_NONZERO_WEIGHTS){const r=Object(Z.a)(e,"losses","computeWeightedLoss");let o=null;null!=t&&(o=Object(Z.a)(t,"weights","computeWeightedLoss"));const c=null==o?r:Ye(r,o);if(n===nn.NONE)return c;if(n===nn.SUM)return yt(c);if(n===nn.MEAN){if(null==o)return rn(c);{const e=r.size/o.size,t=div(yt(c),yt(o));return e>1?div(t,Le(e)):t}}if(n===nn.SUM_BY_NONZERO_WEIGHTS){if(null==o)return div(yt(c),Le(r.size));{const e=Ye(o,an(r.shape)),t=J(yt(on(e,Le(0))),"float32");return div(yt(c),t)}}throw Error(`Unknown reduction: ${n}`)}});Object(Q.a)({absoluteDifference_:function(e,t,n,r=nn.SUM_BY_NONZERO_WEIGHTS){const o=Object(Z.a)(e,"labels","absoluteDifference"),c=Object(Z.a)(t,"predictions","absoluteDifference");let l=null;null!=n&&(l=Object(Z.a)(n,"weights","absoluteDifference")),Object(O.e)(o.shape,c.shape,"Error in absoluteDifference: ");const d=At(sub(o,c));return sn(d,l,r)}});Object(Q.a)({cosineDistance_:function(e,t,n,r,o=nn.SUM_BY_NONZERO_WEIGHTS){const c=Object(Z.a)(e,"labels","cosineDistance"),l=Object(Z.a)(t,"predictions","cosineDistance");let d=null;null!=r&&(d=Object(Z.a)(r,"weights","cosineDistance")),Object(O.e)(c.shape,l.shape,"Error in cosineDistance: ");const h=Le(1),f=sub(h,yt(Ye(c,l),n,!0));return sn(f,d,o)}});const un=Object(Q.a)({relu_:function(e){const t={x:Object(Z.a)(e,"x","relu")};return x.a.runKernel(Y.mc,t)}});Object(Q.a)({hingeLoss_:function(e,t,n,r=nn.SUM_BY_NONZERO_WEIGHTS){let o=Object(Z.a)(e,"labels","hingeLoss");const c=Object(Z.a)(t,"predictions","hingeLoss");let l=null;null!=n&&(l=Object(Z.a)(n,"weights","hingeLoss")),Object(O.e)(o.shape,c.shape,"Error in hingeLoss: ");const d=Le(1);o=sub(Ye(Le(2),o),d);const h=un(sub(d,Ye(o,c)));return sn(h,l,r)}});const cn=Object(Q.a)({minimum_:function(a,b){let e=Object(Z.a)(a,"a","minimum"),t=Object(Z.a)(b,"b","minimum");[e,t]=Object(Ke.b)(e,t),"bool"===e.dtype&&(e=J(e,"int32"),t=J(t,"int32")),he(e.shape,t.shape);const n={a:e,b:t};return x.a.runKernel(Y.Pb,n)}});Object(Q.a)({huberLoss_:function(e,t,n,r=1,o=nn.SUM_BY_NONZERO_WEIGHTS){const c=Object(Z.a)(e,"labels","huberLoss"),l=Object(Z.a)(t,"predictions","huberLoss");let d=null;null!=n&&(d=Object(Z.a)(n,"weights","huberLoss")),Object(O.e)(c.shape,l.shape,"Error in huberLoss: ");const h=Le(r),f=At(sub(l,c)),m=cn(f,h),x=sub(f,m),v=wt(Ye(Le(.5),zt(m)),Ye(h,x));return sn(v,d,o)}});const ln=Object(Q.a)({log_:function(e){const t={x:Object(Z.a)(e,"x","log","float32")};return x.a.runKernel(Y.Bb,t)}});Object(Q.a)({logLoss_:function(e,t,n,r=1e-7,o=nn.SUM_BY_NONZERO_WEIGHTS){const c=Object(Z.a)(e,"labels","logLoss"),l=Object(Z.a)(t,"predictions","logLoss");let d=null;null!=n&&(d=Object(Z.a)(n,"weights","logLoss")),Object(O.e)(c.shape,l.shape,"Error in logLoss: ");const h=Le(1),f=Le(r),m=Jt(Ye(c,ln(wt(l,f)))),x=Ye(sub(h,c),ln(wt(sub(h,l),f))),v=sub(m,x);return sn(v,d,o)}});const dn=Object(Q.a)({squaredDifference_:function(a,b){let e=Object(Z.a)(a,"a","squaredDifference"),t=Object(Z.a)(b,"b","squaredDifference");[e,t]=Object(Ke.b)(e,t),he(e.shape,t.shape);const n={a:e,b:t};return x.a.runKernel(Y.Rc,n,{})}});Object(Q.a)({meanSquaredError_:function(e,t,n,r=nn.SUM_BY_NONZERO_WEIGHTS){const o=Object(Z.a)(e,"labels","meanSquaredError"),c=Object(Z.a)(t,"predictions","meanSquaredError");let l=null;null!=n&&(l=Object(Z.a)(n,"weights","meanSquaredError")),Object(O.e)(o.shape,c.shape,"Error in meanSquaredError: ");const d=dn(o,c);return sn(d,l,r)}});const hn=Object(Q.a)({exp_:function(e){const t={x:Object(Z.a)(e,"x","exp")};return x.a.runKernel(Y.Z,t)}});const pn=Object(Q.a)({log1p_:function(e){const t={x:Object(Z.a)(e,"x","log1p")};return x.a.runKernel(Y.Cb,t)}});Object(Q.a)({sigmoidCrossEntropy_:function(e,t,n,r=0,o=nn.SUM_BY_NONZERO_WEIGHTS){let c=Object(Z.a)(e,"multiClassLabels","sigmoidCrossEntropy");const l=Object(Z.a)(t,"logits","sigmoidCrossEntropy");let d=null;if(null!=n&&(d=Object(Z.a)(n,"weights","sigmoidCrossEntropy")),Object(O.e)(c.shape,l.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=Le(r),t=Le(1),n=Le(.5);c=wt(Ye(c,sub(t,e)),Ye(n,e))}const h=function(e,t){const n=Object(Z.a)(e,"labels","sigmoidCrossEntropyWithLogits"),r=Object(Z.a)(t,"logits","sigmoidCrossEntropyWithLogits");Object(O.e)(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const o=un(r),c=Ye(r,n),l=pn(hn(Jt(At(r))));return wt(sub(o,c),l)}(c,l);return sn(h,d,o)}});const fn=Object(Q.a)({logSumExp_:function(e,t=null,n=!1){const r=Object(Z.a)(e,"x","logSumExp"),o=Object(O.I)(t,r.shape),c=jt(r,o,!0),a=sub(r,c),b=hn(a),l=yt(b,o),d=ln(l),h=wt(Fe(c,d.shape),d);if(n){const e=Dt(h.shape,o);return Fe(h,e)}return h}});function gn(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=(o=(e,t,r)=>{const o=fn(t,[n],!0),c=sub(J(t,"float32"),o);r([e,c]);const l=Jt(Ye(c,e));return{value:yt(l,[n]),gradFunc:(e,t)=>{const[r,o]=t,c=Dt(e.shape,[n]);return[Ye(Fe(e,c),sub(J(r,"float32"),hn(o))),Ye(Fe(e,c),sub(hn(o),J(r,"float32")))]}}},x.a.customGrad(o));var o;return r(e,t)}Object(Q.a)({softmaxCrossEntropy_:function(e,t,n,r=0,o=nn.SUM_BY_NONZERO_WEIGHTS){let c=Object(Z.a)(e,"onehotLabels","softmaxCrossEntropy");const l=Object(Z.a)(t,"logits","softmaxCrossEntropy");let d=null;if(null!=n&&(d=Object(Z.a)(n,"weights","softmaxCrossEntropy")),Object(O.e)(c.shape,l.shape,"Error in softmaxCrossEntropy: "),r>0){const e=Le(r),t=Le(1),n=Le(c.shape[1]);c=wt(Ye(c,sub(t,e)),div(e,n))}const h=gn(c,l);return sn(h,d,o)}});Object(Q.a)({sparseFillEmptyRows_:function(e,t,n,r){const o=Object(Z.a)(e,"indices","sparseFillEmptyRows","int32"),c=Object(Z.a)(t,"values","sparseFillEmptyRows"),l=Object(Z.a)(n,"denseShape","sparseFillEmptyRows","int32"),d=Object(Z.a)(r,"defaultValue","sparseFillEmptyRows",c.dtype);if(2!==o.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${o.shape}`);if(1!==c.rank)throw new Error(`Values should be Tensor1D but received shape ${c.shape}`);if(1!==l.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${l.shape}`);if(0!==d.rank)throw new Error(`Default value should be a scalar but received shape ${d.shape}`);const h={indices:o,values:c,denseShape:l,defaultValue:d},f=x.a.runKernel(Y.Jc,h);return{outputIndices:f[0],outputValues:f[1],emptyRowIndicator:f[2],reverseIndexMap:f[3]}}});Object(Q.a)({sparseReshape_:function(e,t,n){const r=Object(Z.a)(e,"inputIndices","sparseReshape","int32"),o=Object(Z.a)(t,"inputShape","sparseReshape","int32"),c=Object(Z.a)(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==o.rank)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(1!==c.rank)throw new Error(`New shape should be Tensor1D but received shape ${c.shape}`);const l={inputIndices:r,inputShape:o,newShape:c},d=x.a.runKernel(Y.Kc,l);return{outputIndices:d[0],outputShape:d[1]}}});Object(Q.a)({sparseSegmentMean_:function(data,e,t){const n=Object(Z.a)(data,"data","sparseSegmentMean"),r=Object(Z.a)(e,"indices","sparseSegmentMean","int32"),o=Object(Z.a)(t,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${r.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${o.shape}`);const c={data:n,indices:r,segmentIds:o};return x.a.runKernel(Y.Lc,c)}});Object(Q.a)({sparseSegmentSum_:function(data,e,t){const n=Object(Z.a)(data,"data","sparseSegmentSum"),r=Object(Z.a)(e,"indices","sparseSegmentSum","int32"),o=Object(Z.a)(t,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${r.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${o.shape}`);const c={data:n,indices:r,segmentIds:o};return x.a.runKernel(Y.Mc,c)}});Object(Q.a)({stringNGrams_:function(data,e,t,n,r,o,c,l){const d=Object(Z.a)(data,"data","stringNGrams","string");if("string"!==d.dtype)throw new Error("Data must be of datatype string");if(1!==d.shape.length)throw new Error(`Data must be a vector, saw: ${d.shape}`);const h=Object(Z.a)(e,"dataSplits","stringNGrams");if("int32"!==h.dtype)throw new Error("Data splits must be of datatype int32");const f={separator:t,nGramWidths:n,leftPad:r,rightPad:o,padWidth:c,preserveShortSequences:l},m={data:d,dataSplits:h},v=x.a.runKernel(Y.Uc,m,f);return{nGrams:v[0],nGramsSplits:v[1]}}});Object(Q.a)({stringSplit_:function(input,e,t=!0){const n=Object(Z.a)(input,"input","stringSplit","string"),r=Object(Z.a)(e,"delimiter","stringSplit","string");if(1!==n.rank)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(0!==r.rank)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const o={skipEmpty:t},c={input:n,delimiter:r},l=x.a.runKernel(Y.Vc,c,o);return{indices:l[0],values:l[1],shape:l[2]}}});Object(Q.a)({stringToHashBucketFast_:function(input,e){const t=Object(Z.a)(input,"input","stringToHashBucketFast","string"),n={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return x.a.runKernel(Y.Wc,r,n)}});var mn=n(492),bn=n(509);function xn(e,t){const n=e[0].length;e.forEach(((e,i)=>{O.b(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${i}] must be the same as the rank of the rest (${n})`))})),O.b(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,i)=>{for(let o=0;o<n;o++)O.b(o===t||e[o]===r[o],(()=>`Error in concat${n}D: Shape of tensors[${i}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`))}))}function vn(e,t){const n=e[0].slice();for(let i=1;i<e.length;i++)n[t]+=e[i][t];return n}function yn(e,t,n,r,o="NHWC",c){return In(e,[...t,e[3]],n,c,r,null,null,Nn(o))}function wn(e,t,n,r,o,c,l="channelsLast"){const[d,h]=kn(t);let f;if("channelsLast"===l)f=[d,h,e[3],e[3]];else{if("channelsFirst"!==l)throw new Error(`Unknown dataFormat ${l}`);f=[d,h,e[1],e[1]]}return In(e,f,n,r,o,c,!1,l)}function Cn(e,t,n,r,o,c,l="NDHWC"){const[d,h,f]=En(t);let m,x;if("NDHWC"===l)x="channelsLast",m=[d,h,f,e[4],e[4]];else{if("NCDHW"!==l)throw new Error(`Unknown dataFormat ${l}`);x="channelsFirst",m=[d,h,f,e[1],e[1]]}return $n(e,m,n,r,o,!1,x,c)}function In(e,t,n,r,o,c,l=!1,d="channelsLast"){let[h,f,m,x]=[-1,-1,-1,-1];if("channelsLast"===d)[h,f,m,x]=e;else{if("channelsFirst"!==d)throw new Error(`Unknown dataFormat ${d}`);[h,x,f,m]=e}const[v,y,,w]=t,[C,I]=kn(n),[$,S]=kn(r),k=Tn(v,$),E=Tn(y,S),{padInfo:T,outHeight:R,outWidth:O}=function(e,t,n,r,o,c,l,d,h){let f,m,x;if("number"==typeof e){f={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const o=function(e,t,n,r,o){null==r&&(r=Sn(e,t,n));const c=e[0],l=e[1],d=Rn((c-t+2*r)/n+1,o),h=Rn((l-t+2*r)/n+1,o);return[d,h]}([t,n],c,r,e,d);m=o[0],x=o[1]}else if("same"===e){m=Math.ceil(t/r),x=Math.ceil(n/o);const e=Math.max(0,(m-1)*r+c-t),d=Math.max(0,(x-1)*o+l-n),h=Math.floor(e/2),v=e-h,y=Math.floor(d/2);f={top:h,bottom:v,left:y,right:d-y,type:"SAME"}}else if("valid"===e)f={top:0,bottom:0,left:0,right:0,type:"VALID"},m=Math.ceil((t-c+1)/r),x=Math.ceil((n-l+1)/o);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const v="channelsLast"===h?e[1][0]:e[2][0],y="channelsLast"===h?e[1][1]:e[2][1],w="channelsLast"===h?e[2][0]:e[3][0],C="channelsLast"===h?e[2][1]:e[3][1];f={top:v,bottom:y,left:w,right:C,type:0===v&&0===y&&0===w&&0===C?"VALID":"EXPLICIT"},m=Rn((t-c+v+y)/r+1,d),x=Rn((n-l+w+C)/o+1,d)}}return{padInfo:f,outHeight:m,outWidth:x}}(o,f,m,C,I,k,E,c,d),A=l?w*x:w;let N;return"channelsFirst"===d?N=[h,A,R,O]:"channelsLast"===d&&(N=[h,R,O,A]),{batchSize:h,dataFormat:d,inHeight:f,inWidth:m,inChannels:x,outHeight:R,outWidth:O,outChannels:A,padInfo:T,strideHeight:C,strideWidth:I,filterHeight:v,filterWidth:y,effectiveFilterHeight:k,effectiveFilterWidth:E,dilationHeight:$,dilationWidth:S,inShape:e,outShape:N,filterShape:t}}function $n(e,t,n,r,o,c=!1,l="channelsLast",d){let[h,f,m,x,v]=[-1,-1,-1,-1,-1];if("channelsLast"===l)[h,f,m,x,v]=e;else{if("channelsFirst"!==l)throw new Error(`Unknown dataFormat ${l}`);[h,v,f,m,x]=e}const[y,w,C,,I]=t,[$,S,k]=En(n),[E,T,R]=En(r),O=Tn(y,E),A=Tn(w,T),N=Tn(C,R),{padInfo:_,outDepth:F,outHeight:D,outWidth:P}=function(e,t,n,r,o,c,l,d,h,f,m){let x,v,y,w;if("number"==typeof e){x={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const c=function(e,t,n,r,o,c){null==o&&(o=Sn(e,t,r));const l=e[0],d=e[1],h=e[2],f=Rn((l-t+2*o)/r+1,c),m=Rn((d-t+2*o)/r+1,c),x=Rn((h-t+2*o)/r+1,c);return[f,m,x,n]}([t,n,r,1],d,1,o,e,m);v=c[0],y=c[1],w=c[2]}else if("same"===e){v=Math.ceil(t/o),y=Math.ceil(n/c),w=Math.ceil(r/l);const e=(v-1)*o+d-t,m=(y-1)*c+h-n,C=(w-1)*l+f-r,I=Math.floor(e/2),$=e-I,S=Math.floor(m/2),k=m-S,E=Math.floor(C/2);x={top:S,bottom:k,left:E,right:C-E,front:I,back:$,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);x={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},v=Math.ceil((t-d+1)/o),y=Math.ceil((n-h+1)/c),w=Math.ceil((r-f+1)/l)}return{padInfo:x,outDepth:v,outHeight:y,outWidth:w}}(o,f,m,x,$,S,k,O,A,N,d),L=c?I*v:I;let B;return"channelsFirst"===l?B=[h,L,F,D,P]:"channelsLast"===l&&(B=[h,F,D,P,L]),{batchSize:h,dataFormat:l,inDepth:f,inHeight:m,inWidth:x,inChannels:v,outDepth:F,outHeight:D,outWidth:P,outChannels:L,padInfo:_,strideDepth:$,strideHeight:S,strideWidth:k,filterDepth:y,filterHeight:w,filterWidth:C,effectiveFilterDepth:O,effectiveFilterHeight:A,effectiveFilterWidth:N,dilationDepth:E,dilationHeight:T,dilationWidth:R,inShape:e,outShape:B,filterShape:t}}function Sn(e,t,n,r=1){const o=Tn(t,r);return Math.floor((e[0]*(n-1)-n+o)/2)}function kn(param){return"number"==typeof param?[param,param,param]:2===param.length?[param[0],param[1],1]:param}function En(param){return"number"==typeof param?[param,param,param]:param}function Tn(e,t){return t<=1?e:e+(e-1)*(t-1)}function Rn(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function On(param){const[e,t,n]=kn(param);return 1===e&&1===t&&1===n}function An(e,t){return On(e)||On(t)}function Nn(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function _n(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)O.b(O.v(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((p=>{p.forEach((t=>{O.b(O.v(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}const Fn=Object(Q.a)({elu_:function(e){const t={x:Object(Z.a)(e,"x","elu","float32")};return x.a.runKernel(Y.V,t)}});const Dn=Object(Q.a)({leakyRelu_:function(e,t=.2){const n={x:Object(Z.a)(e,"x","leakyRelu")},r={alpha:t};return x.a.runKernel(Y.xb,n,r)}});const Pn=Object(Q.a)({prelu_:function(e,t){const n={x:Object(Z.a)(e,"x","prelu"),alpha:Object(Z.a)(t,"alpha","prelu")};return x.a.runKernel(Y.ec,n)}});const Ln=Object(Q.a)({relu6_:function(e){const t={x:Object(Z.a)(e,"x","relu6")};return x.a.runKernel(Y.nc,t)}});const Bn=Object(Q.a)({sigmoid_:function(e){const t={x:Object(Z.a)(e,"x","sigmoid","float32")};return x.a.runKernel(Y.Bc,t)}});const Mn=Object(Q.a)({step_:function(e,t=0){const n={x:Object(Z.a)(e,"x","step")},r={alpha:t};return x.a.runKernel(Y.Sc,n,r)}});function jn(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Ye(e,Mn(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Un(e,t){let n=t;const r=de(e.shape,t.shape);return r.length>0&&(n=yt(n,r)),Fe(n,e.shape)}function Wn(e,t,n,r){if("linear"===t)return e;if("relu"===t)return un(e);if("elu"===t)return Fn(e);if("relu6"===t)return Ln(e);if("prelu"===t)return Pn(e,n);if("leakyrelu"===t)return Dn(e,r);if("sigmoid"===t)return Bn(e);throw new Error(`Unknown fused activation ${t}.`)}const Vn=(e,t)=>!(e>0)||"linear"===t;var zn;function Gn(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let i=1;i<n.length;++i){const o=n[i],c=r[r.length-n.length+i],l=r[c];if(o>=0)if(l>=0){if(l!==o)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${i+e}] = ${o} but shape[${i+e}] = ${l}`)}else r[c]=o}return r}function Hn(e){const t={FIRST_DIM_SIZE:zn.FIRST_DIM_SIZE,VALUE_ROWIDS:zn.VALUE_ROWIDS,ROW_LENGTHS:zn.ROW_LENGTHS,ROW_SPLITS:zn.ROW_SPLITS,ROW_LIMITS:zn.ROW_LIMITS,ROW_STARTS:zn.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function Xn(e){return 0===e.length?0:e[0]===zn.FIRST_DIM_SIZE?e.length-1:e.length}function qn(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let i=0;i<Math.min(n,r-1);++i){const n=e[i],r=t[i+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${i-e.length}] = ${n} but ragged tensor input.flatValues.shape[${i-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(zn||(zn={}));const Kn=30;function Yn(e){return e<=Kn?e:Object(O.G)(e,Math.floor(Math.sqrt(e)))}function Zn(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function Qn(e,t,n,r=!0){let o=[];if(r)o=o.concat(t.slice(0)),o.push(e[0]/n),o=o.concat(e.slice(1));else{o=o.concat(e[0]);const n=t.length;for(let i=0;i<n;++i)o=o.concat([e[i+1]/t[i],t[i]]);o=o.concat(e.slice(n+1))}return o}function Jn(e,t,n=!0){const r=[];if(n){r.push(t);for(let i=t+1;i<e;++i)i<=2*t?(r.push(i),r.push(i-(t+1))):r.push(i)}else{const n=[],o=[];for(let i=1;i<e;++i)i>=2*t+1||i%2==1?o.push(i):n.push(i);r.push(...n),r.push(0),r.push(...o)}return r}function er(e,t,n,r=!0){const o=[];r?o.push(e[0]/n):o.push(e[0]*n);for(let i=1;i<e.length;++i)i<=t.length?r?o.push(t[i-1]*e[i]):o.push(e[i]/t[i-1]):o.push(e[i]);return o}function nr(e,t){const n=[0];for(let i=0;i<t;++i)n.push(e[i][0]);return n}function rr(e,t,n){const r=e.slice(0,1);for(let i=0;i<n;++i)r.push(e[i+1]-t[i][0]-t[i][1]);return r}function or(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Object(O.O)(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const o=t.shape,c=o[o.length-1];let l=1;for(let i=0;i<o.length-1;++i)l*=o[i];const d=e.shape,h=o.slice();h.pop();let f=1;for(let i=c;i<n;++i)f*=d[i],h.push(d[i]);const m=[...Object(O.j)(e.shape).map((e=>e/f)),1].slice(0,c);return[h,l,f,m]}function ir(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,o=t.rank>1?t.rank-1:1,c=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${o}.`;if(n.rank<o)throw new Error(c+` update.rank < ${o}. `);if(e.length<r+(n.rank-o))throw new Error(c+` Output shape length < ${r+(n.rank-o)}`);if(n.rank!==o+e.length-r)throw new Error(c+" update.rank != "+(o+e.length-r));for(let e=0;e<o;++e)if(n.shape[e]!==t.shape[e])throw new Error(c+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-o;++t)if(n.shape[t+o]!==e[t+r])throw new Error(c+` updates.shape[${t+o}] (${n.shape[t+o]}) != shape[${t+o}] (${e[t+o]})`)}function ar(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}ir(n,t,e)}function sr(e,t,n){const r=t.shape.length,o=r>1?t.shape[r-1]:1,c=n.length;let l=1;for(let i=o;i<c;++i)l*=n[i];const d=o<1?1:o;return{sliceRank:o,numUpdates:Object(O.O)(t.shape)/d,sliceSize:l,strides:[...Object(O.j)(n.slice(0,o)),1],outputSize:Object(O.O)(n)}}const ur=1.7580993408473768,cr=1.0507009873554805,lr=.3275911,dr=.254829592,pr=-.284496736,fr=1.421413741,gr=-1.453152027,mr=1.061405429;var xr=n(460);function vr(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let i=0;i<n.length;i+=2)n[i]=e[i/2],n[i+1]=t[i/2];return n}function yr(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let i=0;i<e.length;i+=2)t[i/2]=e[i],n[i/2]=e[i+1];return{real:t,imag:n}}function wr(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let i=0;i<e.length;i+=4)n[Math.floor(i/4)]=e[i],r[Math.floor(i/4)]=e[i+1];return{real:n,imag:r}}function Cr(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let i=2;i<e.length;i+=4)n[Math.floor(i/4)]=e[i],r[Math.floor(i/4)]=e[i+1];return{real:n,imag:r}}function Ir(e,t){return{real:e[2*t],imag:e[2*t+1]}}function $r(data,e,t,n){data[2*n]=e,data[2*n+1]=t}function Sr(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let i=0;i<Math.ceil(e/2);i++){const o=(t?2:-2)*Math.PI*(i/e);n[i]=Math.cos(o),r[i]=Math.sin(o)}return{real:n,imag:r}}function kr(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const Er="->",Tr=/->/g,Rr=",",Or="...";function Ar(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(Tr,"").length)/Er.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Er}").`);const[r,o]=e.split(Er);Object(O.b)(-1===r.indexOf(Or),(()=>`The ellipsis notation ("${Or}") is not supported yet.`));const c=r.split(Rr),l=c.length;if(t!==l)throw new Error(`Expected ${l} input tensors, received ${t}`);if(l>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const d=[];for(let i=0;i<o.length;++i){const e=o[i];if(!c.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===d.indexOf(e)&&d.push(e)}for(let i=0;i<r.length;++i){const e=r[i];-1===d.indexOf(e)&&e!==Rr&&d.push(e)}const h=new Array(c.length);for(let i=0;i<l;++i){if(new Set(c[i].split("")).size!==c[i].length)throw new Error(`Found duplicate axes in input component ${c[i]}. Support for duplicate axes in input is not implemented yet.`);h[i]=[];for(let e=0;e<c[i].length;++e)h[i].push(d.indexOf(c[i][e]))}const f=d.length,m=[];for(let i=o.length;i<f;++i)m.push(i);return{allDims:d,summedDims:m,idDims:h}}function Nr(e,t){let n=new Array(e);n.fill(-1);for(let i=0;i<t.length;++i)n[t[i]]=i;const r=[];for(let i=0;i<e;++i)-1===n[i]&&r.push(i);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function _r(e,t,n){const r=new Array(e);for(let i=0;i<n.length;++i){const e=n[i].shape;for(let n=0;n<t[i].length;++n)void 0===r[t[i][n]]?r[t[i][n]]=e[n]:Object(O.b)(r[t[i][n]]===e[n],(()=>`Expected dimension ${r[t[i][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function Fr(e,t){const path=e,n=[];let r=0;0===e.length&&path.push(-1),r=e.length+1;for(let i=0;i<r;++i)n.push([]);const o=[];for(let i=0;i<path.length;++i){const e=Pr(t,path[i]);for(const t of e)-1===o.indexOf(t)&&(n[i].push(t),o.push(t))}return{path:path,steps:n}}function Dr(e){return e.every(((e,t)=>e===t))}function Pr(e,t){const n=[];for(let i=0;i<e.length;++i)0!==e[i].length&&-1===e[i].indexOf(t)&&-1!==t||n.push(i);return n}function Lr(e,t,n=0){let r=[];if("number"==typeof t)Object(O.b)(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const o=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Object(O.b)(o<=1,(()=>"There should be only one negative value in split array."));const c=t.indexOf(-1);if(-1!==c){const r=t.reduce(((a,b)=>b>0?a+b:a));t[c]=e.shape[n]-r}Object(O.b)(e.shape[n]===t.reduce(((a,b)=>a+b)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function Br(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function Mr(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function jr(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Ur(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Wr(e,t){return`size ${e} must be non-negative, not ${t}`}function Vr(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function zr(e,t){return`Input to reshape is a SparseTensor with ${Object(O.O)(e)}\n  dense values, but the requested shape requires a multiple of ${Object(O.O)(t)}. inputShape=${e} outputShape= ${t}`}function Gr(e,t){return`Input to reshape is a tensor with ${Object(O.O)(e)} dense values, but the requested shape has ${Object(O.O)(t)}. inputShape=${e} outputShape=${t}`}function Hr(){return"segment ids must be >= 0"}function Xr(){return"segment ids are not increasing"}function qr(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Kr(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function Yr(e,t){let n,r=!1;for(e<=Kn?(n=e,r=!0):n=Object(O.G)(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Object(O.G)(e,n+1);return n}function Zr(e,t,n){const r=[],o=e.length;for(let c=0;c<o;c++)c!==t?r.push(e[c]):r.push(n);return r}function Qr(e,t,n,r){const o=t.shape.length,c=e.shape.length;if(0!==r&&(r<-o||r>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${r}`);if(r<0&&(r+=o),r>c)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${c}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let i=0;i<r;++i)if(e.shape[i]!==t.shape[i])throw new Error(`x.shape[${i}]: ${e.shape[i]} should be equal to indices.shape[${i}]: ${t.shape[i]}.`);const l=e.shape[n],d=[];let h=1,f=1,m=1;for(let i=0;i<r;++i)d.push(e.shape[i]),h*=e.shape[i];for(let i=r;i<n;i++)d.push(e.shape[i]),f*=e.shape[i];for(let i=r;i<o;i++)d.push(t.shape[i]);for(let i=n+1;i<c;i++)d.push(e.shape[i]),m*=e.shape[i];return{batchSize:h,sliceSize:m,outerSize:f,dimSize:l,outputShape:d}}function Jr(e){try{return e.map((e=>Object(Ne.decodeString)(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function eo(e){return e.map((s=>Object(Ne.encodeString)(s)))}var to=n(493);function no(e,t){const n=[];for(let i=0;i<t.length;i++)t[i]&&n.push(i);const r=K(e,"int32"),o=K([n.length,e.length],"int32");for(let i=0;i<n.length;i++){const t=r.indexToLoc(n[i]),c=i*e.length;o.values.set(t,c)}return o.toTensor()}var ro=n(461);const oo={},io={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function ao(e,t){if(!(e in oo)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const canvas=null==t?function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e):t;canvas.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete oo[e]}),!1),Object(v.b)().getBool("SOFTWARE_WEBGL_ENABLED")&&(io.failIfMajorPerformanceCaveat=!1);if(1===e)return canvas.getContext("webgl",io)||canvas.getContext("experimental-webgl",io);return canvas.getContext("webgl2",io)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;oo[e]=n}const n=oo[e];return null==n||n.isContextLost()?(delete oo[e],ao(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),oo[e])}var so,uo,co;function lo(e,t){return[t,e]}function ho(e){const t=Ne.sizeFromShape(e),n=Math.ceil(t/4);return Ne.sizeToSquarishShape(n)}function po(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function fo(e,t){const n=e;let r,o,c,l,d,h,f,m,x,y;return 2===Object(v.b)().getNumber("WEBGL_VERSION")?(r=n.R32F,o=n.R16F,c=n.RGBA16F,l=n.RGBA32F,d=n.RED,f=4,m=1,x=n.HALF_FLOAT,y=n.FLOAT,h=n.RGBA8):(r=e.RGBA,o=e.RGBA,c=e.RGBA,l=n.RGBA,d=e.RGBA,f=4,m=4,x=null!=t?t.HALF_FLOAT_OES:null,y=e.FLOAT,h=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:c,internalFormatPackedFloat:l,textureFormatFloat:d,downloadTextureFormat:h,downloadUnpackNumChannels:f,defaultNumChannels:m,textureTypeHalfFloat:x,textureTypeFloat:y}}function go(e,t){const n=t();return Object(v.b)().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(so||(so={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(uo||(uo={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(co||(co={}));function mo(e){return!!(Object(v.b)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function bo(e,t){return ko(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const xo=/ERROR: [0-9]+:([0-9]+):/g;function vo(e,t){const n=xo.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],o=e.split("\n"),c=o.length.toString().length+2,l=o.map(((line,e)=>Ne.rightPad((e+1).toString(),c)+line));let d=0;for(let i=0;i<l.length;i++)d=Math.max(l[i].length,d);const h=l.slice(0,r-1),f=l.slice(r-1,r),m=l.slice(r);console.log(h.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Ne.rightPad(f[0],d)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(m.join("\n"))}function yo(e,t){if(go(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function wo(e,t,n,r,o,c,l){const d=e.getAttribLocation(t,n);return-1!==d&&(go(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),go(e,(()=>e.vertexAttribPointer(d,o,e.FLOAT,!1,c,l))),go(e,(()=>e.enableVertexAttribArray(d))),!0)}function Co(e,t,n,r){go(e,(()=>function(e,t,n){Eo(e,n),go(e,(()=>e.activeTexture(e.TEXTURE0+n))),go(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),go(e,(()=>e.uniform1i(n,r)))}function Io(e,t,n){go(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),go(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function $o(e,t){go(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),go(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function So(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function ko(e,t,n){const r=go(e,(()=>t()));if(null==r)throw new Error(n);return r}function Eo(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function To(e,t=2){return Ne.sizeFromShape(e.slice(0,e.length-t))}function Ro(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Oo(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[To(e),...Ro(e)]),t}function Ao(e){return e%2==0}function No(e,t){if(e=e.slice(-2),t=t.slice(-2),Ne.arraysEqual(e,t))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(Ao(n)&&Ao(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&Ao(e[0])&&Ao(t[0])}let _o,Fo;function Do(e,t){return null!=e.getExtension(t)}function Po(e){try{if(null!=ao(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Lo(e){if(0===e)return!1;const t=ao(e);if(1!==e){if(Do(t,"EXT_color_buffer_float"))return Bo(t);const e="EXT_color_buffer_half_float";if(Do(t,e)){const n=t.getExtension(e);return function(e,t){const n=fo(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const o=1,c=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,o,c,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const l=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,l),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const d=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(l),d}(t,n)}return!1}if(!Do(t,"OES_texture_float"))return!1;if(!Do(t,"WEBGL_color_buffer_float"))return!1;return Bo(t)}function Bo(e){const t=fo(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),o}function Mo(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Ne.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const jo=Object(v.b)();function Uo(){let e,t,n,r,o,output,c,l,d,h;return 2===Object(v.b)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",o="texture",output="outputColor",c="out vec4 outputColor;",l=Object(v.b)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",d="",h="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",o="texture2D",output="gl_FragColor",c="",l="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",d="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",h="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:o,output:output,defineOutput:c,defineSpecialNaN:l,defineSpecialInf:d,defineRound:h}}function Wo(e,t,n="index"){const r=Ne.computeStrides(t);return r.map(((t,i)=>`${`int ${e[i]} = ${n} / ${t}`}; ${i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${t}`:`index -= ${e[i]} * ${t}`};`)).join("")}function Vo(e,t,n="index"){const r=Ne.computeStrides(t);return r.map(((t,i)=>`${`int ${e[i]} = ${n} / outShapeStrides[${i}]`}; ${i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * outShapeStrides[${i}]`:`index -= ${e[i]} * outShapeStrides[${i}]`};`)).join("")}function zo(e,t,n="index"){const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),o=new Array(n-1);o[n-2]=r[n-1];for(let i=n-3;i>=0;--i)o[i]=`(${o[i+1]} * ${r[i+1]})`;return o}(e.map(((e,i)=>i)),t);return r.map(((t,i)=>`${`int ${e[i]} = ${n} / ${r[i]}`}; ${i===r.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${r[i]}`:`index -= ${e[i]} * ${r[i]}`};`)).join("")}function Go(e){const t=Ne.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}jo.registerFlag("HAS_WEBGL",(()=>jo.getNumber("WEBGL_VERSION")>0)),jo.registerFlag("WEBGL_VERSION",(()=>Po(2)?2:Po(1)?1:0)),jo.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),jo.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===jo.get("WEBGL_VERSION"))),jo.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),jo.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),jo.registerFlag("WEBGL_PACK",(()=>jo.getBool("HAS_WEBGL"))),jo.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>jo.getBool("WEBGL_PACK"))),jo.registerFlag("WEBGL_PACK_CLIP",(()=>jo.getBool("WEBGL_PACK"))),jo.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>jo.getBool("WEBGL_PACK"))),jo.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>jo.getBool("WEBGL_PACK"))),jo.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>jo.getBool("WEBGL_PACK"))),jo.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>jo.getBool("WEBGL_PACK"))),jo.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>jo.getBool("WEBGL_PACK"))),jo.registerFlag("WEBGL_PACK_REDUCE",(()=>jo.getBool("WEBGL_PACK"))),jo.registerFlag("WEBGL_LAZILY_UNPACK",(()=>jo.getBool("WEBGL_PACK"))),jo.registerFlag("WEBGL_CONV_IM2COL",(()=>jo.getBool("WEBGL_PACK"))),jo.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==_o){const t=ao(e);_o=t.getParameter(t.MAX_TEXTURE_SIZE)}return _o}(jo.getNumber("WEBGL_VERSION")))),jo.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==Fo){const t=ao(e);Fo=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Fo)}(jo.getNumber("WEBGL_VERSION")))),jo.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=jo.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=ao(e);return t=Do(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:Do(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),jo.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>jo.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!to.isMobile())),jo.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=ao(e);if(1===e){if(!Do(t,"OES_texture_float"))return!1}else if(!Do(t,"EXT_color_buffer_float"))return!1;return Bo(t)}(jo.getNumber("WEBGL_VERSION")))),jo.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!jo.getBool("WEBGL_FORCE_F16_TEXTURES")&&jo.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),jo.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>Lo(jo.getNumber("WEBGL_VERSION")))),jo.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=jo.getNumber("WEBGL_VERSION"))&&null!=ao(e).fenceSync;var e})),jo.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>jo.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),jo.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),jo.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>to.isMobile()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),jo.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),jo.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),jo.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),jo.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),jo.registerFlag("WEBGL_EXP_CONV",(()=>!1)),jo.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>jo.getBool("IS_TEST"))),jo.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),jo.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),jo.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1));const Ho="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:Xo}=l;function qo(e,t,n){const r=[];if(e.forEach((e=>{const t=Ne.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=ii(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const o=r.join("\n"),c=e.map((e=>function(e,t,n=!1,r){let o="";o+=n?Yo(e,r):Ko(e,r);const c=e.shapeInfo.logicalShape,l=t.logicalShape;c.length<=l.length&&(o+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),o="get"+r+"AtOutCoords",c=e.shapeInfo.logicalShape.length,l=t.logicalShape.length,d=Xo(e.shapeInfo.logicalShape,t.logicalShape),h=oi(l),f=l-c;let m;const x=["x","y","z","w","u","v"];m=0===c?"":l<2&&d.length>=1?"coords = 0;":d.map((e=>`coords.${x[e+f]} = 0;`)).join("\n");let v="";v=l<2&&c>0?"coords":e.shapeInfo.logicalShape.map(((s,i)=>`coords.${x[i+f]}`)).join(", ");let output="return outputValue;";const y=1===Ne.sizeFromShape(e.shapeInfo.logicalShape),w=Ne.sizeFromShape(t.logicalShape),C=1===w;if(1!==c||y||C){if(y&&!C)output=1===l?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(d.length){const e=c-2,t=c-1;d.indexOf(e)>-1&&d.indexOf(t)>-1?output="return vec4(outputValue.x);":d.indexOf(e)>-1?output="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":d.indexOf(t)>-1&&(output="return vec4(outputValue.xx, outputValue.zz);")}}else output="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${o}() {\n      ${h} coords = getOutputCoords();\n      ${m}\n      vec4 outputValue = get${r}(${v});\n      ${output}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),o="get"+r+"AtOutCoords",c=t.texShape,l=e.shapeInfo.texShape,d=e.shapeInfo.logicalShape.length,h=t.logicalShape.length;if(!e.shapeInfo.isUniform&&d===h&&null==e.shapeInfo.flatOffset&&Ne.arraysEqual(l,c))return`\n      float ${o}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const f=oi(h),m=Xo(e.shapeInfo.logicalShape,t.logicalShape),x=h-d;let v;const y=["x","y","z","w","u","v"];v=0===d?"":h<2&&m.length>=1?"coords = 0;":m.map((e=>`coords.${y[e+x]} = 0;`)).join("\n");let w="";w=h<2&&d>0?"coords":e.shapeInfo.logicalShape.map(((s,i)=>`coords.${y[i+x]}`)).join(", ");return`\n    float ${o}() {\n      ${f} coords = getOutputCoords();\n      ${v}\n      return get${r}(${w});\n    }\n  `}(e,t));return o}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),l=t.texShape,d=Uo(),h=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(d);let f,m,x=function(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Zo}\n    ${Qo}\n    ${Jo}\n  `;return t}(d);t.isPacked?(f=function(e,t,n){switch(e.length){case 0:return ti();case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `;if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Ne.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const o=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(e[2]/2),c=o*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${c};\n      index -= b * ${c};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(e[e.length-1]/2),c=o*Math.ceil(e[e.length-2]/2);let l=c,d="",h="b, r, c";for(let b=2;b<e.length-1;b++)l*=e[e.length-b-1],d=`\n      int b${b} = index / ${l};\n      index -= b${b} * ${l};\n    `+d,h=`b${b}, `+h;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${d}\n\n      int b = index / ${c};\n      index -= b * ${c};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec${e.length}(${h});\n    }\n  `}(e,t,n)}}(t.logicalShape,l,n.enableShapeUniforms),m=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(d)):(f=function(e,t,n){switch(e.length){case 0:return ti();case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){if(Ne.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Vo(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const r=Wo(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Vo(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=Wo(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=Wo(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=Wo(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,l,n.enableShapeUniforms),m=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(d)),n.packedInputs&&(x+=ei);return[x,h,m,o,f,c,n.userCode].join("\n")}function Ko(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[o,c]=e.shapeInfo.texShape;if(1===o&&1===c)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const l=ni(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${l});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[d,h]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${d}, ${h}, ${l});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${ri(e)}\n      }\n    `;const o=e.shapeInfo.texShape,c=o[0],l=o[1];if(1===l&&1===c)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const d=ni(n);if(1===l)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${d}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${d}) + 0.5) / ${c}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===c)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${d}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${d}) + 0.5) / ${l}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(t)return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${d});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${c}, ${l}, index + ${d});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),c=e.shapeInfo.texShape;if(null!=c&&Ne.arraysEqual(n,c)){if(t)return`\n      float ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=c[0];return`\n    float ${o}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${c[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:l,keptDims:d}=Ne.squeezeShape(n),h=l;if(h.length<n.length){const n=["row","col"];return`\n      ${Ko(ai(e,h),t)}\n      float ${o}(int row, int col) {\n        return ${o}(${si(n,d)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${ri(e)}\n      }\n    `;const f=c[0],m=c[1],x=ni(r);if(1===m)return t?`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${x}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${x}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===f)return t?`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${x}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${x}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${m}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(t)return`\n      float ${o}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${x};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `;return`\n  float ${o}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${x};\n    vec2 uv = uvFromFlat(${f}, ${m}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),c=n[1]*n[2],l=n[2],{newShape:d,keptDims:h}=Ne.squeezeShape(n),f=d;if(f.length<n.length){const n=["row","col","depth"];return`\n        ${Ko(ai(e,f),t)}\n        float ${o}(int row, int col, int depth) {\n          return ${o}(${si(n,h)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${c}, ${l}, 1)));\n        ${ri(e)}\n      }\n    `;const m=e.shapeInfo.texShape,x=m[0],v=m[1],y=e.shapeInfo.flatOffset;if(v===c&&null==y)return t?`\n      float ${o}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${o}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${l}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${v}.0, ${x}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(v===l&&null==y)return t?`\n      float ${o}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${o}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${v}.0, ${x}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const w=ni(r);if(t)return`\n    float ${o}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${w};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `;return`\n      float ${o}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${c} + col * ${l} + depth + ${w};\n        vec2 uv = uvFromFlat(${x}, ${v}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),c=n[3],l=n[2]*c,d=n[1]*l,{newShape:h,keptDims:f}=Ne.squeezeShape(n);if(h.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${Ko(ai(e,h),t)}\n      float ${o}(int row, int col, int depth, int depth2) {\n        return ${o}(${si(n,f)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${d}, ${l}, ${c}, 1)));\n        ${ri(e)}\n      }\n    `;const m=e.shapeInfo.flatOffset,x=e.shapeInfo.texShape,v=x[0],y=x[1],w=`int stride2 = ${r}Shape[3];`,C=`int stride1 = ${r}Shape[2] * stride2;`,I=`int stride0 = ${r}Shape[1] * stride1;`;if(y===d&&null==m)return t?`\n      float ${o}(int row, int col, int depth, int depth2) {\n        ${w}\n        ${C}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${l}, ${c}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${y}.0, ${v}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(y===c&&null==m)return t?`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${y}.0, ${v}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const $=ni(r);if(t)return`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${w}\n      ${C}\n      ${I}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${$});\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${l} +\n          depth * ${c} + depth2;\n      vec2 uv = uvFromFlat(${v}, ${y}, index + ${$});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=t[4],c=t[3]*o,l=t[2]*c,d=t[1]*l,{newShape:h,keptDims:f}=Ne.squeezeShape(t);if(h.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${Ko(ai(e,h))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${si(t,f)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${l}, ${c}, ${o})) +\n          depth3;\n        ${ri(e)}\n      }\n    `;const m=e.shapeInfo.flatOffset,x=e.shapeInfo.texShape,v=x[0],y=x[1];if(y===d&&null==m)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${l}, ${c}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${y}.0, ${v}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(y===o&&null==m)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${y}.0, ${v}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const w=ni(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${l} + depth * ${c} +\n          depth2 * ${o} + depth3 + ${w};\n      vec2 uv = uvFromFlat(${v}, ${y}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:o,keptDims:c}=Ne.squeezeShape(t);if(o.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Ko(ai(e,o))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${si(t,c)});\n      }\n    `}const l=t[5],d=t[4]*l,h=t[3]*d,f=t[2]*h,m=t[1]*f;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${m}, ${f}, ${h}, ${d})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${l}, 1)));\n        ${ri(e)}\n      }\n    `;const x=e.shapeInfo.flatOffset,v=e.shapeInfo.texShape,y=v[0],w=v[1];if(w===m&&null==x)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${f}, ${h}, ${d}, ${l})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${w}.0, ${y}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(w===l&&null==x)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${w}.0, ${y}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const C=ni(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${m} + col * ${f} + depth * ${h} +\n          depth2 * ${d} + depth3 * ${l} + depth4 + ${C};\n      vec2 uv = uvFromFlat(${y}, ${w}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function Yo(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Uo();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=e.shapeInfo.texShape,c=Uo();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${c.texture2D}(${n}, uv);\n    }\n  `;const l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${l[0]}, ${l[1]}, index);\n      return ${c.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),c=e.shapeInfo.texShape,l=c[0],d=c[1],h=Uo();if(null!=c&&Ne.arraysEqual(n,c))return t?`\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${h.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${l}.0);\n\n        return ${h.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${o}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${h.texture2D}(${r}, uv);\n    }\n  `;const f=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)],m=Math.ceil(n[1]/2);return`\n    vec4 ${o}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${m}, ${f[0]}, ${f[1]}, row, col);\n      return ${h.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),c=e.shapeInfo.texShape,l=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];if(1===n[0]){const r=[1,2],c=["b","row","col"];return`\n        ${Yo(ai(e,n.slice(1)),t)}\n        vec4 ${o}(int b, int row, int col) {\n          return ${o}(${si(c,r)});\n        }\n      `}const d=Uo();if(t)return`\n    vec4 ${o}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${d.texture2D}(${r}, uv);\n    }\n  `;const h=l[0],f=l[1],m=Math.ceil(n[2]/2),x=m*Math.ceil(n[1]/2);return`\n    vec4 ${o}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${h}, ${f}, ${x}, ${m}, b, row, col);\n      return ${d.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),o=Uo();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${n}, uv);\n    }\n  `;const c=e.shapeInfo.logicalShape,l=c.length,d=e.shapeInfo.texShape,h=[Math.ceil(d[0]/2),Math.ceil(d[1]/2)],f=h[0],m=h[1],x=Math.ceil(c[l-1]/2);let v=x*Math.ceil(c[l-2]/2),y="int b, int row, int col",w=`b * ${v} + (row / 2) * ${x} + (col / 2)`;for(let b=2;b<l-1;b++)y=`int b${b}, `+y,v*=c[l-b-1],w=`b${b} * ${v} + `+w;return`\n    vec4 ${r}(${y}) {\n      int index = ${w};\n      int texR = index / ${m};\n      int texC = index - texR * ${m};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}, ${f});\n      return ${o.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const Zo="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Qo="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Jo="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",ei="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function ti(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function ni(e){return`offset${e}`}function ri(e){const t=e.name,n=Ne.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function oi(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function ii(e,t,n){const{newShape:r,keptDims:o}=Ne.squeezeShape(t),c=t.length,l=e&&3===c&&1===t[0],d=l?t.slice(1):r,h=!e&&c>1&&!Ne.arraysEqual(t,n)&&r.length<c||l;return{useSqueezeShape:h,uniformShape:h?d:t,keptDims:o}}function ai(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function si(e,t){return t.map((t=>e[t])).join(", ")}function ui(e,t,n,output){const r=n.map(((input,i)=>{const e={logicalShape:input.shape,texShape:input.isUniform?null:input.texData.texShape,isUniform:input.isUniform,isPacked:!input.isUniform&&input.texData.isPacked,flatOffset:null};return null!=input.texData&&null!=input.texData.slice&&input.texData.slice.flatOffset>0&&(e.flatOffset=input.texData.slice.flatOffset),{name:t.variableNames[i],shapeInfo:e}})),o=r.map((e=>e.shapeInfo)),c={logicalShape:output.shape,texShape:output.texData.texShape,isUniform:!1,isPacked:output.texData.isPacked,flatOffset:null},source=qo(r,c,t),l=function(e,t){const n=ko(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(go(e,(()=>e.shaderSource(n,t))),go(e,(()=>e.compileShader(n))),Object(v.b)().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw vo(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,source),d=e.createProgram(l);return Object(v.b)().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:source,webGLProgram:d,inShapeInfos:o,outShapeInfo:c,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:source,webGLProgram:d,inShapeInfos:o,outShapeInfo:c},ci(e,t,d))}function ci(e,t,n){const r={},o={},c={},l=[];let d,h,f,m=null,x=null;x=e.getUniformLocation(n,"NAN",!1),1===Object(v.b)().getNumber("WEBGL_VERSION")&&(m=e.getUniformLocation(n,"INFINITY",!1));const y=!1;for(let i=0;i<t.variableNames.length;i++){const l=t.variableNames[i];r[l]=e.getUniformLocation(n,l,y),r[`offset${l}`]=e.getUniformLocation(n,`offset${l}`,y),t.enableShapeUniforms&&(o[`${l}Shape`]=e.getUniformLocation(n,`${l}Shape`,y),c[`${l}TexShape`]=e.getUniformLocation(n,`${l}TexShape`,y))}return t.enableShapeUniforms&&(d=e.getUniformLocation(n,"outShape",y),f=e.getUniformLocation(n,"outShapeStrides",y),h=e.getUniformLocation(n,"outTexShape",y)),t.customUniforms&&t.customUniforms.forEach(((t,i)=>{l[i]=e.getUniformLocation(n,t.name,y)})),{uniformLocations:r,customUniformLocations:l,infLoc:m,nanLoc:x,inShapesLocations:o,inTexShapesLocations:c,outShapeLocation:d,outShapeStridesLocation:f,outTexShapeLocation:h}}function di(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((s,i)=>{const e=s.logicalShape,input=t[i],n=input.shape;if(!Ne.arraysEqual(e,n))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${e} and ${n} must match`);if(s.isUniform&&input.isUniform)return;const r=s.texShape,o=input.isUniform?null:input.texData.texShape;if(!Ne.arraysEqual(r,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${r} and ${o} must match`)}))}function hi(e){return Object(v.b)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class pi{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=so.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Uo();this.outputShape=e,this.enableShapeUniforms=hi(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Vo(["r","c","d"],e):Wo(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class fi{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=so.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Uo();this.outputShape=e,this.enableShapeUniforms=hi(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Vo(["r","c","d"],e):Wo(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class gi{constructor(e){this.variableNames=["A"],this.outTexUsage=uo.DOWNLOAD;const t=Uo();this.outputShape=e,this.userCode=`\n      ${Ho}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class mi{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=uo.DOWNLOAD;const t=Uo();this.outputShape=e,this.userCode=`\n      ${Ho}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class bi{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Uo();this.outputShape=e,this.enableShapeUniforms=hi(this.outputShape.length);let output="result";t&&(output="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Go(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${output}, 0., 0., 0.);\n      }\n    `}}class xi{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=Uo();this.outputShape=e,this.enableShapeUniforms=hi(this.outputShape.length);let r="",output="result";t&&(output="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let col=0;col<=1;col++){const o=2*t+col;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${col} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${col};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${o}] = values[0];\n            } else if (offset == 1) {\n              result[${o}] = values[1];\n            } else if (offset == 2) {\n              result[${o}] = values[2];\n            } else {\n              result[${o}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Go(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${output};\n        }\n    `}}function vi(e){const t=Uo();return function(e,t){const n=ko(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(go(e,(()=>e.shaderSource(n,t))),go(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function yi(e){return function(e,data){const t=ko(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return go(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,t))),go(e,(()=>e.bufferData(e.ARRAY_BUFFER,data,e.STATIC_DRAW))),t}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function wi(e){return function(e,data){const t=ko(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return go(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t))),go(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,data,e.STATIC_DRAW))),t}(e,new Uint16Array([0,1,2,2,1,3]))}function Ci(e,t,n,r,o,c){!function(e,t){const n=Object(v.b)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const l=function(e){return ko(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),d=e.TEXTURE_2D;return go(e,(()=>e.bindTexture(d,l))),go(e,(()=>e.texParameteri(d,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),go(e,(()=>e.texParameteri(d,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),go(e,(()=>e.texParameteri(d,e.TEXTURE_MIN_FILTER,e.NEAREST))),go(e,(()=>e.texParameteri(d,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===Object(v.b)().getNumber("WEBGL_VERSION")?go(e,(()=>e.texImage2D(d,0,r,t,n,0,o,c,null))):go(e,(()=>e.texStorage2D(d,1,r,t,n))),go(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:l,texShape:[n,t]}}function Ii(e){return e.internalFormatFloat}function $i(e){return e.internalFormatHalfFloat}function Si(e){return e.downloadTextureFormat}function ki(e){return e.internalFormatPackedFloat}function Ei(e){return e.internalFormatPackedHalfFloat}function Ti(e,t,n,r,o,c,l,d){const h=e,f=new Float32Array(function(e,t){const[n,r]=po(e,t);return n*r*4}(c,l));return h.bindBuffer(h.PIXEL_PACK_BUFFER,t),h.getBufferSubData(h.PIXEL_PACK_BUFFER,0,f),h.bindBuffer(h.PIXEL_PACK_BUFFER,null),f}class Ri{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=Object(v.b)().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){oo[e]=t}(t,e)):this.gl=ao(t);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Object(v.b)().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=bo(this.gl,e),Do(this.gl,t))this.textureHalfFloatExtension=bo(this.gl,t);else if(Object(v.b)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Do(this.gl,r))this.colorBufferHalfFloatExtension=bo(this.gl,r);else if(Object(v.b)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Do(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!Do(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=yi(this.gl),this.indexBuffer=wi(this.gl),this.framebuffer=function(e){return ko(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=fo(this.gl,this.textureHalfFloatExtension)}get debug(){return Object(v.b)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;go(e,(()=>e.finish())),go(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),go(e,(()=>e.deleteFramebuffer(this.framebuffer))),go(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),go(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),go(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[o,c]=lo(t,n);return Ci(e,o,c,Ii(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[o,c]=lo(t,n);return Ci(e,o,c,$i(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[o,c]=lo(t,n);return Ci(e,o,c,Si(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){go(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===Object(v.b)().getNumber("WEBGL_VERSION")?go(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):go(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===Object(v.b)().getNumber("WEBGL_VERSION")?go(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):go(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),go(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,data){this.throwIfDisposed(),function(e,t,n,r,data,o){let c,l,d;go(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),data instanceof Uint8Array?(c=new Uint8Array(n*r*4),l=e.UNSIGNED_BYTE,d=e.RGBA):(c=new Float32Array(n*r*4),l=e.FLOAT,d=o.internalFormatPackedFloat),c.set(data),2===Object(v.b)().getNumber("WEBGL_VERSION")?go(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,l,c))):go(e,(()=>e.texImage2D(e.TEXTURE_2D,0,d,n,r,0,e.RGBA,l,c))),go(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,data,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[o,c]=po(t,n);return Ci(e,o,c,Ei(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[o,c]=po(t,n);return Ci(e,o,c,ki(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&($o(this.gl,this.framebuffer),this.outputTexture=null),go(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[o,c]=lo(t,n),l=new Uint8Array(t*n*4);return go(e,(()=>e.readPixels(0,0,o,c,r.downloadTextureFormat,e.UNSIGNED_BYTE,l))),new Float32Array(l.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,o,c){return Ti(this.gl,e,0,0,0,o,c,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,o=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n,r){const o=e.createBuffer();go(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,o)));const c=16*t*n;return go(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,c,e.STREAM_READ))),go(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),go(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),o}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Object(v.b)().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(o,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=o}else Object(v.b)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Object(v.b)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return go(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=vi(t));const n=function(e){return ko(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);return go(t,(()=>t.attachShader(n,this.vertexShader))),go(t,(()=>t.attachShader(n,e))),function(e,t){if(go(e,(()=>e.linkProgram(t))),!Object(v.b)().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n),this.debug&&yo(t,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=function(e,t,n){return go(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),wo(e,t,"clipSpacePos",n,3,20,0)&&wo(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),n}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&go(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&yo(this.gl,this.program),go(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return ko(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),go(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),Co(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,o]=po(t,n);this.setOutputMatrixTextureDriver(e,r,o)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&yo(this.gl,this.program),So(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),go(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),go(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=bo(this.gl,2===Object(v.b)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Object(v.b)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Object(v.b)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Ne.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,Object(v.b)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,Object(v.b)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let i=0;for(;i<e.length;++i){if(!e[i]())break}return i-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let i=0;i<=e;++i){const{resolveFn:e}=this.itemsToPoll[i];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Object(v.b)().platform&&(n=Object(v.b)().platform.setTimeoutCustom.bind(Object(v.b)().platform)),Ne.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Io(this.gl,e,this.framebuffer),this.debug&&So(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Io(this.gl,this.outputTexture,this.framebuffer),this.debug&&So(this.gl)):$o(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;Io(r,e,this.framebuffer),this.debug&&So(r),this.outputTexture=e,go(r,(()=>r.viewport(0,0,t,n))),go(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),go(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function Oi(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Ne.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}function Ai(e){const t=new Float32Array(e.length);for(let i=0;i<e.length;++i)t[i]=Math.abs(e[i]);return t}Y.a;function Ni(e){return(t,n,r,o,c)=>{const d=l.assertAndGetBroadcastShape(t,n),h=d.length,f=Ne.computeStrides(d),m=Ne.sizeFromShape(d),x=Ne.getTypedArrayFromDType(c,m),v=t.length,y=n.length,w=Ne.computeStrides(t),C=Ne.computeStrides(n),I=l.getBroadcastDims(t,d),$=l.getBroadcastDims(n,d);if(I.length+$.length===0)for(let i=0;i<x.length;++i)x[i]=e(r[i%r.length],o[i%o.length]);else for(let i=0;i<x.length;++i){const t=Ne.indexToLoc(i,h,f),n=t.slice(-v);I.forEach((e=>n[e]=0));const c=Ne.locToIndex(n,v,w),l=t.slice(-y);$.forEach((e=>l[e]=0));const d=Ne.locToIndex(l,y,C);x[i]=e(r[c],o[d])}return[x,d]}}function _i(e){const{inputs:t,backend:n}=e,{real:r,imag:o}=t,c=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,d=n.makeTensorInfo(r.shape,"complex64");return n.data.get(d.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",c),imag:n.makeTensorInfo(o.shape,"float32",l)},d}Y.z;function Fi(e,t,n="float32"){if("complex64"===n){return _i({inputs:{real:Fi(e,t,"float32"),imag:Fi(e,t,"float32")},backend:e})}const r=Ne.makeZerosTypedArray(Ne.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function Di(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}Y.qb;function Pi(e){const{inputs:t,backend:n}=e,{input:input}=t,r=n.data.get(input.dataId).complexTensorInfos.real,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}Y.jc;function Li(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){const r=Ne.toTypedArray([0],n),[o,c]=Ni(((a,b)=>a!==b?1:0))(t,[],e,r,"bool");return[c,"bool",o]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Bi(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{dtype:c}=r;if("complex64"===c){if("complex64"===o.dtype)return Di({inputs:{x:o},backend:n});const e=Fi(n,o.shape,o.dtype),t=Bi({inputs:{x:o},backend:n,attrs:{dtype:"float32"}}),r=_i({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===o.dtype){const e=Pi({inputs:{input:o},backend:n}),t=Bi({inputs:{x:e},backend:n,attrs:{dtype:c}});return n.disposeIntermediateTensorInfo(e),t}if(!Ne.hasEncodingLoss(o.dtype,c)){const e=Di({inputs:{x:o},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:c}}const l=n.data.get(o.dataId).values,[d,h,f]=Li(l,o.shape,o.dtype,c);return n.makeTensorInfo(d,h,f)}Y.w;function Mi(e,t,n,r){return null==n?({inputs:n,backend:o})=>{const{a:a,b:b}=n,c=o;Oi([a,b],e);const d=c.data.get(a.dataId).values,h=c.data.get(b.dataId).values,f="string"===a.dtype?l.fromUint8ToStringArray(d):d,m="string"===a.dtype?l.fromUint8ToStringArray(h):h,x=r||a.dtype,[v,y]=t(a.shape,b.shape,f,m,x);return c.makeTensorInfo(y,x,v)}:({inputs:e,backend:o})=>{const{a:a,b:b}=e,c=o;if("complex64"===a.dtype||"complex64"===b.dtype){const e=Bi({inputs:{x:a},backend:c,attrs:{dtype:"complex64"}}),t=c.data.get(e.dataId),r=t.complexTensorInfos.real,o=t.complexTensorInfos.imag,l=c.data.get(r.dataId).values,d=c.data.get(o.dataId).values,h=Bi({inputs:{x:b},backend:c,attrs:{dtype:"complex64"}}),f=c.data.get(h.dataId),m=f.complexTensorInfos.real,x=f.complexTensorInfos.imag,v=c.data.get(m.dataId).values,y=c.data.get(x.dataId).values,[w,C,I]=n(a.shape,b.shape,l,d,v,y),$=c.makeTensorInfo(I,"float32",w),S=c.makeTensorInfo(I,"float32",C),k=_i({inputs:{real:$,imag:S},backend:c});return c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(h),c.disposeIntermediateTensorInfo($),c.disposeIntermediateTensorInfo(S),k}{const e=c.data.get(a.dataId).values,n=c.data.get(b.dataId).values,o=r||a.dtype,[l,d]=t(a.shape,b.shape,e,n,o);return c.makeTensorInfo(d,o,l)}}}function ji(e){return(t,n,r,o,c,d)=>{const h=l.assertAndGetBroadcastShape(t,n),f=Ne.sizeFromShape(h),m=h.length,x=Ne.computeStrides(h),v=Ne.getTypedArrayFromDType("float32",f),y=Ne.getTypedArrayFromDType("float32",f),w=l.getBroadcastDims(t,h),C=l.getBroadcastDims(n,h),I=l.mergeRealAndImagArrays(r,o),$=l.mergeRealAndImagArrays(c,d),S=t.length,k=Ne.computeStrides(t),E=n.length,T=Ne.computeStrides(n);if(w.length+C.length===0)for(let i=0;i<v.length;i++){const t=i%I.length,n=i%$.length,r=e(I[2*t],I[2*t+1],$[2*n],$[2*n+1]);v[i]=r.real,y[i]=r.imag}else for(let i=0;i<v.length;i++){const t=Ne.indexToLoc(i,m,x),n=t.slice(-S);w.forEach((e=>n[e]=0));const r=Ne.locToIndex(n,S,k),o=t.slice(-E);C.forEach((e=>o[e]=0));const c=Ne.locToIndex(o,E,T),l=e(I[2*r],I[2*r+1],$[2*c],$[2*c+1]);v[i]=l.real,y[i]=l.imag}return[v,y,h]}}const Ui=Ni(((a,b)=>a+b)),Wi=ji(((e,t,n,r)=>({real:e+n,imag:t+r})));Mi(Y.d,Ui,Wi),Y.d;function Vi(e,t,n,r,o){const c=Ne.sizeFromShape(r),l=Ne.makeZerosTypedArray(o,n);for(let i=0;i<e.length;i++){const n=e[i];if(n<0)throw new Error("Input x must be non-negative!");n>=o||(l[n]+=c>0?t[i]:1)}return l}function zi(e,t,n,r=!1){const o=e.shape[0],c=e.shape[1],l=K([o,n],t.dtype);for(let i=0;i<o;i++)for(let o=0;o<c;o++){const c=e.get(i,o);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(r?l.set(1,i,c):t.size>0?l.set(l.get(i,c)+t.get(i,o),i,c):l.set(l.get(i,c)+1,i,c))}return l}function Gi(e){return(t,n,r)=>{const o=Ne.getTypedArrayFromDType(n,t.length);for(let i=0;i<t.length;++i)o[i]=e(t[i],r);return o}}function Hi(e,t,n){return({inputs:r,attrs:o,backend:c})=>{const{x:l}=r;if(Oi(l,e),"string"===l.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const d=c,h=d.data.get(l.dataId).values,f=Ne.sizeFromShape(l.shape),m=n||l.dtype,x=Ne.getArrayFromDType(m,f);for(let i=0;i<f;++i)x[i]=t(h[i],o);return d.makeTensorInfo(l.shape,m,x)}}function Xi(e,t,n){return({inputs:r,attrs:o,backend:c})=>{const{x:l}=r;if(Oi(l,e),"string"===l.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const d=c,h=d.data.get(l.dataId).values,f=n||l.dtype,m=t(h,f,o);return d.makeTensorInfo(l.shape,f,m)}}const qi=Gi((e=>Math.ceil(e)));Xi(Y.x,qi),Y.x;function Ki(e,t,n,r){const o=Ne.getArrayFromDType(n,Ne.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((input=>{const e=Ne.sizeFromShape(input.shape);o.set(input.vals,t),t+=e}))}else{let r=0;e.forEach((input=>{const e="string"===n?l.fromUint8ToStringArray(input.vals):input.vals;let c=0;for(let n=0;n<input.shape[0];++n){const l=n*t[1]+r;for(let col=0;col<input.shape[1];++col)o[l+col]=e[c++]}r+=input.shape[1]}))}return o}const Yi=Ni(((a,b)=>a===b?1:0)),Zi=(Mi(Y.X,Yi,null,"bool"),Y.X,Gi((e=>Math.exp(e)))),Qi=(Xi(Y.Z,Zi,"float32"),Y.Z,Gi((e=>Math.expm1(e)))),Ji=(Xi(Y.bb,Qi),Y.bb,Gi((e=>Math.floor(e))));Xi(Y.fb,Ji),Y.fb;function ea(e,t,n,r,o,c,l,d,h){const f=K([r,c],n);for(let i=0;i<r;i++){const n=[];let r=0;for(let t=0;t<o;t++){const c=e[i*o+t];r+=c*l[t],n.push(c)}if(r<0||r>=h/c)throw new Error(`Invalid indices: ${n} does not index into ${d}`);for(let e=0;e<c;e++)f.values[i*c+e]=t.get(...t.indexToLoc(r*c+e))}return f}function ta(e,t,n){const r=K(n,e.dtype);for(let i=0;i<r.size;++i){const n=r.indexToLoc(i).slice(),o=n[0],c=n[2],l=t.locToIndex([o,c]);n[2]=t.values[l];const d=e.locToIndex(n);0<=d&&d<e.values.length&&(r.values[i]=e.values[d])}return r}const na=Ni(((a,b)=>a>b?1:0)),ra=(Mi(Y.nb,na,null,"bool"),Y.nb,Ni(((a,b)=>a>=b?1:0))),oa=(Mi(Y.ob,ra,null,"bool"),Y.ob,Ni(((a,b)=>a<b?1:0))),ia=(Mi(Y.yb,oa,null,"bool"),Y.yb,Ni(((a,b)=>a<=b?1:0)));Mi(Y.zb,ia,null,"bool"),Y.zb;function aa(e,t,n){const r=(t-e)/(n-1),o=Ne.makeZerosTypedArray(n,"float32");o[0]=e;for(let i=1;i<o.length;i++)o[i]=o[i-1]+r;return o}const sa=Gi((e=>Math.log(e)));Xi(Y.Bb,sa),Y.Bb;function ua(e,t,n,r){const o=Ne.getTypedArrayFromDType(r,Ne.sizeFromShape(n));for(let i=0;i<o.length;++i){const n=i*t;let r=e[n];for(let o=0;o<t;++o){const t=e[n+o];(Number.isNaN(t)||t>r)&&(r=t)}o[i]=r}return o}const ca=Ni(((e,t)=>Math.max(e,t))),la=(Mi(Y.Mb,ca),Y.Mb,Ni(((e,t)=>Math.min(e,t)))),da=(Mi(Y.Pb,la),Y.Pb,Ni(((e,t)=>e*t))),ha=ji(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})));Mi(Y.Tb,da,ha),Y.Tb;function pa(e,t,n){const r=Ne.createScalarValue(-1,n);return da([],t,r,e,n)}Y.Ub;const fa=Ni(((a,b)=>a!==b?1:0));Mi(Y.Yb,fa,null,"bool"),Y.Yb;function ga(e,t,n,r,o){const c=t.length,l=Ne.sizeFromShape(t),d=Ne.computeStrides(t),h=Ne.computeStrides(o),f=Ne.getTypedArrayFromDType(n,Ne.sizeFromShape(o));for(let i=0;i<l;++i){const t=Ne.indexToLoc(i,c,d),n=new Array(t.length);for(let i=0;i<n.length;i++)n[i]=t[r[i]];f[Ne.locToIndex(n,c,h)]=e[i]}return f}Y.ed;function ma(e,t,n,r){const[o,c]=l.computeOutAndReduceShapes(e,r),d=Object(_e.b)(t,"int32"),h=Ne.makeZerosTypedArray(Ne.sizeFromShape(o),d),f=Ne.sizeFromShape(c);for(let i=0;i<h.length;++i){const e=i*f;let t=1;for(let r=0;r<f;++r)t*=n[e+r];h[i]=t}return{outVals:h,outShape:o,outDtype:d}}Y.fc;function ba(e,t,n,r){const o=[];let c=0;const l=t.length-1+n.length,d=new Array(l).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],o=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>o)throw new Error("Ragged splits must not point past values");for(let i=1;i<r.length;++i)if(r[i-1]>r[i])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let h=1;for(let e=0;e<t.length-1;++e){h*=t[e];const n=t[e+1];for(let i=1;i<h+1;++i)d[e].push(i*n)}for(let i=0;i<e.length;++i){let r=e[i],l=e[i]+1;for(let e=0;e<n.length;++e){const o=n[e],c=e+t.length-1;if(c>=0){const e=d[c],t=e[e.length-1]-o[r];for(let e=r;e<l;++e)d[c].push(o[e+1]+t)}r=o[r],l=o[l]}l!==r&&(o.push([r,l]),c+=l-r)}return{outSplits:d,valueSlices:o,numValues:c}}function xa(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function va(e,t,n,r,o){const c=t.slice();c[0]=o;const l=Ne.getArrayFromDType(n,Ne.sizeFromShape(c)),d=e.length;return function(e,t,n,r,o,c){const l=xa(t,2)[1],d=xa(c,2)[1];let h=0;for(const t of n)for(let i=t[0];i<t[1];++i){for(let t=0;t<r;++t)o[h*d+t]=e[i*l+t];++h}}(e,t,r,0===d?0:d/t[0],l,c),[l,c]}function ya(e,t,n,r,o,c,l,d){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,i)=>{if(e<0||e>=n){const r=Ne.indexToLoc(i,t.length,Ne.computeStrides(t)).join(",");throw new Error(`indices[${r}] = ${e} is not in [0, ${n})`)}}))}(c,l,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const h=r[0],{outSplits:f,valueSlices:m,numValues:x}=ba(c,l,e,h),v=function(e){const t=[];for(let i=0;i<e.length;++i){const n=e[i].length,r=Ne.getArrayFromDType("int32",n);t.push(r),e[i].forEach(((e,t)=>r[t]=e))}return t}(f),y=va(n,r,o,m,x);return[v,y[0],y[1]]}var wa=l.RowPartitionType;class Ca{constructor(e,t,n,r,o,c,d,h,f,m){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=o,this.defaultValue=c,this.defaultValueShape=d,this.rowPartitionValues=h,this.rowPartitionValuesShapes=f,this.rowPartitionTypes=l.getRowPartitionTypesHelper(m),this.raggedRank=l.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===wa.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===wa.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case wa.VALUE_ROWIDS:return Ca.getMaxWidthValueRowID(t);case wa.ROW_SPLITS:return Ca.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${wa[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let i=0;i<t-1;++i){const t=e[i+1]-e[i];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],o=0;for(let i=1;i<t;++i){const t=e[i];t!==r&&(r=t,o=Math.max(i-n,o),n=i)}return Math.max(t-n,o)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return $a(e,n)}calculateOutputSize(e){const t=this.valuesShape,n=this.defaultValueShape;l.validateDefaultValueShape(n,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=l.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);o[0]<0&&(o[0]=e);for(let i=1;i<=this.raggedRank;++i)o[i]<0&&(o[i]=this.getMaxWidth(i));return o}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),o=[];let c=0;for(let i=0;i<r;++i,c+=t)o.push(c);for(let i=r;i<e;++i)o.push(-1);return Ne.assert(o.length===e,(()=>"Final length of result must be equal to firstDimension.")),o}calculateOutputIndexRowSplit(e,t,n,r){const o=e.length,c=[];for(let i=0;i<o-1;++i){const o=e[i+1]-e[i];let l=Math.min(r,o),d=t[i];-1===d&&(l=0);for(let e=0;e<l;++e)c.push(d),d+=n;for(let e=0;e<o-l;++e)c.push(-1)}if(o>0&&c.length!==e[o-1])throw new Error("Invalid row split size.");return c}calculateOutputIndexValueRowID(e,t,n,r){const o=e.length,c=[];if(0===o)return[];let l=0,d=e[0];if(d>=t.length)throw new Error(`Got currentValueRowId=${d}, which is not less than ${t.length}`);let h=t[d];c.push(h);for(let i=1;i<o;++i){const o=e[i];if(o===d)h>=0&&(++l,l<r?h+=n:h=-1);else{if(l=0,d=o,o>=t.length)throw new Error(`Got nextValueRowId=${o} which is not less than ${t.length}`);h=t[o]}c.push(h)}if(c.length!==e.length)throw new Error("Invalid row ids.");return c}calculateOutputIndex(e,t,n,r){const o=this.getRowPartitionTensor(e),c=this.getRowPartitionTypeByDimension(e);switch(c){case wa.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,t,n,r);case wa.ROW_SPLITS:if(o.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(o,t,n,r);default:throw new Error(`Unsupported partition type: ${wa[c]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case wa.FIRST_DIM_SIZE:return e[0];case wa.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case wa.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${wa[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let i=n.length-2;i>=0;--i)n[i]=n[i+1]*t[i+1];const r=$a(t,!1),o=Ne.getArrayFromDType(this.valuesDType,Ne.sizeFromShape(r));if(n[0]*t[0]>0){let c=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let i=1;i<=this.raggedRank;++i){c=this.calculateOutputIndex(i-1,c,n[i],t[i])}this.setOutput(this.raggedRank,c,o,r)}return[r,o]}setOutput(e,t,n,r){if(0===n.length)return;const o=this.values,c=n;let l=r.slice();l=l.slice(e+1);const d=Ne.sizeFromShape(l),h=t.length;let f=this.defaultValue;if(f.length!==d&&1!==f.length){const e=this.defaultValueShape;Kt((()=>{const t=Fe(f,e),n=De(t,l);f=n.dataSync()}))}let m=0,x=0,v=0;for(let e=0;e<=h;++e){let r=e<h?t[e]:-1;if(r!==v){if(x<v){const e=o.subarray(m*d);Ia(c.subarray(x*d),e,(v-x)*d)}if(e>=h){const e=n.length;r=Math.floor(e/d)}if(r>v)if(1===this.defaultValue.length)c.subarray(v*d,r*d).fill(this.defaultValue[0]),v=r;else for(;r>v;){Ia(c.slice(v*d),f,d),++v}r<0?(m=e+1,x=v):(m=e,x=v,v=x+1)}else++v}}}function Ia(e,t,n){for(let i=0;i<n;i++)e[i]=t[i]}function $a(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function Sa(e,t,n,r,o,c,l,d,h,f){return new Ca(e,t,n,r,o,c,l,d,h,f).compute()}function ka(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return Ne.makeZerosTypedArray(0,r);const o=Math.abs(Math.ceil((t-e)/n)),c=Ne.makeZerosTypedArray(o,r);t<e&&1===n&&(n=-1),c[0]=e;for(let i=1;i<c.length;i++)c[i]=c[i-1]+n;return c}const Ea=Gi((e=>1/Math.sqrt(e)));Xi(Y.wc,Ea),Y.wc;function Ta(e,t,n,r,o,c,l,d,h,f){const m=[r/o,o],x=e.values,v=t.values;if(0===r)return K(n,t.dtype);const y=K(m,t.dtype);"string"==typeof h||"number"==typeof h?y.values.fill(h):"boolean"==typeof h&&y.values.fill(+h);for(let i=0;i<c;i++){const e=[];let c=0;for(let t=0;t<l;t++){const n=x[i*l+t];e.push(n),c+=n*d[t]}if(c<0||c>=r/o)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let e=0;e<o;e++)f?y.values[c*o+e]+=v[i*o+e]:y.values[c*o+e]=0===t.rank?v[0]:v[i*o+e]}return y}const Ra=Gi((e=>1/(1+Math.exp(-e))));Hi(Y.Bc,(e=>1/(1+Math.exp(-e)))),Y.Bc;function Oa(e,t,n,r,c){const d=o.isSliceContinous(r,t,n),h=Ne.sizeFromShape(n),f=Ne.computeStrides(r);if(d){const n=o.computeFlatOffset(t,f);return"string"===c?e.slice(n,n+h):e.subarray(n,n+h)}const m=K(r,c,"string"===c?l.fromUint8ToStringArray(e):e),x=K(n,c);for(let i=0;i<x.size;++i){const e=x.indexToLoc(i),n=e.map(((e,n)=>e+t[n]));x.set(m.get(...n),...e)}return"string"===c?l.fromStringArrayToUint8(x.values):x.values}Y.Fc;function Aa(e,t,n,r,o,c,d){const h=t[0],f=c[0],m=new Array(f),x=new Array(h),v=t[1];if(0===f){if(0!==h)throw new Error(l.getSparseFillEmptyRowsIndicesDenseShapeMismatch(h));return[Ne.getArrayFromDType(n,0),[0,v],Ne.getArrayFromDType(o,0),m,x]}let y=!0,w=0;const C=new Array(f).fill(0);for(let i=0;i<h;++i){const t=e[i*v];if(t<0)throw new Error(l.getSparseFillEmptyRowsNegativeIndexErrorMessage(i,t));if(t>=f)throw new Error(l.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(i,t,f));++C[t],y=y&&t>=w,w=t}let I=!0;for(let e=0;e<f;++e){const t=0===C[e];m[e]=t,I=I&&!t,C[e]=Math.max(C[e],1),e>0&&(C[e]+=C[e-1])}if(I&&y){const t=e,n=r;for(let i=0;i<h;++i)x[i]=i;return[t,[h,v],n,m,x]}{const t=C[f-1],c=Ne.getArrayFromDType(n,t*v),l=Ne.getArrayFromDType(o,t),y=new Array(f).fill(0);for(let i=0;i<h;++i){const t=e[i*v],n=y[t],o=(0===t?0:C[t-1])+n;y[t]++;for(let t=0;t<v;++t)c[o*v+t]=e[i*v+t];l[o]=r[i],x[i]=o}for(let e=0;e<f;++e){if(0===y[e]){const t=0===e?0:C[e-1];c[t*v+0]=e;for(let col=1;col<v;++col)c[t*v+col]=0;l[t]=d}}return[c,[t,v],l,m,x]}}function Na(e,t,n,r,o){const c=Ne.sizeFromShape(r),d=t[0],h=o.length,f=[];let m=1,x=-1;for(let e=0;e<h;++e){const t=o[e];if(-1===t){if(-1!==x)throw new Error(l.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(x,e));x=e,f.push(1)}else{if(t<0)throw new Error(l.getSparseReshapeNegativeOutputDimErrorMessage(e,t));m*=t,f.push(t)}}if(-1!==x){if(m<=0)throw new Error(l.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(c/m);if(m*e!==c)throw new Error(l.getSparseReshapeInputOutputMultipleErrorMessage(r,f));f[x]=e}if(Ne.sizeFromShape(f)!==c)throw new Error(l.getSparseReshapeInputOutputMismatchErrorMessage(r,f));const v=r.length,y=[];if(v>0){y[v-1]=1;for(let e=v-2;e>=0;--e)y[e]=y[e+1]*r[e+1]}const w=[];if(h>0){w[h-1]=1;for(let e=h-2;e>=0;--e)w[e]=w[e+1]*f[e+1]}const C=Ne.getArrayFromDType(n,d*h);for(let i=0;i<d;++i){let t=0;for(let n=0;n<v;++n)t+=e[i*v+n]*y[n];for(let e=0;e<h;++e)C[i*h+e]=Math.trunc(t/w[e]),t%=w[e]}return[C,[d,h],f]}function _a(input,e,t,n,r,o=!1,c=0){const d=n.length,h=[e[0],input.length/e[0]],f=h[1],m=d>0?r[d-1]+1:0;if(m<0)throw new Error(l.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const x=e.slice();x[0]=m;const v=x.reduce(((e,t)=>e*t),1),output=Ne.getArrayFromDType(t,v);if(0===d)return m>0&&output.fill(c),[output,x];if(m<=0)throw new Error(l.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let y=0,w=1,C=0,I=r[y];for(;;){let e=0;if(w<d){if(e=r[w],I===e){++w;continue}if(I>=e)throw new Error(l.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(I<0||I>=m)throw new Error(l.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(I,m));I>C&&output.fill(c,C*f,I*f);for(let i=y;i<w;++i){const e=n[i];if(e<0||e>=h[0])throw new Error(l.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(i,n[i],h[0]));for(let t=0;t<f;t++)output[I*f+t]+=input[e*f+t]}if(o)for(let e=0;e<f;e++)output[I*f+e]/=w-y;if(y=w,++w,C=I+1,I=e,w>d)break}return C<m&&output.fill(c,C*f,m*f),[output,x]}const Fa=Gi((e=>Math.sqrt(e))),Da=(Hi(Y.Pc,(e=>Math.sqrt(e))),Y.Pc,Ni(((a,b)=>{const e=a-b;return e*e})));Mi(Y.Rc,Da),Y.Rc;function Pa(e,t,n,r){const o=K(e,t.dtype);for(let i=0;i<o.size;i++){const e=o.indexToLoc(i),c=new Array(e.length);for(let t=0;t<c.length;t++)c[t]=e[t]*n[t]+r[t];o.set(t.get(...c),...e)}return o}class La{constructor(e,t,n,r,o,c){this.separator=Ne.encodeString(e),this.nGramWidths=t,this.leftPad=Ne.encodeString(n),this.rightPad=Ne.encodeString(r),this.padWidth=o,this.preserveShort=c}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(data,e,output,t,n,r){for(let o=0;o<n;++o){const c=this.getPadWidth(r),l=Math.max(0,c-o),d=Math.max(0,c-(n-(o+1))),h=r-(l+d),f=e+(l>0?0:o-c);let m=0;m+=l*this.leftPad.length;for(let e=0;e<h;++e)m+=data[f+e].length;m+=d*this.rightPad.length;m+=(l+d+h-1)*this.separator.length,output[t+o]=new Uint8Array(m);const x=output[t+o];let v=0;const y=e=>e.forEach((e=>x[v++]=e));for(let e=0;e<l;++e)y(this.leftPad),y(this.separator);for(let e=0;e<h-1;++e)y(data[f+e]),y(this.separator);if(h>0){y(data[f+h-1]);for(let e=0;e<d;++e)y(this.separator),y(this.rightPad)}else{for(let e=0;e<d-1;++e)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(data,e){const t=data.length,n=e.length;if(n>0){let r=e[0];if(0!==r)throw new Error(`First split value must be 0, got ${r}`);for(let i=1;i<n;++i){let n=e[i]>=r;if(n=n&&e[i]<=t,!n)throw new Error(`Invalid split value ${e[i]}, must be in [${r}, ${t}]`);r=e[i]}if(r!==t)throw new Error(`Last split value must be data size. Expected ${t}, got ${r}`)}const r=n-1,o=Ne.getArrayFromDType("int32",n);if(0===t||0===n){const e=new Array(t);for(let i=0;i<=r;++i)o[i]=0;return[e,o]}o[0]=0;for(let i=1;i<=r;++i){const t=e[i]-e[i-1];let n=0;this.nGramWidths.forEach((e=>{n+=this.getNumNGrams(t,e)})),this.preserveShort&&t>0&&0===n&&(n=1),o[i]=o[i-1]+n}const c=new Array(o[r]);for(let i=0;i<r;++i){const t=e[i];let n=o[i];if(this.nGramWidths.forEach((r=>{const o=e[i+1]-e[i],l=this.getNumNGrams(o,r);this.createNGrams(data,t,c,n,l,r),n+=l})),this.preserveShort&&n===o[i]){const r=e[i+1]-e[i];if(0===r)continue;const o=r+2*this.padWidth,l=1;this.createNGrams(data,t,c,n,l,o)}}return[c,o]}}function Ba(data,e,t,n,r,o,c,l){return new La(t,n,r,o,c,l).compute(data,e)}function Ma(e,t,n,r){if(!e.length)return;if(0===t.length){for(let i=0;i<e.length;++i)r.push(e.subarray(i,i+1));return}if(1===t.length){const o=t[0];let c=e.indexOf(o);for(;-1!==c;){const t=e.subarray(0,c);n&&0===t.length||r.push(t),c=(e=e.subarray(c+1)).indexOf(o)}return void(n&&0===e.length||r.push(e))}let o=0;for(let i=0;i<e.length+1;i++)if(i===e.length||-1!==t.indexOf(e[i])){const t=e.subarray(o,i);n&&0===t.length||r.push(t),o=i+1}}function ja(input,e,t){const n=input.length,r=[];let o=0,c=0;const l=new Array(n);for(let i=0;i<n;++i){const n=r.length;Ma(input[i],e,t,r);const d=r.length-n;l[i]=d,o+=d,c=Math.max(c,d)}const d=Ne.getArrayFromDType("int32",2*o),h=new Array(o),f=[n,c];let m=0;for(let i=0;i<n;++i)for(let e=0;e<l[i];++e)d[2*m]=i,d[2*m+1]=e,h[m]=r[m],++m;return[d,h,f]}function Ua(input,e){const output=Ne.getArrayFromDType("int32",input.length);for(let i=0;i<input.length;++i)output[i]=Ne.fingerPrint64(input[i]).modulo(e).getLowBitsUnsigned();return output}const Wa=Ni(((e,t)=>e-t)),Va=ji(((e,t,n,r)=>({real:e-n,imag:t-r})));Mi(Y.Xc,Wa,Va),Y.Xc;function za(e,t){const n=new Array(e.rank);for(let i=0;i<n.length;i++)n[i]=e.shape[i]*t[i];const r=K(n,e.dtype);for(let i=0;i<r.values.length;++i){const t=r.indexToLoc(i),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const o=e.locToIndex(n);r.values[i]=e.values[o]}return r}const Ga=(a,b)=>{const e=b.value-a.value;return 0===e?a.index-b.index:e};function Ha(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const o=r-n+1,i=t-n+1,c=Math.log(o),s=.5*Math.exp(2*c/3),l=.5*Math.sqrt(c*s*(o-s)/o)*Math.sign(i-o/2);Ha(e,t,Math.max(n,Math.floor(t-i*s/o+l)),Math.min(r,Math.floor(t+(o-i)*s/o+l)))}const o=e[t];let i=n,c=r;for(Ne.swap(e,n,t),Ga(e[r],o)>0&&Ne.swap(e,n,r);i<c;){for(Ne.swap(e,i,c),i++,c--;Ga(e[i],o)<0;)i+=1;for(;Ga(e[c],o)>0;)c-=1}0===Ga(e[n],o)?Ne.swap(e,n,c):(c+=1,Ne.swap(e,c,r)),c<=t&&(n=c+1),t<=c&&(r=c-1)}}function Xa(e,t,n,r,o){const c=t[t.length-1],[l,d]=[e.length/c,c],h=Ne.getTypedArrayFromDType(n,l*r),f=Ne.getTypedArrayFromDType("int32",l*r);for(let b=0;b<l;b++){const t=b*d,n=e.subarray(t,t+d);let c=new Array(n.length);n.forEach(((e,t)=>c[t]={value:e,index:t})),r<c.length&&(Ha(c,r),c=c.slice(0,r)),o&&c.sort(Ga);const l=b*r,m=h.subarray(l,l+r),x=f.subarray(l,l+r);for(let i=0;i<r;i++)m[i]=c[i].value,x[i]=c[i].index}const m=t.slice();return m[m.length-1]=r,[K(m,n,h),K(m,"int32",f)]}function qa(e,t,n,r){const o=Ne.parseAxisParam(t,n)[0],c=[1,n[0],1];for(let i=0;i<o;i++)c[0]*=n[i];c[1]=n[o];for(let i=o+1;i<n.length;i++)c[2]*=n[i];const l={},d=new Int32Array(n[o]),h=new X.b(c,r,e),f=[],m=1===c[0]&&1===c[2];for(let i=0;i<n[o];i++){let element;if(m)element=e[i].toString();else{const e=[];for(let t=0;t<c[0];t++)for(let n=0;n<c[2];n++)e.push(h.get(t,i,n));element=e.join(",")}if(void 0!==l[element])d[i]=l[element];else{const e=Object.keys(l).length;l[element]=e,d[i]=e,f.push(i)}}const x=c.slice();x[1]=Object.keys(l).length;const v=new X.b(x,r);f.forEach(((e,i)=>{for(let t=0;t<c[0];t++)for(let n=0;n<c[2];n++)v.set(h.get(t,e,n),t,i,n)}));const y=n.slice();return y[o]=x[1],{outputValues:v.values,outputShape:y,indices:d}}const{addImpl:Ka,bincountImpl:Ya,bincountReduceImpl:Za,castImpl:Qa,ceilImpl:Ja,concatImpl:es,equalImpl:ts,expImpl:ns,expm1Impl:rs,floorImpl:os,gatherNdImpl:is,gatherV2Impl:as,greaterImpl:ss,greaterEqualImpl:us,lessImpl:cs,lessEqualImpl:ls,linSpaceImpl:ds,logImpl:hs,maxImpl:ps,maximumImpl:fs,minimumImpl:gs,multiplyImpl:ms,negImpl:bs,notEqualImpl:xs,prodImpl:vs,raggedGatherImpl:ys,raggedTensorToTensorImpl:ws,rangeImpl:Cs,rsqrtImpl:Is,scatterImpl:$s,sigmoidImpl:Ss,simpleAbsImpl:ks,sliceImpl:Es,sparseFillEmptyRowsImpl:Ts,sparseReshapeImpl:Rs,sparseSegmentReductionImpl:Os,sqrtImpl:As,stridedSliceImpl:Ns,stringNGramsImpl:_s,stringSplitImpl:Fs,stringToHashBucketFastImpl:Ds,subImpl:Ps,tileImpl:Ls,topKImpl:Bs,transposeImpl:Ms,uniqueImpl:js}=h;function Us(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function Ws(e,t){return 1===t?[e]:Us(e,t)}class Vs{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=hi(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Ws("rc",this.rank),t=oi(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),output=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${output}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let col=0;col<=1;col++){let r=`${0===n?"r":"rp1"}, ${0===col?"c":"cp1"}`;for(let t=2;t<this.rank;t++)r=`${e[e.length-1-t]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let i=this.rank-2;i<this.rank;i++)t+=`${e[i]} >= ${this.enableShapeUniforms?`outShape[${i}]`:this.outputShape[i]}`,i<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),col=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],n=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${col};\n      bool rEdge = rp1 >= ${n};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class zs{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=hi(this.outputShape.length);let n="";for(let i=0;i<4;i++){let e="thisRC = rc;";i%2==1&&(e+="thisRC.z += 1;"),i>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i>0?"}":""}\n      `}var r,o;this.userCode=`\n      ${r=t,o=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${o?zo(["r","c","d"],"inputShape"):Wo(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Go(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class Gs{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=Xs(t,n),o=qs(e,r,n);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const c=Hs(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=c,this.log();const e=this.freeTextures[o].shift();return this.usedTextures[o].push(e),e}let l;return r===co.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===co.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===co.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===co.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===co.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(l),this.numUsedTextures++,this._numBytesAllocated+=c,this.log(),l}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const o=Xs(n,r),c=qs(t,o,r);c in this.freeTextures||(this.freeTextures[c]=[]);const l=Hs(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,r),d=Object(v.b)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==d&&this._numBytesAllocated>d?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=l):(this.freeTextures[c].push(e),this.numFreeTextures++,this._numBytesFree+=l),this.numUsedTextures--;const h=this.usedTextures[c],f=h.indexOf(e);if(f<0)throw new Error("Cannot release a texture that was never provided by this texture manager");h.splice(f,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Hs(e,t,n,r,o){const c=function(e,t){switch(e){case co.PACKED_2X2_FLOAT32:return ki(t);case co.PACKED_2X2_FLOAT16:return Ei(t);case co.UNPACKED_FLOAT32:return Ii(t);case co.UNPACKED_FLOAT16:return $i(t);case co.PACKED_4X1_UNSIGNED_BYTE:return Si(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let l;if(o){const[t,n]=po(e[0],e[1]);l=t*n}else{const[t,n]=lo(e[0],e[1]);l=t*n}const d=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,c);return l*d}function Xs(e,t){if(e===uo.UPLOAD)return co.PACKED_2X2_FLOAT32;if(e===uo.RENDER||null==e)return function(e){return Object(v.b)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?co.PACKED_2X2_FLOAT32:co.UNPACKED_FLOAT32:e?co.PACKED_2X2_FLOAT16:co.UNPACKED_FLOAT16}(t);if(e===uo.DOWNLOAD||e===uo.PIXELS)return co.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function qs(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class Ks{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=hi(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Ys="if (isnan(x)) return x;",Zs="return x;",Qs="return abs(x);";const Js="return (x >= 0.0) ? x : (exp(x) - 1.0);",eu=Ys+"\n  return (x < 0.0) ? 0.0 : x;\n",tu=Ys+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",nu="return x;",ru="return 1.0 / (1.0 + exp(-1.0 * x));",ou="return x;",iu="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",au="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",su="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",uu="return 1.0 / (1.0 + exp(-1.0 * x));";class cu{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=hi(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class lu{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=hi(this.outputShape.length);const t=e.length,n=Ws("rc",t),r=oi(t),o=function(e,t){if(1===e)return"rc";let n="";for(let i=0;i<e;i++)n+=t[i],i<e-1&&(n+=",");return n}(t,n),c=n.slice(-2),l=t<=1?"rc":`vec2(${c.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${l}));\n      }\n    `}}const du=d.whereImpl,hu={};const pu=Object(v.b)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class fu extends ro.b{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Object(v.b)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof Ri)t=e;else{const n=ao(Object(v.b)().getNumber("WEBGL_VERSION"),e);t=new Ri(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=ao(Object(v.b)().getNumber("WEBGL_VERSION"));t=new Ri(e),this.binaryCache=((n=Object(v.b)().getNumber("WEBGL_VERSION"))in hu||(hu[n]={}),hu[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Gs(this.gpgpu),this.numMBBeforeWarning=null==Object(v.b)().global.screen?1024:Object(v.b)().global.screen.height*Object(v.b)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new ro.a(this,qt())}nextDataId(){return fu.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((Object(v.b)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Object(v.b)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:uo.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,o){if(Object(v.b)().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:uo.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:o,slice:c,shape:d,isPacked:h}=t;if(null!=c){let t;t=h?new cu(d,nu):new Ks(d,nu);const n=this.runWebGLProgram(t,[{dataId:e,shape:d,dtype:r}],r),data=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),data}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const f=null!=this.activeTimers;let m,x;if(f&&(m=Ne.now()),"complex64"===r){const e=this.readSync(o.real.dataId),t=this.readSync(o.imag.dataId);x=l.mergeRealAndImagArrays(e,t)}else x=this.getValuesFromTexture(e);return f&&(this.downloadWaitMs+=Ne.now()-m),this.convertAndCacheOnCPU(e,x)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:o,dtype:c,complexTensorInfos:d,isPacked:h}=t;if(null!=o){let t;t=h?new cu(r,nu):new Ks(r,nu);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:c}],c),data=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),data}if(null!=n)return this.convertAndCacheOnCPU(e);if(Object(v.b)().getBool("DEBUG")&&!Object(v.b)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Object(v.b)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let f,m,x=null;if("complex64"!==c&&Object(v.b)().get("WEBGL_BUFFER_SUPPORTED")){f=this.decode(e);const t=this.texData.get(f.dataId);x=this.gpgpu.createBufferFromTexture(t.texture.texture,...ho(r))}if(this.pendingRead.set(e,[]),"complex64"!==c&&await this.gpgpu.createAndWaitForFence(),"complex64"===c){const e=await Promise.all([this.read(d.real.dataId),this.read(d.imag.dataId)]),t=e[0],n=e[1];m=l.mergeRealAndImagArrays(t,n)}else if(null==x)m=this.getValuesFromTexture(e);else{const e=Ne.sizeFromShape(r);m=this.gpgpu.downloadFloat32MatrixFromBuffer(x,e)}if(null!=f&&this.disposeIntermediateTensorInfo(f),null!=x){const e=this.gpgpu.gl;go(e,(()=>e.deleteBuffer(x)))}const y=this.convertAndCacheOnCPU(e,m),w=this.pendingRead.get(e);return this.pendingRead.delete(e),w.forEach((e=>e(y))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&qt().removeDataId(e,this),this.pendingDeletes--),y}readToGPU(e,t={}){const n=this.texData.get(e),{values:r,shape:o,slice:c,dtype:l,isPacked:d,texture:h}=n;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=c){let n;n=d?new cu(o,nu):new Ks(o,nu);const r=this.runWebGLProgram(n,[{dataId:e,shape:o,dtype:l}],l),c=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),c}if(null==h)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const f=this.decode(e,t.customTexShape),m=qt().makeTensorFromTensorInfo(f),x=this.texData.get(f.dataId);return Object.assign({tensorRef:m},x.texture)}bufferSync(e){const data=this.readSync(e.dataId);if("string"===e.dtype)try{const t=data.map((e=>Ne.decodeString(e)));return K(e.shape,e.dtype,t)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return K(e.shape,e.dtype,data)}checkNumericalProblems(e){if(null!=e)for(let i=0;i<e.length;i++){const t=e[i];if(!mo(t)){if(Object(v.b)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${t} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${t} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),o=Ne.sizeFromShape(t);if(Object(v.b)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),c=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...ho(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(n),c}const c=Object(v.b)().getBool("WEBGL_PACK")&&!0===r,l=c?Oo(t):t,d=c?new mi(l):new gi(l),output=this.runWebGLProgram(d,[{shape:l,dtype:n,dataId:e}],"float32"),h=this.texData.get(output.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(output),f}timerAvailable(){return Object(v.b)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const o=Ne.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),c=Ne.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const l={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Object(v.b)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(o);l.kernelMs=Ne.sum(e),l.getExtraProfileInfo=()=>e.map(((e,i)=>({name:c[i],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else l.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,l})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Object(v.b)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Ne.now(),endMs:null}}endTimer(e){return Object(v.b)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Ne.now(),e)}async getQueryTime(e){if(Object(v.b)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:o,isPacked:c,slice:l}=this.texData.get(e),d=l&&l.origDataId||e,h=this.dataRefCount.get(d);h>1?this.dataRefCount.set(d,h-1):(this.dataRefCount.delete(d),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,o,c)));const f=this.texData.get(e);f.texture=null,f.texShape=null,f.isPacked=!1,f.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=pu){return Object(v.b)().getBool("WEBGL_CPU_FORWARD")&&e.every((input=>null==this.texData.get(input.dataId).texture&&Ne.sizeFromShape(input.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){l.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return du(e.shape,t)}packedUnaryOp(e,t,n){const r=new cu(e.shape,t),o=this.compileAndRun(r,[e],n);return qt().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=ks(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Object(v.b)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Qs,e.dtype);const t=new Ks(e.shape,Qs),n=this.compileAndRun(t,[e]);return qt().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Ne.isString(n[0])){const o=n.map((e=>Ne.encodeString(e)));r=this.write(o,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return qt().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(input){const e=new lu(input.shape);return this.runWebGLProgram(e,[input],input.dtype)}packTensor(input){const e=new Vs(input.shape);return this.runWebGLProgram(e,[input],input.dtype,null,!0)}packedReshape(input,e){const t=[To(input.shape),...Ro(input.shape)],n={dtype:input.dtype,shape:t,dataId:input.dataId},r=[To(e),...Ro(e)],o=new zs(r,t),c=[t],output=this.runWebGLProgram(o,[n],input.dtype,c,!0);return{dataId:output.dataId,shape:e,dtype:output.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:o,dtype:c}=n;if(null!=t){const e=Ne.sizeFromShape(o),n=t[0]*t[1]*4;Ne.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const l=Oo(o);let d;d=r?new fi(l):new pi(l);const h=[null!=t?t:ho(l)];return{dtype:c,shape:o,dataId:this.runWebGLProgram(d,[{shape:l,dtype:c,dataId:e}],c,h,!0,t).dataId}}runWebGLProgram(e,t,n,r,o=!1,c){const output=this.makeTensorInfo(e.outputShape,n),d=this.texData.get(output.dataId);if(e.packedOutput&&(d.isPacked=!0),e.outPackingScheme===so.DENSE){const t=null!=c?c:ho(e.outputShape);d.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(d.usage=e.outTexUsage),0===Ne.sizeFromShape(output.shape))return d.values=Ne.getTypedArrayFromDType(output.dtype,0),output;const h=[],f=t.map((input=>{if("complex64"===input.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let t=this.texData.get(input.dataId);if(null==t.texture){if(!e.packedInputs&&Ne.sizeFromShape(input.shape)<=Object(v.b)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:input.shape,texData:null,isUniform:!0,uniformValues:t.values};e.packedInputs&&(t.isPacked=!0,t.shape=input.shape)}if(this.uploadToGPU(input.dataId),!!t.isPacked!=!!e.packedInputs)input=t.isPacked?this.unpackTensor(input):this.packTensor(input),h.push(input),t=this.texData.get(input.dataId);else if(t.isPacked&&!No(t.shape,input.shape)){const e=input,n=input.shape;input.shape=t.shape,input=this.packedReshape(input,n),h.push(input),t=this.texData.get(input.dataId),e.shape=n}return{shape:input.shape,texData:t,isUniform:!1}}));this.uploadToGPU(output.dataId);const m={shape:output.shape,texData:d,isUniform:!1},x=function(e,t,output){let n="";t.concat(output).forEach((t=>{const r=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const o=t.texData.texShape,{useSqueezeShape:c,uniformShape:d,keptDims:h}=ii(e.packedInputs,t.shape,o);let f="",m="",x="";if(1===d.length&&e.packedInputs){const e=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];f=`${e[0]>1}_${e[1]>1}`}else if(2!==d.length||e.packedInputs){if(d.length>2&&!e.packedInputs){const e=Ne.computeStrides(d);x=`${e[0]===o[1]}_${e[e.length-1]===o[1]}`}}else m=`${d[0]>1}_${d[1]>1}`;const v=t.shape.length,y=2===d.length&&Ne.arraysEqual(t.shape,o),w=1===Ne.sizeFromShape(t.shape),C=l.getBroadcastDims(t.shape,output.shape),I=!e.packedInputs&&v===output.shape.length&&Ne.arraysEqual(o,output.texData.texShape),$=e.packedInputs||d.length>2?"":`${o[0]>1}_${o[1]>1}`;n+=`${v}_${I}_${c?h:""}_${d.length}_${w}_${C}_${y}_${f}_${m}_${x}_${$}_${r}`}else{const e=t.isUniform?"uniform":t.texData.texShape;n+=`${t.shape}_${e}_${r}`}}));const r=e.userCode;let o=e.constructor.name;return o+="_"+n+"_"+r+`${Object(v.b)().getNumber("WEBGL_VERSION")}`,o}(e,f,m),y=this.getAndSaveBinary(x,(()=>ui(this.gpgpu,e,f,m))),w=null!=this.activeTimers;let C;w&&(C=this.startTimer()),Object(v.b)().get("ENGINE_COMPILE_ONLY")||function(e,t,n,output,r){t.program.enableShapeUniforms||(di(t.inShapeInfos,n),di([t.outShapeInfo],[output]));const o=output.texData.texture,c=output.texData.texShape;output.texData.isPacked?e.setOutputPackedMatrixTexture(o.texture,c[0],c[1]):e.setOutputMatrixTexture(o.texture,c[0],c[1]),e.setProgram(t.webGLProgram),1===Object(v.b)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((input,i)=>{const n=t.program.variableNames[i],r=t.uniformLocations[n],o=t.uniformLocations[`offset${n}`],c=t.inShapesLocations[`${n}Shape`],l=t.inTexShapesLocations[`${n}TexShape`];if(c){const{uniformShape:n}=ii(t.program.packedInputs,input.shape,input.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(c,new Int32Array(n));break;case 2:e.gl.uniform2iv(c,new Int32Array(n));break;case 3:e.gl.uniform3iv(c,new Int32Array(n));break;case 4:e.gl.uniform4iv(c,new Int32Array(n))}}if(l&&e.gl.uniform2i(l,input.texData.texShape[0],input.texData.texShape[1]),null!=r)if(input.isUniform)if(Ne.sizeFromShape(input.shape)<2)e.gl.uniform1f(r,input.uniformValues[0]);else{let t=input.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(r,t)}else null!=input.texData.slice&&null!=o&&e.gl.uniform1i(o,input.texData.slice.flatOffset),e.setInputMatrixTexture(input.texData.texture.texture,r,i)}));const l=t.outShapeLocation;if(l)switch(output.shape.length){case 1:e.gl.uniform1iv(l,new Int32Array(output.shape));break;case 2:e.gl.uniform2iv(l,new Int32Array(output.shape));break;case 3:e.gl.uniform3iv(l,new Int32Array(output.shape));break;case 4:e.gl.uniform4iv(l,new Int32Array(output.shape))}if(t.outShapeStridesLocation){const n=Ne.computeStrides(output.shape);switch(output.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,output.texData.texShape[0],output.texData.texShape[1]),t.program.customUniforms&&r&&t.program.customUniforms.forEach(((n,i)=>{const o=t.customUniformLocations[i],c=r[i];if("float"===n.type)e.gl.uniform1fv(o,c);else if("vec2"===n.type)e.gl.uniform2fv(o,c);else if("vec3"===n.type)e.gl.uniform3fv(o,c);else if("vec4"===n.type)e.gl.uniform4fv(o,c);else if("int"===n.type)e.gl.uniform1iv(o,c);else if("ivec2"===n.type)e.gl.uniform2iv(o,c);else if("ivec3"===n.type)e.gl.uniform3iv(o,c);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(o,c)}})),e.executeProgram()}(this.gpgpu,y,f,m,r),h.forEach((e=>this.disposeIntermediateTensorInfo(e))),w&&(C=this.endTimer(C),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(C)}));const I=Object(v.b)().get("WEBGL_FLUSH_THRESHOLD");if(I>0){const time=Ne.now();time-this.lastGlFlushTime>I&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=time)}if(!Object(v.b)().getBool("WEBGL_LAZILY_UNPACK")&&d.isPacked&&!1===o){const e=this.unpackTensor(output);return this.disposeIntermediateTensorInfo(output),e}return output}compileAndRun(e,t,n,r,o=!1){n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,r,o)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!Object(v.b)().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Kt((()=>{if(!Object(v.b)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Object(v.b)().getBool("DEBUG");Object(v.b)().set("DEBUG",!1);const t=this.abs(Le(1e-8)).dataSync()[0];if(Object(v.b)().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:o,texture:c,usage:l,isPacked:d}=t;if(null!=c)return;const h=null!=this.activeTimers;let f;h&&(f=Ne.now());let m=t.texShape;if(null==m&&(m=function(e,t=!1){let n=Object(v.b)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Object(v.b)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&Object(v.b)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,i)=>i>=e.length-2?Ne.nearestLargerEven(e[i]):e[i]))).length&&(e=[2,e[0]])),2!==e.length){const t=Ne.squeezeShape(e);e=t.newShape}let o=Ne.sizeFromShape(e),c=null;e.length<=1&&o<=n?c=[1,o]:2===e.length&&e[0]<=n&&e[1]<=n?c=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?c=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?c=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?c=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(c=[e[0],e[1]*e[2]*e[3]]);const l=null!=c&&Math.max(...c)>r&&Math.min(...c)<=(t?2:1)&&Math.min(...c)>0;if(null==c||l)if(t){const t=To(e);let n=2,r=2;e.length&&([n,r]=Ro(e)),o=t*(n/2)*(r/2),c=Ne.sizeToSquarishShape(o).map((e=>2*e))}else c=Ne.sizeToSquarishShape(o);return c}(n,d),t.texShape=m),null!=o){const e=Oo(n);let c,l=m[1],x=m[0];const y=o instanceof Uint8Array||o instanceof Uint8ClampedArray;!d&&y||([l,x]=po(m[0],m[1])),c=d?new xi(e,y):new bi(e,y);const w=y?[x,l]:m,C=this.makeTensorInfo(w,r),I=this.texData.get(C.dataId);I.usage=y?uo.PIXELS:uo.UPLOAD,I.texShape=w,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(C.dataId),l,x,o);const $=[[x,l]],S=!0,k=this.runWebGLProgram(c,[C],r,$,S),E=this.texData.get(k.dataId);t.texShape=E.texShape,t.isPacked=E.isPacked,t.usage=E.usage,Object(v.b)().get("ENGINE_COMPILE_ONLY")?this.disposeData(k.dataId):(t.texture=E.texture,t.values=null,this.texData.delete(k.dataId)),this.disposeIntermediateTensorInfo(C),h&&(this.uploadWaitMs+=Ne.now()-f)}else{const e=this.acquireTexture(m,l,r,d);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(a,e){if("float32"===e||"complex64"===e)return a;if("int32"===e||"bool"===e){const t="int32"===e?new Int32Array(a.length):new Uint8Array(a.length);for(let i=0;i<t.length;++i)t[i]=Math.round(a[i]);return t}throw new Error(`Unknown dtype ${e}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Ne.bytesPerElement(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const p=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}}));e.push(p)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Object(bn.a)(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw vo(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:n,infLoc:r,nanLoc:o,inShapesLocations:c,inTexShapesLocations:l,outShapeLocation:d,outShapeStridesLocation:h,outTexShapeLocation:f}=ci(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=o,e.inShapesLocations=c,e.inTexShapesLocations=l,e.outShapeLocation=d,e.outShapeStridesLocation=h,e.outTexShapeLocation=f}}}fu.nextDataId=0,to.isBrowser()&&function(e,t,n=1){x.a.registerBackend(e,t,n)}("webgl",(()=>new fu),2);const gu="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class mu{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=l.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=hi(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const bu="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class xu{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=l.assertAndGetBroadcastShape(t,n);const o=this.outputShape.length;this.enableShapeUniforms=hi(o);let c="";if(r)if(0===o||1===Ne.sizeFromShape(this.outputShape))c="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(c=`\n          ${oi(o)} coords = getOutputCoords();\n        `,1===o)this.enableShapeUniforms?c+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":c+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=Ws("coords",o);this.enableShapeUniforms?c+=`\n            bool nextRowOutOfBounds =\n              (${e[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${e[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:c+=`\n            bool nextRowOutOfBounds =\n              (${e[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${e[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${c}\n\n        setOutput(result);\n      }\n    `}}function vu(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const yu={kernelName:Y.qb,backendName:"webgl",kernelFunc:vu};function wu(e){const{inputs:t,backend:n}=e,{real:r,imag:o}=t,c=n.makeTensorInfo(r.shape,"complex64"),l=n.texData.get(c.dataId),d=vu({inputs:{x:r},backend:n}),h=vu({inputs:{x:o},backend:n});return l.complexTensorInfos={real:d,imag:h},c}const Cu={kernelName:Y.z,backendName:"webgl",kernelFunc:wu},Iu="return (a < 0.) ? b * a : a;",$u="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const Su={kernelName:Y.xb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{alpha:c}=r,l=n.makeTensorInfo([],"float32",Ne.createScalarValue(c,"float32")),d=Object(v.b)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xu($u,o.shape,l.shape):new mu(Iu,o.shape,l.shape),h=n.runWebGLProgram(d,[o,l],"float32");return n.disposeIntermediateTensorInfo(l),h}},ku="return (a < 0.) ? b * a : a;",Eu="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const Tu={kernelName:Y.ec,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:o}=t,c=Object(v.b)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xu(Eu,r.shape,o.shape):new mu(ku,r.shape,o.shape);return n.runWebGLProgram(c,[r,o],"float32")}},Ru="if (isnan(x)) return x;";function Ou({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:o,backend:c})=>{const{x:l}=o,d=c,h=r||l.dtype;if(d.shouldExecuteOnCPU([l])&&null!=n){const e=d.texData.get(l.dataId),t=n(e.values,h);return d.makeTensorInfo(l.shape,h,t)}let f;return f=Object(v.b)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new cu(l.shape,t):new Ks(l.shape,e),d.runWebGLProgram(f,[l],h)}}function Au({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:c}){return({inputs:d,backend:h})=>{const{a:a,b:b}=d,f=h;if(r&&"complex64"===a.dtype){const t=f.texData.get(a.dataId),n=f.texData.get(b.dataId),[r,o]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,o={dataId:n.dataId,dtype:n.dtype,shape:a.shape},c={dataId:r.dataId,dtype:r.dtype,shape:b.shape},l=new mu(e,a.shape,b.shape);return f.runWebGLProgram(l,[o,c],Object(_e.b)(n.dtype,r.dtype))})),c=wu({inputs:{real:r,imag:o},backend:f});return f.disposeIntermediateTensorInfo(r),f.disposeIntermediateTensorInfo(o),c}const m=c||Object(_e.b)(a.dtype,b.dtype);if(("string"===a.dtype||"string"===b.dtype||f.shouldExecuteOnCPU([a,b]))&&null!=o){const e=f.texData.get(a.dataId).values,t=f.texData.get(b.dataId).values,n="string"===a.dtype?l.fromUint8ToStringArray(e):e,r="string"===a.dtype?l.fromUint8ToStringArray(t):t,[c,d]=o(a.shape,b.shape,n,r,m),h=f.makeTensorInfo(d,m);return f.texData.get(h.dataId).values=c,h}let x;return x=Object(v.b)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new xu(t,a.shape,b.shape,n):new mu(e,a.shape,b.shape),f.runWebGLProgram(x,[a,b],m)}}function Nu(e,t=!1){if("linear"===e)return t?ou:Zs;if("relu"===e)return t?au:eu;if("elu"===e)return t?iu:Js;if("relu6"===e)return t?su:tu;if("prelu"===e)return t?Eu:ku;if("leakyrelu"===e)return t?$u:Iu;if("sigmoid"===e)return t?uu:ru;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class _u{constructor(e,t,n,r=!1,o=!1,c=!1,l=null,d=!1,h=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=hi(this.outputShape.length);const f=r?e[1]:e[2],m=Math.ceil(f/2),x=r?"i * 2, rc.y":"rc.y, i * 2",v=o?"rc.z, i * 2":"i * 2, rc.z",y=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],w=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let C="",I="";l&&(C=d?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${l}\n        }`:h?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${l}\n        }`:`vec4 activation(vec4 x) {\n          ${l}\n        }`,I="result = activation(result);");const $=c?"result += getBiasAtOutCoords();":"";c&&this.variableNames.push("bias"),d&&this.variableNames.push("preluActivationWeights"),h&&this.variableNames.push("leakyreluAlpha");let S="rc.x",k="rc.x";e[0]<t[0]?S=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(k=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${C}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${m}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${m}; i++) {\n          int batchA = ${S};\n          int batchB = ${k};\n          vec4 a = getMatrixA(batchA, ${x});\n          vec4 b = getMatrixB(batchB, ${v});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${y[0]} * ${w[0]});\n          result += (${y[1]} * ${w[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${$}\n\n        ${I}\n\n        setOutput(result);\n      }\n    `}}const Fu={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Du{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=l.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Pu="return a * b;";function Lu(e){const{inputs:t,backend:n}=e,{a:a,b:b}=t,r=l.upcastType(a.dtype,b.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(b.dataId),r=new Du(Fu.REAL,a.shape,b.shape),o=new Du(Fu.IMAG,a.shape,b.shape),c=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:b.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:b.shape}],l=n.runWebGLProgram(r,c,"float32"),d=n.runWebGLProgram(o,c,"float32"),h=wu({inputs:{real:l,imag:d},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(d),h}if(n.shouldExecuteOnCPU([a,b])){const e=n.texData.get(a.dataId),t=n.texData.get(b.dataId),[o,c]=ms(a.shape,b.shape,e.values,t.values,r),l=n.makeTensorInfo(c,r);return n.texData.get(l.dataId).values=o,l}let o;return o=Object(v.b)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xu(Pu,a.shape,b.shape):new mu(Pu,a.shape,b.shape),n.runWebGLProgram(o,[a,b],r)}const Bu={kernelName:Y.Tb,backendName:"webgl",kernelFunc:Lu};function Mu(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{shape:c}=r,l=n,d=Ne.sizeFromShape(o.shape),h=Ne.inferFromImplicitShape(c,d),f=Ne.sizeFromShape(h);Ne.assert(d===f,(()=>`The new shape (${h}) has ${f} elements and the old shape (${o.shape}) has ${d} elements. The new shape and old shape must have the same number of elements.`));const m=l.texData.get(o.dataId);return!m.isPacked||No(o.shape,h)||null!==m.texture&&No(m.shape,h)?(l.incRef(o.dataId),{dataId:o.dataId,shape:h,dtype:o.dtype}):function(input,e,t){const n=[To(input.shape),...Ro(input.shape)],r={dtype:input.dtype,shape:n,dataId:input.dataId},o=[To(e),...Ro(e)],c=new zs(o,n),l=[n],output=t.runWebGLProgram(c,[r],input.dtype,l,!0);return{dataId:output.dataId,shape:e,dtype:output.dtype}}(o,h,l)}const ju={kernelName:Y.oc,backendName:"webgl",kernelFunc:Mu};class Uu{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:o,outSize:c}=e;this.outputShape=[r,c];const l=4*Math.floor(n/4),d=n%4;let h="sumValue += dot(values, ones);";if(null!=t){const e=1/t;h=`sumValue += dot(values * ${Ne.isInt(e)?e.toPrecision(2):e}, ones);`}let f="";o%n>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===d}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}class Wu{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:o,outSize:c}=e;this.outputShape=[r,c];let l="0.0",d="";"prod"===t?l="1.0":"min"===t?(l="1.0 / 1e-20",d="min"):"max"===t&&(l="-1.0 / 1e-20",d="max");let h=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?h="sumValue":"prod"===t?h="prodValue":"all"===t?h="allValue":"any"===t&&(h="anyValue");const f=4*Math.floor(n/4),m=n%4;let x=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${d}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${d}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,v="vec4";"all"===t?(l="1.0",x="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",v="bvec4"):"any"===t&&(l="0.0",x="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",v="bvec4");let y="";o%n>0&&(y=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${l};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${y}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${l});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${f}; i += 4) {\n          int inIdx = inOffset + i;\n          ${v} values = ${v}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${x}\n        }\n\n        int inIdx = inOffset + ${f};\n        if (${1===m}) {\n          ${v} values = ${v}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${x}\n        } else if (${2===m}) {\n          ${v} values = ${v}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${x}\n        } else if (${3===m}) {\n          ${v} values = ${v}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${x}\n        }\n        setOutput(${h});\n      }\n    `}}function Vu(e,t,n,r){const o=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=l.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let c=e;for(let i=0;i<o.length;i++){const{inSize:l,windowSize:d,outSize:h}=o[i];let f,m;f="mean"===n?0===i?new Uu({windowSize:d,inSize:l,batchSize:e.shape[0],outSize:h},l):new Uu({windowSize:d,inSize:l,batchSize:e.shape[0],outSize:h}):new Wu({windowSize:d,inSize:l,batchSize:e.shape[0],outSize:h},n),m=c,c=r.runWebGLProgram(f,[c],t),m.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(m)}return c}class zu{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.rank=n.length;const r=oi(this.rank),o=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let i=0;i<e.length;i++)r[e[i]]=n[i];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class Gu{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=oi(this.rank),o=Us("rc",this.rank),c=new Array(this.rank);for(let i=0;i<t.length;i++)c[t[i]]=o[i];const l=`vec2(${c.slice(-2).join()})`,d=`++${o[this.rank-1]} < ${n[this.rank-1]}`,h=`getChannel(getA(${c.join()}), ${l})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${h};\n      if(${d}) {\n        result[1] = ${h};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${h};\n        if(${d}) {\n          result[3] = ${h};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Hu(e,t,n){const r=Object(v.b)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Gu(e.shape,t):new zu(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function Xu(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:c,keepDims:d}=r;return function(e,t,n,r){const o=t,c=e.shape.length,d=Ne.parseAxisParam(o,e.shape);let h=d;const f=l.getAxesPermutation(h,c),m=null!=f;let x=e;m&&(x=Hu(e,f,r),h=l.getInnerMostAxes(h.length,c)),l.assertAxesAreInnerMostDims("sum",h,c);const[v,y]=l.computeOutAndReduceShapes(x.shape,h);let w=v;n&&(w=l.expandShapeToKeepDim(v,d));const C=Ne.sizeFromShape(y),I=Mu({inputs:{x:x},attrs:{shape:[Ne.sizeFromShape(e.shape)/C,C]},backend:r}),$=Vu(I,Object(_e.a)(e.dtype),"sum",r),S=Mu({inputs:{x:$},attrs:{shape:w},backend:r});return r.disposeIntermediateTensorInfo(I),r.disposeIntermediateTensorInfo($),m&&r.disposeIntermediateTensorInfo(x),S}(o,c,d,n)}const qu={kernelName:Y.Yc,backendName:"webgl",kernelFunc:Xu};function Ku(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{perm:c}=r,l=n,d=o.shape.length,h=new Array(d);for(let i=0;i<h.length;i++)h[i]=o.shape[c[i]];let f;if(l.shouldExecuteOnCPU([o])){const e=l.texData.get(o.dataId).values,t=Ms(e,o.shape,o.dtype,c,h);f=l.makeTensorInfo(h,o.dtype);l.texData.get(f.dataId).values=t}else f=Hu(o,c,l);return f}const Yu={kernelName:Y.ed,backendName:"webgl",kernelFunc:Ku},Zu=1e3;function Qu({a:a,b:b,transposeA:e,transposeB:t,backend:n,bias:o=null,preluActivationWeights:c=null,leakyreluAlpha:l=0,activation:d=null}){const h=a.shape.length,f=b.shape.length,m=e?a.shape[h-2]:a.shape[h-1],x=t?b.shape[f-1]:b.shape[f-2],v=e?a.shape[h-1]:a.shape[h-2],y=t?b.shape[f-2]:b.shape[f-1],w=a.shape.slice(0,-2),C=b.shape.slice(0,-2),I=Ne.sizeFromShape(w),$=Ne.sizeFromShape(C),S=r.assertAndGetBroadcastShape(a.shape.slice(0,-2),b.shape.slice(0,-2)).concat([v,y]);Ne.assert(m===x,(()=>`Error in matMul: inner shapes (${m}) and (${x}) of Tensors with shapes ${a.shape} and ${b.shape} and transposeA=${e} and transposeB=${t} must match.`));const k=e?[I,m,v]:[I,v,m],E=t?[$,y,x]:[$,x,y],T=Mu({inputs:{x:a},backend:n,attrs:{shape:k}}),R=Mu({inputs:{x:b},backend:n,attrs:{shape:E}}),O=[T,R],A=Math.max(I,$),N=e?T.shape[1]:T.shape[2],_=null!=o,F=null!=c,D="leakyrelu"===d,P=null!=d?Nu(d,!0):null;let L;if((1===v||1===y)&&N>Zu&&!1===(_||F||D||null!=P)){let r=T,o=R;e&&(r=Ku({inputs:{x:T},backend:n,attrs:{perm:[0,2,1]}}),O.push(r)),t&&(o=Ku({inputs:{x:R},backend:n,attrs:{perm:[0,2,1]}}),O.push(o));const c=1===y;let l=r;1!==y&&(l=Mu({inputs:{x:r},backend:n,attrs:{shape:[A,N,1]}}),O.push(l));const d=1===y?2:1;let h=o;c&&(h=Mu({inputs:{x:o},backend:n,attrs:{shape:[A,1,N]}}),O.push(h));const f=Lu({inputs:{a:l,b:h},backend:n});L=Xu({inputs:{x:f},backend:n,attrs:{axis:d,keepDims:!0}}),O.push(f)}else{const r=Object(_e.b)(a.dtype,b.dtype),d=new _u(k,E,[A,v,y],e,t,_,P,F,D),h=[T,R];if(null!=o&&h.push(o),F&&h.push(c),D){const e=n.makeTensorInfo([],"float32",Ne.createScalarValue(l,"float32"));h.push(e),O.push(e)}L=n.runWebGLProgram(d,h,r)}const B=Mu({inputs:{x:L},backend:n,attrs:{shape:S}});O.push(L);for(const i of O)n.disposeIntermediateTensorInfo(i);return B}const Ju={kernelName:Y.jd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:b,bias:o,preluActivationWeights:c}=t,{transposeA:l,transposeB:d,activation:h,leakyreluAlpha:f}=r;return Qu({a:a,b:b,transposeA:l,transposeB:d,backend:n,bias:o,preluActivationWeights:c,leakyreluAlpha:f,activation:h})}},ec="return abs(x);";const tc={kernelName:Y.a,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=ks(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let o;return o=Object(v.b)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new cu(r.shape,ec):new Ks(r.shape,ec),n.runWebGLProgram(o,[r],r.dtype)}},nc=Ou({opSnippet:Ys+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),rc={kernelName:Y.b,backendName:"webgl",kernelFunc:nc},oc=Ou({opSnippet:Ys+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),ic={kernelName:Y.c,backendName:"webgl",kernelFunc:oc},ac="return a + b;",sc=Au({opSnippet:ac,packedOpSnippet:ac,supportsComplex:!0,cpuKernelImpl:Ka}),uc={kernelName:Y.d,backendName:"webgl",kernelFunc:sc};class cc{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,i)=>`T${i}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class lc{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,i)=>`T${i}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const dc={kernelName:Y.e,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,o=n;if(1===o.length)return vu({inputs:{x:o[0]},backend:r});if(o.length>Object(v.b)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(o.length/2),n=e({inputs:o.slice(0,t),backend:r}),c=e({inputs:o.slice(t),backend:r});return e({inputs:[n,c],backend:r})}const c=o.map((e=>e.dtype)).reduce(((e,t)=>Object(_e.b)(e,t))),l=o.map((e=>e.shape)),d=Object(v.b)().getBool("WEBGL_PACK")?new lc(o[0].shape,l):new cc(o[0].shape,l);return r.runWebGLProgram(d,o,c)}};const hc={kernelName:Y.f,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:c,keepDims:d}=r,h=o.shape.length,f=Ne.parseAxisParam(c,o.shape);let m=f;const x=l.getAxesPermutation(m,h);let v=o;null!=x&&(v=Ku({inputs:{x:o},backend:n,attrs:{perm:x}}),m=l.getInnerMostAxes(m.length,h)),l.assertAxesAreInnerMostDims("all",m,h);const[y,w]=l.computeOutAndReduceShapes(v.shape,m),C=Mu({inputs:{x:v},backend:n,attrs:{shape:[-1,Ne.sizeFromShape(w)]}}),I=Vu(C,C.dtype,"all",n);let $;if(d){$=Mu({inputs:{x:I},backend:n,attrs:{shape:l.expandShapeToKeepDim(y,f)}})}else $=Mu({inputs:{x:I},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(C),n.disposeIntermediateTensorInfo(I),null!=x&&n.disposeIntermediateTensorInfo(v),$}};const pc={kernelName:Y.g,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:c,keepDims:d}=r,h=o.shape.length,f=Ne.parseAxisParam(c,o.shape);let m=f;const x=l.getAxesPermutation(m,h);let v=o;null!=x&&(v=Ku({inputs:{x:o},backend:n,attrs:{perm:x}}),m=l.getInnerMostAxes(m.length,h)),l.assertAxesAreInnerMostDims("any",m,h);const[y,w]=l.computeOutAndReduceShapes(v.shape,m),C=Mu({inputs:{x:v},backend:n,attrs:{shape:[-1,Ne.sizeFromShape(w)]}}),I=Vu(C,C.dtype,"any",n);let $;if(d){$=Mu({inputs:{x:I},backend:n,attrs:{shape:l.expandShapeToKeepDim(y,f)}})}else $=Mu({inputs:{x:I},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(C),n.disposeIntermediateTensorInfo(I),null!=x&&n.disposeIntermediateTensorInfo(v),$}};class fc{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:o,outSize:c}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[o,c];const l="max"===t?">":"<",d=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${d};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${l} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class gc{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Ne.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const o=e[e.length-1],c=Math.ceil(o/t);this.outputShape=e.slice(0,-1),c>1&&this.outputShape.push(c),r||this.variableNames.push("bestIndicesA");const l=this.outputShape,d=l.length,h=oi(d),f=Ws("coords",d);let m,x;if(1===c){x=d+1;const e=oi(x);m=`\n        ${e} sourceLocR = ${e}(${f.join()}, 0);\n        ++${f[d-1]};\n        ${e} sourceLocG = ${e}(${f.join()}, 0);\n        ++${f[d-2]};\n        ${e} sourceLocA = ${e}(${f.join()}, 0);\n        --${f[d-1]};\n        ${e} sourceLocB = ${e}(${f.join()}, 0);\n        --${f[d-2]};`}else x=d,m=`\n        ${h} sourceLocR = coords;\n        ++${f[d-1]};\n        ${h} sourceLocG = coords;\n        ++${f[d-2]};\n        ${h} sourceLocA = coords;\n        --${f[d-1]};\n        ${h} sourceLocB = coords;\n        --${f[d-2]};`;const v=["x","y","z","w","u","v"].slice(0,x),y="."+v[x-1],w=v.map((e=>"int "+e)),C=Ws("sourceLocR",x-1).concat("inIdx.r"),I=Ws("sourceLocG",x-1).concat("inIdx.g"),$=Ws("sourceLocB",x-1).concat("inIdx.b"),S=Ws("sourceLocA",x-1).concat("inIdx.a"),k="max"===n?"greaterThan":"lessThan",E=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${C.join()}),\n                             getBestIndicesAChannel(${I.join()}),\n                             getBestIndicesAChannel(${$.join()}),\n                             getBestIndicesAChannel(${S.join()})));`,T=`vec4(\n            getAChannel(${C.join()}),\n            hasNextCol ? getAChannel(${I.join()}) : 0.,\n            hasNextRow ? getAChannel(${$.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${S.join()}) : 0.)`,R=r?"":`\n      float getBestIndicesAChannel(${w.join()}) {\n        return getChannel(getBestIndicesA(${v.join()}),\n                                          vec2(${v.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${w.join()}) {\n        return getChannel(getA(${v.join()}),\n                               vec2(${v.slice(-2).join()}));\n      }\n      ${R}\n      void main() {\n        ${h} coords = getOutputCoords();\n        bool hasNextCol = ${f[d-1]} < ${l[d-1]-1};\n        bool hasNextRow = ${f[d-2]} < ${l[d-2]-1};\n        ${m}\n        ivec4 srcIdx = ivec4(sourceLocR${y}, sourceLocG${y},\n          sourceLocB${y}, sourceLocA${y}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${T};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${E}\n          vec4 candidate = ${T};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${k}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function mc(e,t,n,r=null){let o=t.shape[0],c=t.shape[1];null!=r&&(o=r.shape[0],c=r.shape[1]);const d=l.computeOptimalWindowSize(c),h={windowSize:d,inSize:c,batchSize:o,outSize:Math.ceil(c/d)},f=new fc(h,n,null==r),m=[t];null!=r&&m.push(r);const output=e.runWebGLProgram(f,m,"int32");if(1===output.shape[1])return output;const x=mc(e,t,n,output);return e.disposeIntermediateTensorInfo(output),x}function bc(e,t,n,r=null){const o=null!=r?r.shape:t.shape,c=o[o.length-1],d=l.computeOptimalWindowSize(c),h=new gc(o,d,n,null==r),f=null==r?[t]:[t,r],output=e.runWebGLProgram(h,f,"int32");if(output.shape.length===t.shape.length){const r=bc(e,t,n,output);return e.disposeIntermediateTensorInfo(output),r}return output}function xc(e,t,n,r){const o=[n];if(l.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),o,t.shape.length),!Object(v.b)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],c=e.texData.get(t.dataId);let d=t;null!==c&&c.isPacked&&(d=e.unpackTensor(t),n.push(d));const[h,f]=l.computeOutAndReduceShapes(d.shape,o),m=Ne.sizeFromShape(f),x=Mu({inputs:{x:d},backend:e,attrs:{shape:[-1,m]}});n.push(x);const v=mc(e,x,r);n.push(v);const y=Mu({inputs:{x:v},backend:e,attrs:{shape:h}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),y}return bc(e,t,r)}const vc={kernelName:Y.h,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:c}=r;let d=Ne.parseAxisParam(c,o.shape);const h=l.getAxesPermutation(d,o.shape.length);let f=o;const m=[];null!=h&&(f=Ku({inputs:{x:o},backend:n,attrs:{perm:h}}),m.push(f),d=l.getInnerMostAxes(d.length,f.shape.length)),l.assertAxesAreInnerMostDims("argMax",[d[0]],f.shape.length);const x=xc(n,f,d[0],"max");return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),x}};const yc={kernelName:Y.i,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:c}=r;let d=Ne.parseAxisParam(c,o.shape);const h=l.getAxesPermutation(d,o.shape.length);let f=o;const m=[];null!=h&&(f=Ku({inputs:{x:o},backend:n,attrs:{perm:h}}),m.push(f),d=l.getInnerMostAxes(d.length,f.shape.length)),l.assertAxesAreInnerMostDims("argMin",[d[0]],f.shape.length);const x=xc(n,f,d[0],"min");return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),x}},wc=Ou({opSnippet:Ys+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Cc={kernelName:Y.j,backendName:"webgl",kernelFunc:wc},Ic=Ou({opSnippet:Ys+"return log(x + sqrt(x * x + 1.0));"}),$c={kernelName:Y.k,backendName:"webgl",kernelFunc:Ic},Sc=Ou({opSnippet:Ys+"\n  return atan(x);\n"}),kc={kernelName:Y.l,backendName:"webgl",kernelFunc:Sc},Ec=Au({opSnippet:gu+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+bu+"\n  return result;\n"}),Tc={kernelName:Y.m,backendName:"webgl",kernelFunc:Ec},Rc=Ou({opSnippet:Ys+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Oc={kernelName:Y.n,backendName:"webgl",kernelFunc:Rc};class Ac{constructor(e,t,n,r=!1,o=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const c=e.filterWidth,l=e.strideHeight,d=e.strideWidth,h=e.dilationHeight,f=e.dilationWidth,m=e.effectiveFilterHeight,x=e.effectiveFilterWidth,v=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const w="avg"===t,C=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,I=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let $="0.0";if(w||($="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${l}, ${d});\n        const ivec2 pads = ivec2(${v}, ${y});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${m};\n              wR += ${h}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${x};\n                wC += ${f}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?o?C:I:`wR * ${x} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let S=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(S="avgValue / count");const k=4*Math.floor(c/4),E=c%4,T=`\n      if (${w}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${l}, ${d});\n      const ivec2 pads = ivec2(${v}, ${y});\n      const float initializationValue = ${$};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${$});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${m};\n            wR += ${h}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${k}; wC += 4) {\n            int xC = xCCorner + wC * ${f};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${f}, d),\n              getValue(batch, xR, xC + 2 * ${f}, d),\n              getValue(batch, xR, xC + 3 * ${f}, d)\n            );\n\n            ${T}\n          }\n\n          int xC = xCCorner + ${k};\n          if (${1===E}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${T}\n          } else if (${2===E}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${f}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${T}\n          } else if (${3===E}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${f}, d),\n              getValue(batch, xR, xC + 2 * ${f}, d),\n              initializationValue\n            );\n\n            ${T}\n          }\n        }\n        setOutput(${S});\n      }\n    `}}class Nc{constructor(e,t,n,r=!1,o=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const c=e.filterWidth,l=e.strideDepth,d=e.strideHeight,h=e.strideWidth,f=e.dilationDepth,m=e.dilationHeight,x=e.dilationWidth,v=e.effectiveFilterDepth,y=e.effectiveFilterHeight,w=e.effectiveFilterWidth,C=e.padInfo.front,I=e.padInfo.top,$=e.padInfo.left;this.outputShape=e.outShape;const S="avg"===t;let k="0.0";if(S||(k="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${l}, ${d}, ${h});\n        const ivec3 pads = ivec3(${C}, ${I}, ${$});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${v};\n              wD += ${f}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${y};\n                wR += ${m}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${w};\n                  wC += ${x}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${y} * ${w} +\n                      wR * ${w} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let E=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(E="avgValue / count");const T=4*Math.floor(c/4),R=c%4,O=`\n      if (${S}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${l}, ${d}, ${h});\n      const ivec3 pads = ivec3(${C}, ${I}, ${$});\n      const float initializationValue = ${k};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${k});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${v};\n            wD += ${f}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${y};\n            wR += ${m}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${T}; wC += 4) {\n              int xC = xCCorner + wC * ${x};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${x}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${x}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${x}, ch)\n              );\n\n              ${O}\n            }\n\n            int xC = xCCorner + ${T};\n            if (${1===R}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${O}\n            } else if (${2===R}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${x}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${O}\n            } else if (${3===R}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${x}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${x}, ch),\n                initializationValue\n              );\n\n              ${O}\n            }\n          }\n          setOutput(${E});\n        }\n      }\n    `}}const _c={kernelName:Y.o,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t;Mo(o,"avgPool");const{filterSize:c,strides:d,pad:h,dimRoundingMode:f}=r;Ne.assert(l.eitherStridesOrDilationsAreOne(d,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${d} and dilations '1'`));const m=l.computePool2DInfo(o.shape,c,d,1,h,f);if(1===m.filterWidth&&1===m.filterHeight&&Ne.arraysEqual(m.inShape,m.outShape))return vu({inputs:{x:o},backend:n});const x=new Ac(m,"avg",!1);return n.runWebGLProgram(x,[o],"float32")}};const Fc={kernelName:Y.p,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{filterSize:c,strides:d,pad:h,dimRoundingMode:f,dataFormat:m}=r,x=l.computePool3DInfo(o.shape,c,d,[1,1,1],h,f,m),v=new Nc(x,"avg",!1);return n.runWebGLProgram(v,[o],"float32")}};class Dc{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,x=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${f}, ${m});\n      const float avgMultiplier = float(${x});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d};\n            wR += ${c}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${h};\n            wC+= ${l}) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Pc{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,o=e.strideDepth,c=e.strideHeight,l=e.strideWidth,d=e.dilationDepth,h=e.dilationHeight,f=e.dilationWidth,m=e.effectiveFilterDepth,x=e.effectiveFilterHeight,v=e.effectiveFilterWidth,y=m-1-e.padInfo.front,w=x-1-e.padInfo.top,C=v-1-e.padInfo.left,I=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${y}, ${w}, ${C});\n      const float avgMultiplier = float(${I});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${m};\n            wD += ${d}) {\n          float dyD = float(dyDCorner + wD) / ${o}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${x};\n              wR += ${h}) {\n            float dyR = float(dyRCorner + wR) / ${c}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${v};\n                wC += ${f}) {\n              float dyC = float(dyCCorner + wC) / ${l}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Lc={kernelName:Y.q,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:o,input:input}=t,c=input,{filterSize:d,strides:h,pad:f,dimRoundingMode:m}=r,x=l.computePool3DInfo(c.shape,d,h,[1,1,1],f,m),v=new Pc(x);return n.runWebGLProgram(v,[o],c.dtype)}};const Bc={kernelName:Y.r,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:o,input:input}=t,c=input;Mo([o,input],"avgPoolGrad");const{filterSize:d,strides:h,pad:f}=r,m=l.computePool2DInfo(c.shape,d,h,1,f),x=new Dc(m);return n.runWebGLProgram(x,[o],c.dtype)}};const Mc={kernelName:Y.s,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:a,b:b}=t,{transposeA:o,transposeB:c}=r;return Qu({a:a,b:b,transposeA:o,transposeB:c,backend:n})}};class jc{constructor(e,t,n,r,o,c){this.outputShape=[],this.variableNames=["x","mean","variance"],l.assertAndGetBroadcastShape(e,t),l.assertAndGetBroadcastShape(e,n);let d="0.0";null!=r&&(l.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),d="getOffsetAtOutCoords()");let h="1.0";null!=o&&(l.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),h="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${d};\n        float scale = ${h};\n        float inv = scale * inversesqrt(variance + float(${c}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Uc{constructor(e,t,n,r,o,c){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],l.assertAndGetBroadcastShape(e,t),l.assertAndGetBroadcastShape(e,n);let d="vec4(0.0)";null!=r&&(l.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),d="getOffsetAtOutCoords()");let h="vec4(1.0)";null!=o&&(l.assertAndGetBroadcastShape(e,o),this.variableNames.push("scale"),h="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${d};\n        vec4 scale = ${h};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${c}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Wc={kernelName:Y.ib,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:o,variance:c,offset:l,scale:d}=e;Ne.assert(o.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Ne.assert(null==l||o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Ne.assert(null==d||o.shape.length===d.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:h}=n;null==h&&(h=.001);const f=[r,o,c];let m=null;null!=l&&(m=l.shape,f.push(l));let x=null;null!=d&&(x=d.shape,f.push(d));const y=Object(v.b)().getBool("WEBGL_PACK_NORMALIZATION")?new Uc(r.shape,o.shape,c.shape,m,x,h):new jc(r.shape,o.shape,c.shape,m,x,h);return t.runWebGLProgram(y,f,f[0].dtype)}};class Vc{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=oi(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return zc.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let body;body=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,i)=>`sourceLoc.${zc[i]} = start[${i}] + coords.${zc[i]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${body}\n        setOutput(getSource(${n}));\n      }\n    `}}const zc=["x","y","z","w","u","v"];class Gc{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=oi(this.rank),n=Ws("coords",this.rank),r=Ws("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,c=`getChannel(getSource(${r.join()}), ${o})`,l=`\n      result.x = ${c};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${c};\n        --${r[this.rank-1]};\n      }\n    `,d=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${c};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${c};\n        }\n      }\n    `,h=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,i)=>`start[${i}]`)).join()});`:e.map(((e,i)=>`${r[i]} = ${n[i]} + start[${i}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${h}\n        vec4 result = vec4(0.);\n        ${l}\n        ${d}\n        setOutput(result);\n      }\n    `}}function Hc(e){const{inputs:t,backend:n,attrs:r}=e,{x:c}=t,{begin:l,size:d}=r,[h,f]=o.parseSliceParams(c,l,d);if(o.assertParamsValid(c,h,f),0===Ne.sizeFromShape(f))return n.makeTensorInfo(f,c.dtype,[]);if(n.shouldExecuteOnCPU([c])||"string"===c.dtype){const e=n.texData.get(c.dataId),t=Es(e.values,h,f,c.shape,c.dtype);return n.makeTensorInfo(f,c.dtype,t)}const{isPacked:m}=n.texData.get(c.dataId),x=o.isSliceContinous(c.shape,h,f);if(m||!x){const e=Object(v.b)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Gc(f):new Vc(f),t=[h];return n.runWebGLProgram(e,[c],c.dtype,t)}return n.uploadToGPU(c.dataId),function(e,t,n,r){const c=r.texData.get(e.dataId),l=r.makeTensorInfo(n,e.dtype),d=r.texData.get(l.dataId);Object.assign(d,c),d.refCount=1,d.shape=n,d.dtype=e.dtype;let h=o.computeFlatOffset(t,Ne.computeStrides(e.shape));c.slice&&(h+=c.slice.flatOffset),d.slice={flatOffset:h,origDataId:c.slice&&c.slice.origDataId||e.dataId};const f=r.dataRefCount.get(d.slice.origDataId)||1;return r.dataRefCount.set(d.slice.origDataId,f+1),l}(c,h,f,n)}const Xc={kernelName:Y.Fc,backendName:"webgl",kernelFunc:Hc},qc={kernelName:Y.t,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{blockShape:c,crops:d}=r;Ne.assert(o.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const h=c.reduce(((a,b)=>a*b)),f=l.getReshaped(o.shape,c,h),m=l.getPermuted(f.length,c.length),x=l.getReshapedPermuted(o.shape,c,h),v=l.getSliceBeginCoords(d,c.length),y=l.getSliceSize(x,d,c.length),w=[],C=Mu({inputs:{x:o},backend:n,attrs:{shape:f}}),I=Ku({inputs:{x:C},backend:n,attrs:{perm:m}}),$=Mu({inputs:{x:I},backend:n,attrs:{shape:x}}),S=Hc({inputs:{x:$},backend:n,attrs:{begin:v,size:y}});return w.push(C),w.push(I),w.push($),w.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const Kc={kernelName:Y.u,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,weights:c}=t,{size:l}=r,d=n.readSync(o.dataId),h=n.readSync(c.dataId),f=Ya(d,h,c.dtype,c.shape,l);return n.makeTensorInfo([l],c.dtype,f)}};const Yc={kernelName:Y.v,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:o}=t,c=n.readSync(r.dataId),d=n.readSync(o.dataId),h=l.assertAndGetBroadcastShape(Array.from(c),Array.from(d));return n.makeTensorInfo([h.length],"int32",Int32Array.from(h))}},Zc=Au({opSnippet:"return float(a != b);",cpuKernelImpl:xs,dtype:"bool"}),Qc={kernelName:Y.Yb,backendName:"webgl",kernelFunc:Zc};function Jc(e){const{inputs:t,backend:n}=e,{input:input}=t;return vu({inputs:{x:n.texData.get(input.dataId).complexTensorInfos.real},backend:n})}const el={kernelName:Y.jc,backendName:"webgl",kernelFunc:Jc},tl="return float(int(x));";const nl={kernelName:Y.w,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:o}=t,{x:c}=n,{dtype:l}=o;if("complex64"===l){if("complex64"===c.dtype)return vu({inputs:{x:c},backend:r});const t=Me(c.shape),n=e({inputs:{x:c},backend:r,attrs:{dtype:"float32"}}),o=wu({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),o}if("complex64"===c.dtype){const t=Jc({inputs:{input:c},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:l}});return r.disposeIntermediateTensorInfo(t),n}if(!Ne.hasEncodingLoss(c.dtype,l)){const e=vu({inputs:{x:c},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:l}}if(r.shouldExecuteOnCPU([c])){const e=r.texData.get(c.dataId).values,[t,n,o]=Qa(e,c.shape,c.dtype,l);return r.makeTensorInfo(t,n,o)}if("int32"===l)return function(input,e){const t=new Ks(input.shape,tl),output=e.runWebGLProgram(t,[input],"int32");return{dataId:output.dataId,shape:output.shape,dtype:output.dtype}}(c,r);if("bool"===l){const e=r.makeTensorInfo([],"bool",Ne.getTypedArrayFromDType("bool",1)),t=Zc({inputs:{a:c,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${c.dtype} to ${l}`)}},rl="return ceil(x);",il=Ou({opSnippet:rl,packedOpSnippet:rl,cpuKernelImpl:Ja}),al={kernelName:Y.x,backendName:"webgl",kernelFunc:il};class sl{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class cl{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const ll={kernelName:Y.y,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{clipValueMin:c,clipValueMax:l}=r;let d;d=Object(v.b)().getBool("WEBGL_PACK_CLIP")?new cl(o.shape):new sl(o.shape);const h=[[c],[l]];return n.runWebGLProgram(d,[o],o.dtype,h)}};class hl{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function pl(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const fl={kernelName:Y.A,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,o=n.texData.get(r.dataId),c=new hl(r.shape),l=[pl(r,o.complexTensorInfos.real),pl(r,o.complexTensorInfos.imag)];return n.runWebGLProgram(c,l,l[0].dtype)}};class gl{constructor(e){this.outputShape=[],this.outputShape=l.computeOutShape(e,1),this.variableNames=e.map(((e,i)=>`T${i}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){const e=t[i-1];n.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${e}));`)}const r=t.length,o=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${o}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class ml{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=l.computeOutShape(e,t);const n=this.outputShape,r=n.length,o=oi(r),c=Ws("coords",r),d=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,i)=>`T${i}`));const h=new Array(e.length-1);h[0]=e[0][t];for(let i=1;i<h.length;i++)h[i]=h[i-1]+e[i][t];const f=d[t],m=d.slice(-2),x=d.join();let v=`if (${f} < ${h[0]}) {\n        return getChannel(\n            getT0(${x}), vec2(${m.join()}));\n        }`;for(let i=1;i<h.length;i++){const e=h[i-1];v+=`\n        if (${f} < ${h[i]}  && ${f} >= ${h[i-1]}) {\n          return getChannel(\n            getT${i}(${bl(d,f,e)}),\n            vec2(${bl(m,f,e)}));\n        }`}const y=h.length,w=h[h.length-1];v+=`\n        return getChannel(\n          getT${y}(${bl(d,f,w)}),\n          vec2(${bl(m,f,w)}));`,this.userCode=`\n      float getValue(${d.map((e=>"int "+e))}) {\n        ${v}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${c}), 0., 0., 0.);\n\n        ${c[r-1]} = ${c[r-1]} + 1;\n        if (${c[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${c});\n        }\n\n        ${c[r-2]} = ${c[r-2]} + 1;\n        if (${c[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${c});\n        }\n\n        ${c[r-1]} = ${c[r-1]} - 1;\n        if (${c[r-2]} < ${n[r-2]} &&\n            ${c[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${c});\n        }\n        setOutput(result);\n      }\n    `}}function bl(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function xl(e){const{inputs:t,backend:n}=e,{input:input}=t;return vu({inputs:{x:n.texData.get(input.dataId).complexTensorInfos.imag},backend:n})}const vl={kernelName:Y.rb,backendName:"webgl",kernelFunc:xl};function yl(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>Jc({inputs:{input:e},backend:n}))),o=e.map((e=>xl({inputs:{input:e},backend:n}))),c=yl(r,t,n),l=yl(o,t,n),d=wu({inputs:{real:c,imag:l},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),o.forEach((i=>n.disposeIntermediateTensorInfo(i))),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),d}let o=n.shouldExecuteOnCPU(e);if("string"===r&&(o=!0),o){const o=e.map((e=>{const r=Ne.sizeFromShape(e.shape.slice(t));return Mu({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),c=o.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),d=l.computeOutShape(o.map((e=>e.shape)),1),h=1===o[0].shape[0],f=es(c,d,r,h),m=l.computeOutShape(e.map((e=>e.shape)),t),x=n.makeTensorInfo(m,r,f);return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),x}const c=Object(v.b)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(e.length>c){const r=[];for(let i=0;i<e.length;i+=c){const o=e.slice(i,i+c);r.push(yl(o,t,n))}const o=yl(r,t,n);for(const i of r)n.disposeIntermediateTensorInfo(i);return o}if(Object(v.b)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const o=new ml(e.map((e=>e.shape)),t);return n.runWebGLProgram(o,e,r)}const{tensors2D:d,outShape:h}=function(e,t,n){const r=l.computeOutShape(e.map((e=>e.shape)),t),o=e.map((e=>Mu({inputs:{x:e},attrs:{shape:[-1,Ne.sizeFromShape(e.shape.slice(t))]},backend:n})));return{tensors2D:o,outShape:r}}(e,t,n),f=new gl(d.map((e=>e.shape))),m=n.runWebGLProgram(f,d,r);d.forEach((e=>n.disposeIntermediateTensorInfo(e)));const x=Mu({inputs:{x:m},attrs:{shape:h},backend:n});return n.disposeIntermediateTensorInfo(m),x}function wl(e){const{inputs:t,backend:n,attrs:r}=e,{axis:o}=r,c=Ne.parseAxisParam(o,t[0].shape)[0],d=t.map((e=>e.shape));l.assertParamsConsistent(d,c);const h=l.computeOutShape(t.map((e=>e.shape)),c);if(0===Ne.sizeFromShape(h))return n.makeTensorInfo(h,t[0].dtype,[]);const f=t.filter((e=>Ne.sizeFromShape(e.shape)>0));return 1===f.length?vu({inputs:{x:f[0]},backend:n}):yl(f,c,n)}const Cl={kernelName:Y.B,backendName:"webgl",kernelFunc:wl};class Il{constructor(e,t=!1,n=null,r=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const c=e.padInfo.top,l=e.padInfo.left,d=e.strideHeight,h=e.strideWidth,f=e.dilationHeight,m=e.dilationWidth,x=e.filterHeight,v=e.filterWidth,y=4*Math.floor(e.inChannels/4),w=e.inChannels%4,C="channelsLast"===e.dataFormat,I=C?1:2,$=C?2:3,S=C?3:1;let k="",E="";n&&(k=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,E="result = activation(result);");const T=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${k}\n\n      const ivec2 strides = ivec2(${d}, ${h});\n      const ivec2 pads = ivec2(${c}, ${l});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${S}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${I}], coords[${$}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${x}; wR++) {\n          int xR = xRCorner + wR * ${f};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC++) {\n            int xC = xCCorner + wC * ${m};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${y}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${C}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===w}) {\n\n              if (${C}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${y}) *\n                    getW(wR, wC, ${y}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${y}, xR, xC) *\n                    getW(wR, wC, ${y}, d2);\n              }\n\n            } else if (${2===w}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${y}, d2),\n                getW(wR, wC, ${y} + 1, d2)\n              );\n\n              if (${C}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${y}),\n                  getX(batch, xR, xC, ${y} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${y}, xR, xC),\n                  getX(batch, ${y} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===w}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${y}, d2),\n                getW(wR, wC, ${y} + 1, d2),\n                getW(wR, wC, ${y} + 2, d2)\n              );\n\n              if (${C}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${y}),\n                  getX(batch, xR, xC, ${y} + 1),\n                  getX(batch, xR, xC, ${y} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${y}, xR, xC),\n                  getX(batch, ${y} + 1, xR, xC),\n                  getX(batch, ${y} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${T}\n        ${E}\n        setOutput(result);\n      }\n    `}}class $l{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,o=e.strideDepth,c=e.strideHeight,l=e.strideWidth,d=e.dilationDepth,h=e.dilationHeight,f=e.dilationWidth,m=e.filterDepth,x=e.filterHeight,v=e.filterWidth,y=4*Math.floor(e.inChannels/4),w=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${c}, ${l});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${m}; wF++) {\n          int xF = xFCorner + wF * ${d};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${x}; wR++) {\n            int xR = xRCorner + wR * ${h};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${v}; wC++) {\n              int xC = xCCorner + wC * ${f};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${y}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===w}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${y}) *\n                  getW(wF, wR, wC, ${y}, d2);\n              } else if (${2===w}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${y}),\n                  getX(batch, xF, xR, xC, ${y} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${y}, d2),\n                  getW(wF, wR, wC, ${y} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===w}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${y}),\n                  getX(batch, xF, xR, xC, ${y} + 1),\n                  getX(batch, xF, xR, xC, ${y} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${y}, d2),\n                  getW(wF, wR, wC, ${y} + 1, d2),\n                  getW(wF, wR, wC, ${y} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Sl{constructor(e,t=!1,n=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=hi(this.outputShape.length);const c=e.padInfo.left,l=e.strideWidth,d=e.dilationWidth,h=e.filterHeight,f=e.filterWidth,m=f;let x="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<f;e++)x+=`\n           vec4 xTexelC${2*e};\n           int xTexelC${2*e}Ready;\n           vec4 xTexelC${2*e+1};\n           int xTexelC${2*e+1}Ready;\n           vec4 xC${e};`;x+=`\n     for (int r = 0; r < ${h}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let e=0;e<f;e++)x+=`\n           xTexelC${2*e} = vec4(0.0);\n           xTexelC${2*e}Ready = 0;\n           xTexelC${2*e+1} = vec4(0.0);\n           xTexelC${2*e+1}Ready = 0;\n           xC${e} = vec4(0.0);`;x+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let t=0;t<(m+1)/2;t++){const n=2*t;if(x+=`\n           xC = xCCorner + ${n*d};\n           `,1===l){if(n<f&&(c%2==1?(x+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n               `,x+=1===d&&n>0?`\n                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                   } else {\n                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                   }\n                   `):x+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xC${n} = xTexelC${n};\n                 `,n+1<f)){const e=c%2==0?Ne.nearestLargerEven(d):d;d%2==0&&c%2==1||d%2!=0&&c%2!=1?(x+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${n+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${n+1}Ready = 1;\n                   }\n                   `,x+=d>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                     } else {\n                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                     }\n                     `:`\n                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                     `):x+=1===e?`\n                     xC${n+1} = xTexelC${n};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${n+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${n+1}Ready = 1;\n                     }\n\n                     xC${n+1} = xTexelC${n+1};\n                     `}}else n<f&&(c%2==1?(x+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n               `,n+1<f&&(x+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                 `)):(x+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(\n                   xTexelC${n}.xy, xTexelC${n+1}.xy);\n               `,n+1<f&&(x+=`\n                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                 `)));n<f&&(x+=`\n             wTexel = getW(r, ${n}, d1, d2);\n             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,n+1<f&&(x+=`\n               wTexel = getW(r, ${n+1}, d1, d2);\n               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}x+="\n     }\n   ",x+="\n     }\n   ",x+="\n     }\n   ";let v="",y="";n&&(v=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:o?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,y="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${v}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${x}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${w}\n         ${y}\n         setOutput(result);\n       }\n     `}}class kl{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=hi(this.outputShape.length);const{dataFormat:n}=t,r=Uo(),o="channelsLast"===n,c=o?1:2,l=o?2:3,d=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let h="";for(let e=0;e<=1;e++)for(let col=0;col<=1;col++)h+=`\n          blockIndex = rc.z + ${col};\n          pos = rc.y + ${e};\n\n          ${d}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${c}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${l}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${o}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+col}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+col}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${h}\n\n        ${r.output} = result;\n      }\n    `}}function El(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Tl({x:e,filter:filter,convInfo:t,backend:n,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:c=0,activation:l=null}){const d=e.shape,h=n.texData.get(e.dataId),f=t.inChannels,m=d[0]*d[1]*d[2],x=t.outChannels,v="channelsLast"===t.dataFormat;let y;const w=[];if(null!=o){const e=El(o.shape,v);null!=e&&(o=Mu({inputs:{x:o},backend:n,attrs:{shape:e}}),w.push(o))}if(null!=r){const e=El(r.shape,v);null!=e&&(r=Mu({inputs:{x:r},backend:n,attrs:{shape:e}}),w.push(r))}if(!((1===m||1===x)&&f>Zu)&&h.isPacked&&v&&null!=h.texture&&d[2]%2!=0&&Ne.arraysEqual(h.shape.slice(-3),d.slice(-3))){const f=d[0]*d[1]*(d[2]+1),m={dataId:e.dataId,shape:[1,f,t.inChannels],dtype:e.dtype},x=h.shape;h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,Ne.assert(No(h.shape,m.shape),(()=>`packed reshape ${h.shape} to ${m.shape} isn't free`));const v=Mu({inputs:{x:filter},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}});w.push(v);const C=Qu({a:m,b:v,backend:n,transposeA:false,transposeB:false,bias:r,activation:l,preluActivationWeights:o,leakyreluAlpha:c}),I=n.texData.get(C.dataId);Ne.assert(I.isPacked,(()=>"batchMatMul result is expected to be packed")),h.shape=x,I.shape=t.outShape,y=vu({inputs:{x:C},backend:n}),y.shape=t.outShape,w.push(C)}else{const d=t.outHeight*t.outWidth,h=Mu({inputs:{x:e},backend:n,attrs:{shape:v?[t.batchSize,d,t.inChannels]:[t.batchSize,t.inChannels,d]}}),f=Mu({inputs:{x:filter},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}}),m=Qu({a:v?h:f,b:v?f:h,transposeA:!v,transposeB:false,backend:n,bias:r,activation:l,preluActivationWeights:o,leakyreluAlpha:c});y=Mu({inputs:{x:m},backend:n,attrs:{shape:t.outShape}}),w.push(h),w.push(f),w.push(m)}for(const i of w)n.disposeIntermediateTensorInfo(i);return y}function Rl({x:e,filter:filter,convInfo:t,backend:n,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:c=0,activation:l=null}){const{filterWidth:d,filterHeight:h,inChannels:f,outWidth:m,outHeight:x,dataFormat:v}=t,y="channelsLast"===v,w=d*h*f,C=x*m,I=[t.batchSize,w,C],$=[];if(null!=o){const e=El(o.shape,y);null!=e&&(o=Mu({inputs:{x:o},backend:n,attrs:{shape:e}}),$.push(o))}if(null!=r){const e=El(r.shape,y);null!=e&&(r=Mu({inputs:{x:r},backend:n,attrs:{shape:e}}),$.push(r))}const S=Mu({inputs:{x:filter},backend:n,attrs:{shape:[1,w,Ne.sizeFromShape(filter.shape)/w]}});$.push(S);const k=new kl(I,t),E=[e.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],T=n.runWebGLProgram(k,[e],"float32",E),R=Mu({inputs:{x:T},backend:n,attrs:{shape:I}});$.push(T),$.push(R);const O=null!=r,A=null!=o,N="leakyrelu"===l,_=l?Nu(l,!0):null,F=new _u(y?R.shape:S.shape,y?S.shape:R.shape,y?[t.batchSize,C,t.outChannels]:[t.batchSize,t.outChannels,C],!0,!1,O,_,A,N),D=y?[R,S]:[S,R];if(r&&D.push(r),A&&D.push(o),N){const e=n.makeTensorInfo([],"float32",Ne.createScalarValue(c,"float32"));D.push(e),$.push(e)}const P=n.runWebGLProgram(F,D,"float32"),L=Mu({inputs:{x:P},backend:n,attrs:{shape:t.outShape}});$.push(P);for(const i of $)n.disposeIntermediateTensorInfo(i);return L}const Ol={kernelName:Y.C,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,filter:filter}=t,{strides:c,pad:d,dataFormat:h,dilations:f,dimRoundingMode:m}=r,x=l.convertConv2DDataFormat(h),y=l.computeConv2DInfo(o.shape,filter.shape,c,f,d,m,!1,x);let w;if(1!==y.filterHeight||1!==y.filterWidth||1!==y.dilationHeight||1!==y.dilationWidth||1!==y.strideHeight||1!==y.strideWidth||"SAME"!==y.padInfo.type&&"VALID"!==y.padInfo.type)if(y.strideWidth<=2&&"channelsLast"===x&&Object(v.b)().getBool("WEBGL_EXP_CONV")){const e=new Sl(y),t=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]];w=n.runWebGLProgram(e,[o,filter],"float32",t)}else if(Object(v.b)().getBool("WEBGL_CONV_IM2COL"))w=Rl({x:o,filter:filter,convInfo:y,backend:n});else{const e=new Il(y);w=n.runWebGLProgram(e,[o,filter],"float32")}else w=Tl({x:o,filter:filter,convInfo:y,backend:n});const C=Mu({inputs:{x:w},backend:n,attrs:{shape:y.outShape}});return n.disposeIntermediateTensorInfo(w),C}};class Al{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,c="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${o};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${c}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Nl{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,c="channelsLast"===e.dataFormat,l=t-1-e.padInfo.top,d=n-1-e.padInfo.left,h=c?1:2,f=c?2:3,m=c?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${m}];\n\n        ivec2 dyCorner = ivec2(coords[${h}], coords[${f}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${c}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class _l{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,o=e.padInfo.front,c=e.padInfo.top,l=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${o};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${c};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${l};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Fl{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,o=e.strideDepth,c=e.strideHeight,l=e.strideWidth,d=t-1-e.padInfo.front,h=n-1-e.padInfo.top,f=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${d}, ${h}, ${f});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${o}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${c}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${l}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Dl={kernelName:Y.D,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,dy:c}=t,{strides:d,pad:h,dataFormat:f,dimRoundingMode:m,filterShape:x}=r,v=l.convertConv2DDataFormat(f),y=l.computeConv2DInfo(o.shape,x,d,1,h,m,!1,v),w=new Al(y);return n.runWebGLProgram(w,[o,c],"float32")}};const Pl={kernelName:Y.E,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:o,filter:filter}=t,{inputShape:c,strides:d,pad:h,dataFormat:f,dimRoundingMode:m}=r,x=l.convertConv2DDataFormat(f),v=l.computeConv2DInfo(c,filter.shape,d,1,h,m,!1,x),y=new Nl(v);return n.runWebGLProgram(y,[o,filter],"float32")}};const Ll={kernelName:Y.F,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,filter:filter}=t,{strides:c,pad:d,dilations:h}=r,f=l.computeConv3DInfo(o.shape,filter.shape,c,h,d),m=new $l(f);return n.runWebGLProgram(m,[o,filter],"float32")}};const Bl={kernelName:Y.G,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,dy:c}=t,{strides:d,pad:h,filterShape:f}=r,m=l.computeConv3DInfo(o.shape,f,d,1,h),x=new _l(m);return n.runWebGLProgram(x,[o,c],"float32")}};const Ml={kernelName:Y.H,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:o,filter:filter}=t,{pad:c,strides:d,inputShape:h}=r,f=l.computeConv3DInfo(h,filter.shape,d,1,c),m=new Fl(f);return n.runWebGLProgram(m,[o,filter],"float32")}},jl=Ou({opSnippet:Ru+"\n  return cos(x);\n"}),Ul={kernelName:Y.I,backendName:"webgl",kernelFunc:jl},Wl=Ou({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Vl={kernelName:Y.J,backendName:"webgl",kernelFunc:Wl};class zl{constructor(e,t,n,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[c,l,d,h]=e,[f]=t,[m,x]=n;this.outputShape=[f,m,x,h];const v="bilinear"===r?1:0,[y,w]=[l-1+".0",d-1+".0"],[C,I,$]=m>1?[""+(l-1)/(m-1),"(y2-y1) * height_ratio",`y1*${y} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${y}`],[S,k,E]=x>1?[""+(d-1)/(x-1),"(x2-x1) * width_ratio",`x1*${w} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${w}`];this.userCode=`\n      const float height_ratio = float(${C});\n      const float width_ratio = float(${S});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${c}) {\n          return;\n        }\n\n        float height_scale = ${I};\n        float width_scale = ${k};\n\n        float in_y = ${$};\n        if( in_y < 0.0 || in_y > ${y} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${E};\n        if( in_x < 0.0 || in_x > ${w} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${v} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const Gl={kernelName:Y.K,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:image,boxes:o,boxInd:c}=t,{cropSize:l,method:d,extrapolationValue:h}=r,f=new zl(image.shape,o.shape,l,d,h);return n.runWebGLProgram(f,[image,o,c],"float32")}};var Hl;!function(e){e.Prod="*",e.Sum="+"}(Hl||(Hl={}));class Xl{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,c=this.op===Hl.Prod?"1.0":"0.0",l=n?c:`getX(${ql(o,"coords",this.op)})`,d=this.outputShape[this.outputShape.length-1];let h="",f="";n?(h=r?"end != "+(d-1):"end != 0",f=r?"end + 1":"end - 1"):(h=r?`end + pow2 < ${d}`:"end >= pow2",f=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${oi(o)} coords = getOutputCoords();\n        int end = ${Kl(o,"coords",this.op)};\n        float val = ${l};\n        int pow2 = int(pow(2.0, index));\n        if (${h}) {\n          int idx = ${f};\n          ${Kl(o,"coords",this.op)} = idx;\n          val ${this.op}= getX(${ql(o,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function ql(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Kl(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Yl(e,t,n,r,o,c){const d=t.shape.length,h=l.getAxesPermutation([r],d);let f=t;null!=h&&(f=Ku({inputs:{x:t},backend:n,attrs:{perm:h}}));const m=l.getInnerMostAxes(1,d)[0];if(m!==d-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const x=f.shape[m];let v=vu({inputs:{x:f},backend:n});for(let i=0;i<=Math.ceil(Math.log2(x))-1;i++){const t=new Xl(e,f.shape,!1,c),r=[[i]],o=v;v=n.runWebGLProgram(t,[v],v.dtype,r),n.disposeIntermediateTensorInfo(o)}if(o){const t=new Xl(e,f.shape,o,c),r=v;v=n.runWebGLProgram(t,[v],v.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=h){const e=Ku({inputs:{x:v},backend:n,attrs:{perm:l.getUndoAxesPermutation(h)}});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(f),e}return v}const Zl={kernelName:Y.L,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:c,exclusive:l,reverse:d}=r;return Yl(Hl.Prod,o,n,c,l,d)}};const Ql={kernelName:Y.M,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:c,exclusive:l,reverse:d}=r;return Yl(Hl.Sum,o,n,c,l,d)}};const Jl={kernelName:Y.N,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,weights:c}=t,{size:l,binaryOutput:d}=r;if(1===o.shape.length){const e=n.readSync(o.dataId),t=n.readSync(c.dataId),r=Ya(e,t,c.dtype,c.shape,l);return n.makeTensorInfo([l],c.dtype,r)}if(2===o.shape.length){const e=n.bufferSync(o),t=n.bufferSync(c),r=Za(e,t,l,d);return n.makeTensorInfo(r.shape,c.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}};class ed{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const nd={kernelName:Y.O,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{blockSize:c,dataFormat:l}=r,d=o.shape[0],h=("NHWC"===l?o.shape[1]:o.shape[2])*c,f=("NHWC"===l?o.shape[2]:o.shape[3])*c,m=("NHWC"===l?o.shape[3]:o.shape[1])/(c*c),x=new ed("NHWC"===l?[d,h,f,m]:[d,m,h,f],c,l);return n.runWebGLProgram(x,[o],o.dtype)}};class rd{constructor(e,t=!1,n=null,r=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=hi(this.outputShape.length);const c=e.filterHeight,l=e.filterWidth,d=e.outChannels/e.inChannels;let h="",f="";n&&(h=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${h}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${d};\n        int q = d2 - d1 * ${d};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${l}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}class od{constructor(e,t=!1,n=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=hi(this.outputShape.length);const c=e.outChannels/e.inChannels,l=e.padInfo.left,d=e.strideWidth,h=e.dilationWidth,f=e.filterHeight,m=e.filterWidth,x=m;let v="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<m;e++)v+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;v+=`\n    for (int r = 0; r < ${f}; r++) {\n      `;for(let e=0;e<m;e++)v+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;v+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(x+1)/2;e++){const t=2*e;if(v+=`\n          xC = xCCorner + ${t*h};\n          `,1===d){if(t<m&&(l%2==1?(v+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,v+=1===h&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):v+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<m)){const e=l%2==0?Ne.nearestLargerEven(h):h;h%2==0&&l%2==1||h%2!=0&&l%2!=1?(v+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,v+=h>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                    } else {\n                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                    }\n                    `:`\n                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                    `):v+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<m&&(l%2==1?(v+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<m&&(v+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(v+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<m&&(v+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<m&&(v+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<m&&(v+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}v+="\n    }\n  ",v+="\n      }\n    ";let y="",w="";n&&(y=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,w="result = activation(result);");const C=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${y}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${c};\n        int q = d2 - d1 * ${c};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${v}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${C}\n        ${w}\n        setOutput(result);\n      }\n    `}}const id={kernelName:Y.P,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,filter:filter}=t,{strides:c,pad:d,dilations:h,dimRoundingMode:f}=r;let m=h;null==m&&(m=[1,1]),Ne.assert(l.eitherStridesOrDilationsAreOne(c,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${m}'`));const x=l.computeConv2DInfo(o.shape,filter.shape,c,m,d,f,!0);let y;y=Object(v.b)().getBool("WEBGL_PACK_DEPTHWISECONV")&&x.strideWidth<=2&&x.outChannels/x.inChannels==1?new od(x):new rd(x);const w=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]];return n.runWebGLProgram(y,[o,filter],"float32",w)}};class ad{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,c=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${c} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${o};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class sd{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,o=e.strideWidth,c=t-1-e.padInfo.top,l=n-1-e.padInfo.left,d=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${c}, ${l});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${d}; dm++) {\n              int d2 = d1 * ${d} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const ud={kernelName:Y.Q,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,dy:c}=t,{strides:d,dilations:h,pad:f,dimRoundingMode:m,filterShape:x}=r,v=l.computeConv2DInfo(o.shape,x,d,h,f,m,!0),y=new ad(v);return n.runWebGLProgram(y,[o,c],"float32")}};const cd={kernelName:Y.R,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:o,filter:filter}=t,{strides:c,dilations:d,pad:h,dimRoundingMode:f,inputShape:m}=r,x=l.computeConv2DInfo(m,filter.shape,c,d,h,f,!0),v=new sd(x);return n.runWebGLProgram(v,[o,filter],"float32")}};class ld{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const hd={kernelName:Y.S,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,o=[...r.shape,...r.shape],c=Ne.sizeFromShape(r.shape),l=Mu({inputs:{x:r},backend:n,attrs:{shape:[c]}}),d=new ld(c),h=n.runWebGLProgram(d,[l],l.dtype),f=Mu({inputs:{x:h},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),f}};class pd{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:o,strideWidth:c,filterHeight:l,filterWidth:d,dilationHeight:h,dilationWidth:f}=e,{top:m,left:x}=r;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${c});\n      const ivec2 pads = ivec2(${m}, ${x});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${l}; h++) {\n          int hIn = hBeg + h * ${h};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${d}; w++) {\n              int wIn = wBeg + w * ${f};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const fd={kernelName:Y.T,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,filter:filter}=t,{strides:c,pad:d,dilations:h}=r,f=l.computeDilation2DInfo(o.shape,filter.shape,c,d,"NHWC",h);let m;const x=new pd(f);m=n.runWebGLProgram(x,[o,filter],"float32");const v=Mu({inputs:{x:m},backend:n,attrs:{shape:f.outShape}});return n.disposeIntermediateTensorInfo(m),v}};const gd={kernelName:Y.U,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:o}=r,c=t,{allDims:d,summedDims:h,idDims:f}=l.decodeEinsumEquation(o,c.length);l.checkEinsumDimSizes(d.length,f,c);const{path:path,steps:m}=l.getEinsumComputePath(h,f),x=m.length;let v=null,y=d.length;const w=[];for(let i=0;i<x;++i){for(const e of m[i]){const{permutationIndices:t,expandDims:r}=l.getEinsumPermutation(y,f[e]);let o;l.isIdentityPermutation(t)?o=c[e]:(o=Ku({inputs:{x:c[e]},backend:n,attrs:{perm:t}}),w.push(o));const d=o.shape.slice();for(let e=0;e<r.length;++e)d.splice(r[e],0,1);Ne.arraysEqual(o.shape,d)||(o=Mu({inputs:{x:o},backend:n,attrs:{shape:d}}),w.push(o)),null===v?v=o:(v=Lu({inputs:{a:o,b:v},backend:n}),w.push(v))}i<x-1&&(path[i]>=0&&(v=Xu({inputs:{x:v},backend:n,attrs:{axis:path[i]-(d.length-y),keepDims:!1}}),w.push(v)),y--)}for(const e of w)e!==v&&n.disposeIntermediateTensorInfo(e);return v}},md=Ou({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),bd={kernelName:Y.V,backendName:"webgl",kernelFunc:md},xd={kernelName:Y.W,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:o}=t,c=Object(v.b)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xu("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,o.shape):new mu("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,o.shape);return n.runWebGLProgram(c,[r,o],r.dtype)}},vd=Au({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:ts}),yd={kernelName:Y.X,backendName:"webgl",kernelFunc:vd},wd=Ou({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${l.ERF_P};\n  float a1 = ${l.ERF_A1};\n  float a2 = ${l.ERF_A2};\n  float a3 = ${l.ERF_A3};\n  float a4 = ${l.ERF_A4};\n  float a5 = ${l.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),Cd={kernelName:Y.Y,backendName:"webgl",kernelFunc:wd},Id=Ou({opSnippet:Ru+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:ns,dtype:"float32"}),$d={kernelName:Y.Z,backendName:"webgl",kernelFunc:Id};function Sd(e){const{inputs:t,attrs:n,backend:r}=e,{dim:o}=n,{input:input}=t,c=input.shape.length,l=input.shape.slice();let d=o;return o<0&&(Ne.assert(-(c+1)<=o,(()=>`Axis must be in the interval [${-(c+1)}, ${c}]`)),d=c+o+1),l.splice(d,0,1),Mu({inputs:{x:input},backend:r,attrs:{shape:l}})}const kd={kernelName:Y.ab,backendName:"webgl",kernelFunc:Sd},Ed="return exp(x) - 1.0;",Td=Ou({opSnippet:Ed,packedOpSnippet:Ed,cpuKernelImpl:rs}),Rd={kernelName:Y.bb,backendName:"webgl",kernelFunc:Td};class Od{constructor(component,e,t){this.variableNames=["real","imag"];const n=e[1];this.outputShape=e;const r=t?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=t?`${n}.0`:"1.0";let c;if("real"===component)c="return real * expR - imag * expI;";else{if("imag"!==component)throw new Error(`FFT component must be either "real" or "imag", got ${component}.`);c="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${c}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${n});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${n}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function Ad(e,t,n){const r=n.texData.get(e.dataId),o=Ne.sizeFromShape(e.shape),c=e.shape[e.shape.length-1],l=Mu({inputs:{x:e},backend:n,attrs:{shape:[o/c,c]}}),d=l.shape,h=new Od("real",d,t),f=new Od("imag",d,t),m=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:d},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:d}],x=n.runWebGLProgram(h,m,"float32"),v=n.runWebGLProgram(f,m,"float32"),y=wu({inputs:{real:x,imag:v},backend:n});n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v);const w=Mu({inputs:{x:y},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(y),w}const Nd={kernelName:Y.cb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:input}=t;return Ad(input,!1,n)}};class _d{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Fd(e){const{backend:t,attrs:n}=e,{shape:r,value:o}=n;let{dtype:c}=n;if(c=c||Ne.inferDtype(o),"string"===c){const e=Ne.getArrayFromDType(c,Ne.sizeFromShape(r));return e.fill(o),t.makeTensorInfo(r,c,e)}{const e=new _d(r,o),n=[[o]];return t.runWebGLProgram(e,[],c,n)}}const Dd={kernelName:Y.db,backendName:"webgl",kernelFunc:Fd};class Pd{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Ld={kernelName:Y.eb,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:image}=e,n=t,r=new Pd(image.shape);return n.runWebGLProgram(r,[image],image.dtype)}},Bd="return floor(x);",Md=Ou({opSnippet:Bd,packedOpSnippet:Bd,cpuKernelImpl:os}),jd={kernelName:Y.fb,backendName:"webgl",kernelFunc:Md},Ud=Au({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),Wd={kernelName:Y.gb,backendName:"webgl",kernelFunc:Ud};class Vd{constructor(e){this.variableNames=["A"];const t=Uo(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class zd{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Uo(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const Gd={kernelName:Y.hb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:o}=t;const{numChannels:c}=r,l="undefined"!=typeof HTMLVideoElement&&o instanceof HTMLVideoElement,d="undefined"!=typeof HTMLImageElement&&o instanceof HTMLImageElement,[h,f]=l?[o.videoWidth,o.videoHeight]:[o.width,o.height],m=[f,h],x=[f,h,c];if(d||l){const e=Object(v.b)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=Hd&&e===Xd||(Xd=e,Hd=document.createElement("canvas").getContext("2d",{willReadFrequently:Xd})),Hd.canvas.width=h,Hd.canvas.height=f,Hd.drawImage(o,0,0,h,f),o=Hd.canvas}const y=n.makeTensorInfo(m,"int32");n.texData.get(y.dataId).usage=uo.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(y.dataId),o);const w=Object(v.b)().getBool("WEBGL_PACK")?new zd(x):new Vd(x),C=n.runWebGLProgram(w,[y],"int32");return n.disposeData(y.dataId),C}};let Hd,Xd=Object(v.b)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const qd={kernelName:Y.jb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,filter:filter,bias:c,preluActivationWeights:d}=t,{strides:h,pad:f,dataFormat:m,dilations:x,dimRoundingMode:y,activation:w,leakyreluAlpha:C}=r,I=l.convertConv2DDataFormat(m),$=l.computeConv2DInfo(o.shape,filter.shape,h,x,f,y,!1,I);let S;const k=[],E=null!=c,T=null!=d,R="leakyrelu"===w,O=()=>{const e=[o,filter],t=(input,e)=>{if("NCHW"===e&&1===input.shape.length&&1!==input.shape[0]){const e=Mu({inputs:{x:input},backend:n,attrs:{shape:[input.shape[0],1,1]}});return k.push(e),e}return input};if(E&&e.push(t(c,m)),T&&e.push(t(d,m)),R){const t=n.makeTensorInfo([],"float32",Ne.createScalarValue(C,"float32"));e.push(t),k.push(t)}return e};if(1!==$.filterHeight||1!==$.filterWidth||1!==$.dilationHeight||1!==$.dilationWidth||1!==$.strideHeight||1!==$.strideWidth||"SAME"!==$.padInfo.type&&"VALID"!==$.padInfo.type)if($.strideWidth<=2&&"channelsLast"===I&&Object(v.b)().getBool("WEBGL_EXP_CONV")){const e=w?Nu(w,!0):null,t=new Sl($,E,e,T,R),r=[[$.padInfo.top,$.padInfo.left],[$.strideHeight,$.strideWidth],[$.dilationHeight,$.dilationWidth],[$.inHeight,$.inWidth]],o=O();S=n.runWebGLProgram(t,o,"float32",r)}else if(Object(v.b)().getBool("WEBGL_CONV_IM2COL"))S=Rl({x:o,filter:filter,convInfo:$,backend:n,bias:c,activation:w,preluActivationWeights:d,leakyreluAlpha:C});else{const e=w?Nu(w,!1):null,t=new Il($,E,e,T,R),r=O();S=n.runWebGLProgram(t,r,"float32")}else S=Tl({x:o,filter:filter,convInfo:$,backend:n,bias:c,activation:w,preluActivationWeights:d,leakyreluAlpha:C});const A=Mu({inputs:{x:S},backend:n,attrs:{shape:$.outShape}});return k.push(S),k.forEach((e=>n.disposeIntermediateTensorInfo(e))),A}};const Kd={kernelName:Y.kb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,filter:filter,bias:c,preluActivationWeights:d}=t,{strides:h,pad:f,dilations:m,dimRoundingMode:x,activation:y,leakyreluAlpha:w}=r,C=[];let I=m;null==I&&(I=[1,1]),Ne.assert(l.eitherStridesOrDilationsAreOne(h,I),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${h} and dilations '${I}'`));const $=l.computeConv2DInfo(o.shape,filter.shape,h,I,f,x,!0),S=Object(v.b)().getBool("WEBGL_PACK_DEPTHWISECONV")&&$.strideWidth<=2&&$.outChannels/$.inChannels==1,k=y?Nu(y,S):null,E=[o,filter],T=null!=c,R=null!=d,O="leakyrelu"===y;if(T&&E.push(c),R&&E.push(d),O){const e=n.makeTensorInfo([],"float32",Ne.createScalarValue(w,"float32"));E.push(e),C.push(e)}let A;A=S?new od($,T,k,R,O):new rd($,T,k,R,O);const N=[[$.padInfo.top,$.padInfo.left],[$.strideHeight,$.strideWidth],[$.dilationHeight,$.dilationWidth],[$.inHeight,$.inWidth]],_=n.runWebGLProgram(A,E,"float32",N);return C.forEach((e=>n.disposeIntermediateTensorInfo(e))),_}};class Yd{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const o=oi(n.length);let c="\n    int index;";for(let e=0;e<this.sliceDim;e++)c+=`\n          index = round(getIndices(coords[0], ${e}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};\n          flattenIndex += index * ${this.strides[e]};`;this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${c}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const Zd={kernelName:Y.lb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:o}=t,c=o.shape,d=c[c.length-1],h=Ne.sizeFromShape(r.shape),[f,m,x,v]=l.prepareAndValidate(r,o),y=Mu({inputs:{x:o},backend:n,attrs:{shape:[m,d]}}),w=Mu({inputs:{x:r},backend:n,attrs:{shape:[Ne.sizeFromShape(r.shape)/x,x]}});if(n.shouldExecuteOnCPU([r,o])||"string"===r.dtype){const e=n.readSync(o.dataId),t=n.bufferSync(r),c=is(e,t,r.dtype,m,d,x,v,r.shape,h);return n.makeTensorInfo(f,r.dtype,c.values)}const C=new Yd(d,v,[m,x],r.shape),I=n.runWebGLProgram(C,[w,y],w.dtype),$=Mu({inputs:{x:I},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(I),$}};class Qd{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=oi(this.rank),r=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<e.length;i++)2===i?r.push("index"):r.push(`${n[i]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function Jd(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,indices:c}=t,{axis:d,batchDims:h}=r,f=Ne.parseAxisParam(d,o.shape)[0];if(Object(v.b)().get("DEBUG")){const e=n.readSync(c.dataId),t=o.shape[f];for(let i=0;i<e.length;++i){const n=e[i];Ne.assert(n<=t-1&&n>=0,(()=>`GatherV2: the index value ${n} is not in [0, ${t-1}]`))}}const m=l.segment_util.collectGatherOpShapeInfo(o,c,f,h),x=Ne.sizeFromShape(c.shape),y=[],w=Mu({inputs:{x:o},backend:n,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),C=Mu({inputs:{x:c},backend:n,attrs:{shape:[m.batchSize,x/m.batchSize]}});y.push(w),y.push(C);const I=[m.batchSize,m.outerSize,x/m.batchSize,m.sliceSize];if(n.shouldExecuteOnCPU([o,c])||"string"===o.dtype){const e=n.bufferSync(C),t=n.bufferSync(w),r=as(t,e,I);return y.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(m.outputShape,r.dtype,r.values)}const $=new Qd(w.shape,I),S=n.runWebGLProgram($,[w,C],w.dtype);y.push(S);const k=Mu({inputs:{x:S},backend:n,attrs:{shape:m.outputShape}});return y.forEach((e=>n.disposeIntermediateTensorInfo(e))),k}const eh={kernelName:Y.mb,backendName:"webgl",kernelFunc:Jd},nh=Au({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:ss,dtype:"bool"}),rh={kernelName:Y.nb,backendName:"webgl",kernelFunc:nh},oh=Au({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:us}),ih={kernelName:Y.ob,backendName:"webgl",kernelFunc:oh};const ah={kernelName:Y.pb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:input}=t;return Ad(input,!0,n)}},sh=Ou({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),uh={kernelName:Y.sb,backendName:"webgl",kernelFunc:sh},ch=Ou({opSnippet:"return float(isinf(x));",dtype:"bool"}),lh={kernelName:Y.tb,backendName:"webgl",kernelFunc:ch},dh=Ou({opSnippet:"return float(isnan(x));",dtype:"bool"}),hh={kernelName:Y.ub,backendName:"webgl",kernelFunc:dh},ph=Au({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:cs,dtype:"bool"}),fh={kernelName:Y.yb,backendName:"webgl",kernelFunc:ph},gh=Au({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:ls,dtype:"bool"}),mh={kernelName:Y.zb,backendName:"webgl",kernelFunc:gh};const bh={kernelName:Y.Ab,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:o,num:c}=n,l=ds(r,o,c);return t.makeTensorInfo([l.length],"float32",l)}},xh=Ou({opSnippet:Ru+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:hs}),vh={kernelName:Y.Bb,backendName:"webgl",kernelFunc:xh},yh=Ou({opSnippet:Ru+"\n  return log(1.0 + x);\n"}),wh={kernelName:Y.Cb,backendName:"webgl",kernelFunc:yh},Ch=Au({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),Ih={kernelName:Y.Db,backendName:"webgl",kernelFunc:Ch},$h=Ou({opSnippet:"return float(!(x >= 1.0));"}),Sh={kernelName:Y.Eb,backendName:"webgl",kernelFunc:$h},kh=Au({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),Eh={kernelName:Y.Fb,backendName:"webgl",kernelFunc:kh};class Th{constructor(e,t,n,r,o){this.variableNames=["x"],this.outputShape=[];const c=t,l=e[3]-1;let d;this.outputShape=e;const h=`float(${n}) + float(${r}) * sum`;d=.5===o?`inversesqrt(${h})`:1===o?`1.0/(${h})`:`exp(log(${h}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${c}; j <= ${c}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${l}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${d};\n        setOutput(val);\n      }\n    `}}class Rh{constructor(e,t,n,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const c=t,l=e[3]-1;let d;this.outputShape=e;const h=`float(${n}) + float(${r}) * sum`;d=.5===o?`inversesqrt(${h})`:1===o?`1.0/(${h})`:`exp(log(${h}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${c};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${c}; j <= ${c}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${l}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${d};\n        setOutput(result);\n      }\n    `}}const Oh={kernelName:Y.vb,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{depthRadius:c,bias:l,alpha:d,beta:h}=r,f=Object(v.b)().getBool("WEBGL_PACK_NORMALIZATION")?new Rh(o.shape,c,l,d,h):new Th(o.shape,c,l,d,h);return n.runWebGLProgram(f,[o],o.dtype)}};class Ah{constructor(e,t,n,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${o})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const Nh={kernelName:Y.wb,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:o,y:c,dy:l}=t,{depthRadius:d,bias:h,alpha:f,beta:m}=r,x=new Ah(o.shape,d,h,f,m);return n.runWebGLProgram(x,[o,c,l],o.dtype)}};function _h(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{reductionIndices:c,keepDims:d}=r,h=o.shape.length,f=Ne.parseAxisParam(c,o.shape);let m=f;const x=l.getAxesPermutation(m,h),v=null!=x,y=n.shouldExecuteOnCPU([o]);let w=o;if(v){if(y){const e=n.texData.get(w.dataId).values,t=new Array(h);for(let i=0;i<t.length;i++)t[i]=o.shape[x[i]];const r=Ms(e,o.shape,o.dtype,x,t);w=n.makeTensorInfo(t,o.dtype);n.texData.get(w.dataId).values=r}else w=Hu(o,x,n);m=l.getInnerMostAxes(m.length,h)}l.assertAxesAreInnerMostDims("max",m,h);const[C,I]=l.computeOutAndReduceShapes(w.shape,m);let $,S=C;if(d&&(S=l.expandShapeToKeepDim(C,f)),y){const e=n.texData.get(w.dataId).values,t=ps(e,Ne.sizeFromShape(I),S,o.dtype);$=n.makeTensorInfo(S,o.dtype);n.texData.get($.dataId).values=t}else $=function(e,t,n,r){const o=Ne.sizeFromShape(t),c=Mu({inputs:{x:e},attrs:{shape:[Ne.sizeFromShape(e.shape)/o,o]},backend:r}),l=Vu(c,e.dtype,"max",r),d=Mu({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(l),d}(w,I,S,n);return v&&n.disposeIntermediateTensorInfo(w),$}const Fh={kernelName:Y.Gb,backendName:"webgl",kernelFunc:_h},Dh=Au({opSnippet:gu+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+bu+"\n  return result;\n",cpuKernelImpl:fs}),Ph={kernelName:Y.Mb,backendName:"webgl",kernelFunc:Dh};const Lh={kernelName:Y.Hb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t;Mo(o,"maxPool");const{filterSize:c,strides:d,pad:h,dimRoundingMode:f}=r;Ne.assert(l.eitherStridesOrDilationsAreOne(d,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${d} and dilations '1'`));const m=l.computePool2DInfo(o.shape,c,d,1,h,f);if(1===m.filterWidth&&1===m.filterHeight&&Ne.arraysEqual(m.inShape,m.outShape))return vu({inputs:{x:o},backend:n});const x=new Ac(m,"max",!1);return n.runWebGLProgram(x,[o],o.dtype)}};const Bh={kernelName:Y.Ib,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{filterSize:c,strides:d,pad:h,dataFormat:f,dimRoundingMode:m}=r,x=l.computePool3DInfo(o.shape,c,d,[1,1,1],h,m,f),v=new Nc(x,"max",!1);return n.runWebGLProgram(v,[o],o.dtype)}};class Mh{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,o=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=o-1-e.padInfo.top,d=c-1-e.padInfo.left,h=o*c-1;this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${h} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${c} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class jh{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,d=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=d-1-e.padInfo.front,x=h-1-e.padInfo.top,v=f-1-e.padInfo.left,y=d*h*f-1;this.userCode=`\n      const ivec3 pads = ivec3(${m}, ${x}, ${v});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n           wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${c}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${y} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${h} * ${f} +\n                  wR * ${f} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Uh={kernelName:Y.Jb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:o,input:input}=t,c=input,{filterSize:d,strides:h,pad:f,dimRoundingMode:m}=r,x=l.computePool3DInfo(c.shape,d,h,[1,1,1],f,m),v=new Nc(x,"max",!0),y=n.runWebGLProgram(v,[c],c.dtype),w=new jh(x),C=n.runWebGLProgram(w,[o,y],c.dtype);return n.disposeIntermediateTensorInfo(y),C}};const Wh={kernelName:Y.Kb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:o,input:input,output:output}=t,c=input;Mo([input,output],"maxPoolGrad");const{filterSize:d,strides:h,pad:f,dimRoundingMode:m}=r,x=l.computePool2DInfo(c.shape,d,h,1,f,m),v=new Ac(x,"max",!0),y=n.runWebGLProgram(v,[c],c.dtype),w=new Mh(x),C=n.runWebGLProgram(w,[o,y],c.dtype);return n.disposeIntermediateTensorInfo(y),C}};const Vh={kernelName:Y.Lb,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:o,strides:c,pad:d,includeBatchInIndex:h}=t,f=n;Ne.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const m=[1,1];Ne.assert(l.eitherStridesOrDilationsAreOne(c,m),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${c} and dilations '${m}'`));const x=l.computePool2DInfo(r.shape,o,c,m,d),[v,y]=function(e,t,n,r){let o=new Ac(n,"max",!1);const c=r.runWebGLProgram(o,[e],"float32");return o=new Ac(n,"max",!0,!0,t),[c,r.runWebGLProgram(o,[e],"float32")]}(r,h,x,f);return[v,y]}};const zh={kernelName:Y.Nb,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:o,axis:c}=t,d=n,h=r.shape.length,f=Ne.parseAxisParam(c,r.shape);let m=f;const x=l.getAxesPermutation(m,h),v=null!=x,y=d.shouldExecuteOnCPU([r]),w=[];let C=r;if(v){if(y){const e=d.texData.get(C.dataId).values,t=new Array(h);for(let i=0;i<t.length;i++)t[i]=r.shape[x[i]];const n=Ms(e,r.shape,r.dtype,x,t);C=d.makeTensorInfo(t,r.dtype);d.texData.get(C.dataId).values=n}else C=Hu(r,x,d);w.push(C),m=l.getInnerMostAxes(m.length,h)}l.assertAxesAreInnerMostDims("sum",m,h);const[I,$]=l.computeOutAndReduceShapes(C.shape,m);let S=I;o&&(S=l.expandShapeToKeepDim(I,f));const k=function(e,t,n,r){const o=Ne.sizeFromShape(t),c=Mu({inputs:{x:e},attrs:{shape:[Ne.sizeFromShape(e.shape)/o,o]},backend:r}),l=Vu(c,"float32","mean",r),d=Mu({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(l),d}(C,$,S,d);for(const i of w)d.disposeIntermediateTensorInfo(i);return k}};const Gh={kernelName:Y.Ob,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:c,keepDims:d}=r,h=o.shape.length,f=Ne.parseAxisParam(c,o.shape);let m=f;const x=l.getAxesPermutation(m,h);let v=o;null!=x&&(v=Ku({inputs:{x:o},backend:n,attrs:{perm:x}}),m=l.getInnerMostAxes(m.length,o.shape.length)),l.assertAxesAreInnerMostDims("min",m,h);const[y,w]=l.computeOutAndReduceShapes(v.shape,m),C=Mu({inputs:{x:v},backend:n,attrs:{shape:[-1,Ne.sizeFromShape(w)]}}),I=Vu(C,C.dtype,"min",n);let $;if(d){$=Mu({inputs:{x:I},backend:n,attrs:{shape:l.expandShapeToKeepDim(y,f)}})}else $=Mu({inputs:{x:I},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(C),n.disposeIntermediateTensorInfo(I),null!=x&&n.disposeIntermediateTensorInfo(v),$}},Hh=Au({opSnippet:gu+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+bu+"\n  return result;\n",cpuKernelImpl:gs}),Xh={kernelName:Y.Pb,backendName:"webgl",kernelFunc:Hh};class qh{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((p,i)=>p[0]+e[i]+p[1]));const r=e.length,o=oi(r),c=t.map((p=>p[0])).join(","),l=t.map(((p,i)=>p[0]+e[i])).join(","),d=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),h="reflect"===n?0:1;this.userCode=1!==r?`\n      ${o} start = ${o}(${c});\n      ${o} end = ${o}(${l});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${h};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${h};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${d}));\n      }\n    `:`\n        int start = ${c};\n        int end = ${l};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${h};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${h};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class Kh{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((p,i)=>p[0]+e[i]+p[1]));const r=e.length,o=oi(r),c=t.map((p=>p[0])).join(","),l=t.map(((p,i)=>p[0]+e[i])).join(","),d=Ws("rc",r),source=Ws("source",r),h=`${d[r-1]} < ${this.outputShape[r-1]}`,f=1===r?"source":`vec2(${source.slice(-2).join()})`,m="reflect"===n?0:1;let x="";if(1===r){const e=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${m};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${m};\n        }\n        source -= start;\n      `;x=`\n        ${o} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${source.join()}), ${f});\n        ${d[r-1]} += 1;\n        if(${h}) {\n          ${e}\n          result[1] = getChannel(getX(${source.join()}), ${f});\n        }\n      `}else{const e=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${m}) +\n                gte * ((end - 1) * 2 - source + ${m});\n        source -= start;\n      `;x=`\n        ${o} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${source.join()}), ${f});\n        ${d[r-1]} += 1;\n        if(${h}) {\n          ${e}\n          result[1] = getChannel(getX(${source.join()}), ${f});\n        }\n        rc = outputLoc;\n        ${d[r-2]} += 1;\n        if(${d[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${source.join()}), ${f});\n          ${d[r-1]} += 1;\n          if(${h}) {\n            ${e}\n            result[3] = getChannel(getX(${source.join()}), ${f});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${c});\n      const ${o} end = ${o}(${l});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${x}\n        setOutput(result);\n      }\n    `}}const Yh={kernelName:Y.Qb,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:o,mode:c}=n,l=Object(v.b)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Kh(r.shape,o,c):new qh(r.shape,o,c);return t.runWebGLProgram(l,[r],r.dtype)}},Zh=Au({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+bu+"\n  return result;\n"}),Qh={kernelName:Y.Rb,backendName:"webgl",kernelFunc:Zh};class Jh{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const ep=Au({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),tp={kernelName:Y.kc,backendName:"webgl",kernelFunc:ep},np="return a - b;",op=Au({opSnippet:np,packedOpSnippet:np,supportsComplex:!0,cpuKernelImpl:Ps}),ip={kernelName:Y.Xc,backendName:"webgl",kernelFunc:op};function ap(e){const{inputs:t,backend:n,attrs:r}=e,{logits:o}=t,{dim:c}=r,d=Ne.parseAxisParam([c],o.shape),h=_h({inputs:{x:o},backend:n,attrs:{reductionIndices:d,keepDims:!1}}),f=l.expandShapeToKeepDim(h.shape,d),m=Mu({inputs:{x:h},backend:n,attrs:{shape:f}}),a=op({inputs:{a:o,b:m},backend:n}),b=Id({inputs:{x:a},backend:n}),x=Xu({inputs:{x:b},backend:n,attrs:{axis:d,keepDims:!1}}),v=Mu({inputs:{x:x},backend:n,attrs:{shape:f}}),y=ep({inputs:{a:b,b:v},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),y}const sp={kernelName:Y.Gc,backendName:"webgl",kernelFunc:ap};const up={kernelName:Y.Sb,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:o}=t,{numSamples:c,seed:l,normalized:d}=r,h=d?o:ap({inputs:{logits:o},backend:n,attrs:{dim:o.shape.length-1}}),f=h.shape[0],m=h.shape[1],x=new Jh(f,m,c),v=[[l]],y=n.runWebGLProgram(x,[h],"int32",v);return d||n.disposeIntermediateTensorInfo(h),y}},cp=Ys+"\n  return -x;\n";const lp={kernelName:Y.Ub,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,o]=bs(e.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,t)}let o;return o=Object(v.b)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new cu(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Ks(r.shape,cp),n.runWebGLProgram(o,[r],r.dtype)}},dp=d.nonMaxSuppressionV3Impl;const hp={kernelName:Y.Vb,backendName:"webgl",kernelFunc:function(e){l.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:o,scores:c}=t,{maxOutputSize:d,iouThreshold:h,scoreThreshold:f}=r,m=n.readSync(o.dataId),x=n.readSync(c.dataId),{selectedIndices:v}=dp(m,x,d,h,f);return n.makeTensorInfo([v.length],"int32",new Int32Array(v))}},pp=d.nonMaxSuppressionV4Impl;const fp={kernelName:Y.Wb,backendName:"webgl",kernelFunc:function(e){l.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:o,scores:c}=t,{maxOutputSize:d,iouThreshold:h,scoreThreshold:f,padToMaxOutputSize:m}=r,x=n.readSync(o.dataId),v=n.readSync(c.dataId),{selectedIndices:y,validOutputs:w}=pp(x,v,d,h,f,m);return[n.makeTensorInfo([y.length],"int32",new Int32Array(y)),n.makeTensorInfo([],"int32",new Int32Array([w]))]}},gp=d.nonMaxSuppressionV5Impl;const mp={kernelName:Y.Xb,backendName:"webgl",kernelFunc:function(e){l.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:o,scores:c}=t,{maxOutputSize:d,iouThreshold:h,scoreThreshold:f,softNmsSigma:m}=r,x=n.readSync(o.dataId),v=n.readSync(c.dataId),y=d,w=h,C=f,I=m,{selectedIndices:$,selectedScores:S}=gp(x,v,y,w,C,I);return[n.makeTensorInfo([$.length],"int32",new Int32Array($)),n.makeTensorInfo([S.length],"float32",new Float32Array(S))]}};class bp{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const xp={kernelName:Y.Zb,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:o}=t,{dtype:c,depth:l,onValue:d,offValue:h}=r,f=Ne.sizeFromShape(o.shape),m=new bp(f,l,d,h),x=Mu({inputs:{x:o},backend:n,attrs:{shape:[f]}}),v=n.runWebGLProgram(m,[x],c);n.disposeIntermediateTensorInfo(x);const y=Mu({inputs:{x:v},backend:n,attrs:{shape:[...o.shape,l]}});return n.disposeIntermediateTensorInfo(v),y}};function vp(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=Jc({inputs:{input:r},backend:n}),t=vp({inputs:{x:e},backend:n}),o=xl({inputs:{input:r},backend:n}),i=vp({inputs:{x:o},backend:n}),c=wu({inputs:{real:t,imag:i},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),c}return Fd({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const yp={kernelName:Y.id,backendName:"webgl",kernelFunc:vp};const wp={kernelName:Y.ac,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:o}=n;if("string"===o.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===o.dtype){const t=Jc({inputs:{input:o},backend:r}),n=e({inputs:{x:t},backend:r}),c=xl({inputs:{input:o},backend:r}),i=vp({inputs:{x:c},backend:r}),l=wu({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(i),l}return Fd({attrs:{shape:o.shape,dtype:o.dtype,value:1},backend:r})}};const Cp={kernelName:Y.bc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:o}=r;if(1===t.length)return Sd({inputs:{input:t[0]},backend:n,attrs:{dim:o}});const c=t[0].shape,l=t[0].dtype;t.forEach((e=>{Ne.assertShapesMatch(c,e.shape,"All tensors passed to stack must have matching shapes"),Ne.assert(l===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const d=[],h=wl({inputs:t.map((e=>{const t=Sd({inputs:{input:e},backend:n,attrs:{dim:o}});return d.push(t),t})),backend:n,attrs:{axis:o}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}};class Ip{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((p,i)=>p[0]+e[i]+p[1]));const r=e.length,o=oi(r),c=t.map((p=>p[0])).join(","),l=t.map(((p,i)=>p[0]+e[i])).join(","),d=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${o} start = ${o}(${c});\n      ${o} end = ${o}(${l});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${d}));\n        }\n      }\n    `:`\n        int start = ${c};\n        int end = ${l};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class $p{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((p,i)=>p[0]+e[i]+p[1]));const r=e.length,o=oi(r),c=t.map((p=>p[0])).join(","),l=t.map(((p,i)=>p[0]+e[i])).join(","),d=Ws("rc",r),source=Ws("source",r),h=`${d[r-1]} < ${this.outputShape[r-1]}`,f=1===r?"source":`vec2(${source.slice(-2).join()})`,m=[`${o} rc = outputLoc;`,`${d[r-1]} += 1;\n       if(${h}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${d[r-2]} += 1;\n       if(${d[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${d[r-1]} += 1;\n         if(${h}) {`],x=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let v="";for(let i=0,e=1===r?2:4;i<e;i++)v+=`\n        ${m[i]}\n        if (${x}) {\n          result[${i}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${i}] = getChannel(getX(${source.join()}), ${f});\n        }\n      `;v+=1===r?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${c});\n      const ${o} end = ${o}(${l});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${v}\n        setOutput(result);\n      }\n    `}}const Sp=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{paddings:c,constantValue:l}=r;if(0===Ne.sizeFromShape(o.shape)){return Fd({backend:n,attrs:{shape:c.map(((p,i)=>p[0]+o.shape[i]+p[1])),value:l,dtype:o.dtype}})}const d=Object(v.b)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $p(o.shape,c,l):new Ip(o.shape,c,l),h=[[l]];return n.runWebGLProgram(d,[o],o.dtype,h)},kp={kernelName:Y.cc,backendName:"webgl",kernelFunc:Sp},Ep=Au({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+bu+"\n  return result;\n"}),Tp={kernelName:Y.dc,backendName:"webgl",kernelFunc:Ep};const Rp={kernelName:Y.fc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{axis:c,keepDims:d}=r,h=o.shape.length,f=[],m=Ne.parseAxisParam(c,o.shape);let x=m;const v=l.getAxesPermutation(x,h);let y,w=o;if(null!=v&&(w=Ku({inputs:{x:o},backend:n,attrs:{perm:v}}),x=l.getInnerMostAxes(x.length,h),f.push(w)),l.assertAxesAreInnerMostDims("prod",x,h),n.shouldExecuteOnCPU([w])){const e=n.texData.get(w.dataId).values,{outVals:t,outShape:r,outDtype:o}=vs(w.shape,w.dtype,e,x);y=n.makeTensorInfo(r,o,t)}else{const[e,t]=l.computeOutAndReduceShapes(w.shape,x),r=Ne.sizeFromShape(t),c=Mu({inputs:{x:w},backend:n,attrs:{shape:[-1,r]}}),d=Vu(c,Object(_e.a)(o.dtype),"prod",n);y=Mu({inputs:{x:d},backend:n,attrs:{shape:e}}),f.push(c),f.push(d)}if(d){f.push(y);const e=l.expandShapeToKeepDim(y.shape,m);y=Mu({inputs:{x:y},backend:n,attrs:{shape:e}})}return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};const Op={kernelName:Y.gc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:o,paramsDenseValues:c,indices:l}=t,{outputRaggedRank:d}=r,h=o.map((e=>n.readSync(e.dataId))),f=o.map((e=>e.shape)),m=n.readSync(c.dataId),x=n.readSync(l.dataId),[v,y,w]=ys(h,f,m,c.shape,c.dtype,x,l.shape,d),C=v.map((e=>n.makeTensorInfo([e.length],"int32",e))),I=n.makeTensorInfo(w,c.dtype,y);return C.concat([I])}};const Ap={kernelName:Y.hc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:o,values:c,defaultValue:l,rowPartitionTensors:d}=t,{rowPartitionTypes:h}=r,f=n.readSync(o.dataId),m=n.readSync(c.dataId),x=n.readSync(l.dataId),v=d.map((e=>n.readSync(e.dataId))),y=d.map((e=>e.shape)),[w,output]=ws(f,o.shape,m,c.shape,c.dtype,x,l.shape,v,y,h);return n.makeTensorInfo(w,c.dtype,output)}},Np=e=>{const{backend:t,attrs:n}=e,{start:r,stop:o,step:c,dtype:l}=n,d=Cs(r,o,c,l);return t.makeTensorInfo([d.length],l,d)},_p={kernelName:Y.ic,backendName:"webgl",kernelFunc:Np},Fp=Ou({opSnippet:"return 1.0 / x;"}),Dp={kernelName:Y.lc,backendName:"webgl",kernelFunc:Fp},Pp=Ou({opSnippet:Ys+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Lp={kernelName:Y.mc,backendName:"webgl",kernelFunc:Pp},Bp=Ou({opSnippet:Ys+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Mp={kernelName:Y.nc,backendName:"webgl",kernelFunc:Bp};class jp{constructor(e,t,n,r,o){this.variableNames=["A"],this.outputShape=[];const[c,l,d,h]=e;this.outputShape=[c,t,n,h];const f=[r&&t>1?l-1:l,r&&n>1?d-1:d],m=[r&&t>1?t-1:t,r&&n>1?n-1:n];let x;x=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${f[0]/m[0]},\n          ${f[1]/m[1]});\n      const vec2 inputShapeRC = vec2(${l}.0, ${d}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${x};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class Up{constructor(e,t,n,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[c,l,d,h]=e;this.outputShape=[c,t,n,h];const f=[r&&t>1?l-1:l,r&&n>1?d-1:d],m=[r&&t>1?t-1:t,r&&n>1?n-1:n];let x;x=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${f[0]/m[0]},\n          ${f[1]/m[1]},\n          ${f[1]/m[1]});\n      const vec3 inputShapeRC = vec3(${l}.0, ${d}.0,\n                                     ${d}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${x};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${h-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const Wp={kernelName:Y.pc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:o}=t,{alignCorners:c,halfPixelCenters:l,size:d}=r,[h,f]=d,m=Object(v.b)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Up(o.shape,h,f,c,l):new jp(o.shape,h,f,c,l);return n.runWebGLProgram(m,[o],"float32")}};class Vp{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,c,l]=e,d=[n&&c>1?r-1:r,n&&l>1?o-1:o],h=[n&&c>1?c-1:c,n&&l>1?l-1:l],f=d[0]/h[0],m=d[1]/h[1],x=1/f,v=1/m,y=2*Math.ceil(x)+2,w=2*Math.ceil(v)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${f});\n        const float widthScale = float(${m});\n\n        const float invHeightScale = float(${x});\n        const float invWidthScale = float(${v});\n\n        const int winHeight = int(${y});\n        const int winWidth = int(${w});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${c}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${l}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const zp={kernelName:Y.qc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:o,dy:c}=t,{alignCorners:l}=r,d=new Vp(c.shape,o.shape,l);return n.runWebGLProgram(d,[c],c.dtype)}};class Gp{constructor(e,t,n,r,o){this.variableNames=["A"],this.outputShape=[];const[c,l,d,h]=e;this.outputShape=[c,t,n,h];const f=[r&&t>1?l-1:l,r&&n>1?d-1:d],m=[r&&t>1?t-1:t,r&&n>1?n-1:n],x=r?"0.5":"0.0";let v;v=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${f[0]/m[0]},\n          ${f[1]/m[1]});\n      const vec2 inputShapeRC = vec2(${l}.0, ${d}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${v};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${x})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class Hp{constructor(e,t,n,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[c,l,d,h]=e;this.outputShape=[c,t,n,h];const f=[r&&t>1?l-1:l,r&&n>1?d-1:d],m=[r&&t>1?t-1:t,r&&n>1?n-1:n],x=r?"0.5":"0.0";let v;v=o?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${f[0]/m[0]},\n          ${f[1]/m[1]},\n          ${f[1]/m[1]});\n      const vec3 inputShapeRC = vec3(${l}.0, ${d}.0,\n                                     ${d}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${v};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${x})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${h-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const Xp={kernelName:Y.rc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:o}=t,{alignCorners:c,halfPixelCenters:l,size:d}=r,[h,f]=d,m=Object(v.b)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Hp(o.shape,h,f,c,l):new Gp(o.shape,h,f,c,l);return n.runWebGLProgram(m,[o],o.dtype)}};class qp{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,o]=t,[,c,l]=e,d=[n&&c>1?r-1:r,n&&l>1?o-1:o],h=[n&&c>1?c-1:c,n&&l>1?l-1:l],f=d[0]/h[0],m=d[1]/h[1],x=1/f,v=1/m,y=2*Math.ceil(x)+2,w=2*Math.ceil(v)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${f});\n        const float widthScale = float(${m});\n\n        const float invHeightScale = float(${x});\n        const float invWidthScale = float(${v});\n\n        const int winHeight = int(${y});\n        const int winWidth = int(${w});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${c}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${l}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${d[0]}) *\n                (float(dyR) / float(${h[0]}));\n\n            float sourceFracCol =\n                float(${d[1]}) *\n                  (float(dyC) / float(${h[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Kp={kernelName:Y.sc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:o,dy:c}=t,{alignCorners:l}=r,d=new qp(c.shape,o.shape,l);return n.runWebGLProgram(d,[c],c.dtype)}};class Yp{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,i)=>(i=>-1!==t.indexOf(i)&&1!==e[i]?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`)(i))).join(","),o=oi(n);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class Zp{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=Ws("rc",n),o=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,c=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,l=oi(n);function d(n){const r=e.map(((r,i)=>function(i,n){return-1!==t.indexOf(i)&&1!==e[i]?`${e[i]} - ${n[i]} - 1`:`${n[i]}`}(i,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${l} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return d(e)}(r.slice())};\n          if(${o}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",d(e)}(r.slice())};\n          }\n          if(${c}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",d(e)}(r.slice())};\n            if(${o}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",d(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const Qp={kernelName:Y.tc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{dims:c}=r,l=o.shape.length,d=Ne.parseAxisParam(c,o.shape);if(0===l)return vu({inputs:{x:o},backend:n});const h=Object(v.b)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Zp(o.shape,d):new Yp(o.shape,d);return n.runWebGLProgram(h,[o],o.dtype)}};class Jp{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let o="";o="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const ef={kernelName:Y.uc,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:image}=e,{radians:r,fillValue:o,center:c}=t,d=n,h=new Jp(image.shape,o),[f,m]=l.getImageCenter(c,image.shape[1],image.shape[2]),x=[[f,m,Math.sin(r),Math.cos(r)]];return d.runWebGLProgram(h,[image],image.dtype,x)}},tf=Ou({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),nf={kernelName:Y.vc,backendName:"webgl",kernelFunc:tf},rf=Ou({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Is}),of={kernelName:Y.wc,backendName:"webgl",kernelFunc:rf};class af{constructor(e,t,n,r,o,c,l=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=c;const d=oi(o.length),h=oi(c.length);let f="";1===n?f="i":2===n&&(f="i, j");const m=`getIndices(${f})`;let x="";1===r?x="i":2===r&&(x="i, coords[1]");const v=`getUpdates(${x})`,y=t>1?"strides[j]":"strides";this.userCode=`\n        ${d} strides = ${d}(${o});\n\n        void main() {\n          ${h} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${m});\n              flattenedIndex += index * ${y};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${v};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const sf={kernelName:Y.xc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:o,updates:c}=t,{shape:d}=r,{sliceRank:h,numUpdates:f,sliceSize:m,strides:x,outputSize:v}=l.calculateShapes(c,o,d),y=[v/m,m];if(0===v)return n.makeTensorInfo(d,o.dtype);const w=Mu({inputs:{x:o},backend:n,attrs:{shape:[f,h]}}),C=Mu({inputs:{x:c},backend:n,attrs:{shape:[f,m]}}),I=n.makeTensorInfo([],"float32",new Float32Array([0])),$=new af(f,h,w.shape.length,C.shape.length,x,y),S=n.runWebGLProgram($,[C,w,I],C.dtype),k=Mu({inputs:{x:S},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(C),n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(I),k}};class uf{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,c=2===Object(v.b)().getNumber("WEBGL_VERSION")?"while (left < right) {":o,l="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${c}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${l} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const cf={kernelName:Y.yc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:o,values:c}=t,{side:l}=r,d=new uf(o.shape[0],o.shape[1],c.shape[1],l),h=[[o.shape[1]]];return n.runWebGLProgram(d,[o,c],"int32",h)}};class lf{constructor(e,t,n){let r,o;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)o="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],l=[];for(let i=0;i<t.length;i++)l.push(`${n[i]}`),i<e&&c.push(`${n[i]}`);r=c.join(),o=l.join()}const c=oi(n);this.userCode=`\n      void main() {\n        ${c} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}const df={kernelName:Y.zc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:o,e:c}=t,l=new lf(r.shape.length,o.shape,o.shape.length);return n.runWebGLProgram(l,[r,o,c],Object(_e.b)(o.dtype,c.dtype))}},hf=Ou({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${l.SELU_SCALEALPHA};\n  float scale = ${l.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),pf={kernelName:Y.Ac,backendName:"webgl",kernelFunc:hf},ff=Ou({opSnippet:Ru+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Ss}),gf={kernelName:Y.Bc,backendName:"webgl",kernelFunc:ff},mf=Ou({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),bf={kernelName:Y.Cc,backendName:"webgl",kernelFunc:mf},xf=Ou({opSnippet:Ru+"\n  return sin(x);\n"}),vf={kernelName:Y.Dc,backendName:"webgl",kernelFunc:xf},yf=Ou({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),wf={kernelName:Y.Ec,backendName:"webgl",kernelFunc:yf},Cf=Ou({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),If={kernelName:Y.Hc,backendName:"webgl",kernelFunc:Cf},$f={kernelName:Y.Ic,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{blockShape:c,paddings:d}=r;Ne.assert(o.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const h=c.reduce(((a,b)=>a*b)),f=[[0,0]];f.push(...d);for(let i=1+c.length;i<o.shape.length;++i)f.push([0,0]);const m=[],x=Sp({inputs:{x:o},backend:n,attrs:{paddings:f,constantValue:0}}),v=l.getReshaped(x.shape,c,h,!1),y=l.getPermuted(v.length,c.length,!1),w=l.getReshapedPermuted(x.shape,c,h,!1),C=Mu({inputs:{x:x},backend:n,attrs:{shape:v}}),I=Ku({inputs:{x:C},backend:n,attrs:{perm:y}}),$=Mu({inputs:{x:I},backend:n,attrs:{shape:w}});return m.push(x),m.push(C),m.push(I),m.forEach((e=>n.disposeIntermediateTensorInfo(e))),$}};const Sf={kernelName:Y.Jc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:o,denseShape:c,defaultValue:l}=t;if(1!==c.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${c.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==o.shape.length)throw new Error(`Values must be a vector, saw:\n         ${o.shape}`);if(0!==l.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${l.shape}`);const d=n.readSync(r.dataId),h=n.readSync(o.dataId),f=n.readSync(c.dataId),m=n.readSync(l.dataId)[0],[x,v,y,w,C]=Ts(d,r.shape,r.dtype,h,o.dtype,f,m);return[n.makeTensorInfo(v,r.dtype,x),n.makeTensorInfo([v[0]],o.dtype,y),n.makeTensorInfo([w.length],"bool",new Uint8Array(w.map((e=>Number(e))))),n.makeTensorInfo([C.length],r.dtype,new Int32Array(C))]}};const kf={kernelName:Y.Kc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:o,newShape:c}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==o.shape.length)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(1!==c.shape.length)throw new Error(`Target shape should be a vector but received shape ${c.shape}`);const l=Array.from(n.readSync(o.dataId)),d=n.readSync(r.dataId),h=Array.from(n.readSync(c.dataId)),[f,m,x]=Rs(d,r.shape,r.dtype,l,h);return[n.makeTensorInfo(m,r.dtype,f),n.makeTensorInfo([x.length],c.dtype,new Int32Array(x))]}};const Ef={kernelName:Y.Lc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:data,indices:r,segmentIds:o}=t;if(data.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const c=n.readSync(data.dataId),l=n.readSync(r.dataId),d=n.readSync(o.dataId),[h,f]=Os(c,data.shape,data.dtype,l,d,!0);return n.makeTensorInfo(f,data.dtype,h)}};const Tf={kernelName:Y.Mc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:data,indices:r,segmentIds:o}=t;if(data.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const c=n.readSync(data.dataId),l=n.readSync(r.dataId),d=n.readSync(o.dataId),[h,f]=Os(c,data.shape,data.dtype,l,d);return n.makeTensorInfo(f,data.dtype,h)}};const Rf={kernelName:Y.Nc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:o,sparseValues:c,defaultValue:d}=t,{outputShape:h}=r,{sliceRank:f,numUpdates:m,sliceSize:x,strides:v,outputSize:y}=l.calculateShapes(c,o,h);if("string"===c.dtype){const e=n.bufferSync(o),t=n.bufferSync(c),r=Ne.decodeString(n.readSync(d.dataId)[0]),l=$s(e,t,h,y,x,m,f,v,r,false);return n.makeTensorInfo(h,l.dtype,l.values)}const w=new af(m,f,o.shape.length,c.shape.length,v,[y,1],false),C=n.runWebGLProgram(w,[c,o,d],c.dtype),I=Mu({inputs:{x:C},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(C),I}};const Of={kernelName:Y.Oc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{numOrSizeSplits:c,axis:d}=r,h=Ne.parseAxisParam(d,o.shape)[0],f=l.prepareSplitSize(o,c,h),m=o.shape.length,x=new Array(m).fill(0),v=o.shape.slice();return f.map((s=>{const e=[...v];e[h]=s;const t=Hc({inputs:{x:o},backend:n,attrs:{begin:x,size:e}});return x[h]+=s,t}))}},Af="return sqrt(x);",Nf=Ou({opSnippet:Af,packedOpSnippet:Af,cpuKernelImpl:As}),_f={kernelName:Y.Pc,backendName:"webgl",kernelFunc:Nf},Ff=Ou({opSnippet:"return x * x;"}),Df={kernelName:Y.Qc,backendName:"webgl",kernelFunc:Ff},Pf="return (a - b) * (a - b);",Lf=Au({opSnippet:Pf,packedOpSnippet:Pf}),Bf={kernelName:Y.Rc,backendName:"webgl",kernelFunc:Lf};const Mf={kernelName:Y.Sc,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,o=Ys+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,c=new Ks(r.shape,o);return n.runWebGLProgram(c,[r],r.dtype)}};class jf{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,o=oi(n.length),c=oi(n.length);let l="";if(1===r)l="coords * strides + begin";else{let e=0;l=n.map(((t,i)=>(e++,1===n.length?`coords * strides[${i}] + begin[${i}]`:`coords[${e-1}] * strides[${i}] + begin[${i}]`))).join(",")}this.userCode=`\n      ${o} begin = ${o}(${e});\n      ${o} strides = ${o}(${t});\n\n      void main() {\n        ${c} coords = getOutputCoords();\n        setOutput(getX(${l}));\n      }\n    `}}const Uf={kernelName:Y.Tc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:c}=t,{begin:l,end:d,strides:h,beginMask:f,endMask:m,ellipsisMask:x,newAxisMask:v,shrinkAxisMask:y}=r,{finalShapeSparse:w,finalShape:C,isIdentity:I,sliceDim0:$,isSimpleSlice:S,begin:k,end:E,strides:T}=o.sliceInfo(c.shape,l,d,h,f,m,x,v,y);let R;if(I)R=Mu({inputs:{x:c},backend:n,attrs:{shape:C}});else if($||S){Ne.assert(c.shape.length>=1,(()=>`Input must have rank at least 1, got: ${c.shape.length}`));const e=o.computeOutShape(k,E,T),t=Hc({inputs:{x:c},backend:n,attrs:{begin:k,size:e}});R=Mu({inputs:{x:t},backend:n,attrs:{shape:C}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([c])){const e=n.readSync(c.dataId),t=K(c.shape,c.dtype,e),r=Ns(w,t,T,k);R=n.makeTensorInfo(C,c.dtype,r.values)}else{const e=new jf(k,T,w);R=n.runWebGLProgram(e,[c],c.dtype)}}const O=Mu({inputs:{x:R},backend:n,attrs:{shape:C}});return n.disposeIntermediateTensorInfo(R),O}};const Wf={kernelName:Y.Uc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:o,nGramWidths:c,leftPad:l,rightPad:d,padWidth:h,preserveShortSequences:f}=r,{data:data,dataSplits:m}=t,x=n.readSync(data.dataId),v=n.readSync(m.dataId),[y,w]=_s(x,v,o,c,l,d,h,f);return[n.makeTensorInfo([y.length],"string",y),n.makeTensorInfo(m.shape,"int32",w)]}};const Vf={kernelName:Y.Vc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:o}=r,{input:input,delimiter:c}=t;if("string"!==input.dtype)throw new Error("Input must be of datatype string");if(1!==input.shape.length)throw new Error(`Input must be a vector, got shape: ${input.shape}`);if(0!==c.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${c.shape}`);const l=n.readSync(input.dataId),d=n.readSync(c.dataId)[0],[h,f,m]=Fs(l,d,o),x=f.length;return[n.makeTensorInfo([x,2],"int32",h),n.makeTensorInfo([x],"string",f),n.makeTensorInfo([2],"int32",new Int32Array(m))]}};const zf={kernelName:Y.Wc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:o}=r,{input:input}=t;if("string"!==input.dtype)throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");const c=n.readSync(input.dataId),output=Ds(c,o);return n.makeTensorInfo(input.shape,"int32",output)}},Gf=Ou({opSnippet:"return tan(x);"}),Hf={kernelName:Y.Zc,backendName:"webgl",kernelFunc:Gf},Xf=Ou({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),qf={kernelName:Y.ad,backendName:"webgl",kernelFunc:Xf};class Kf{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[i]*t[i];this.outputShape=n,this.rank=n.length;const r=oi(this.rank),o=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let i=0;i<e.length;i++)r.push(`imod(${n[i]}, ${e[i]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function Yf(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{reps:c}=r;if("string"===o.dtype||o.shape.length>5){const data=n.readSync(o.dataId),e="string"===o.dtype?data.map((e=>Ne.decodeString(e))):data,t=K(o.shape,o.dtype,e),r=Ls(t,c);return n.makeTensorInfo(r.shape,r.dtype,r.values)}const l=new Kf(o.shape,c);return n.runWebGLProgram(l,[o],o.dtype)}const Zf={kernelName:Y.bd,backendName:"webgl",kernelFunc:Yf};class Qf{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Jf{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function eg(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function tg(e){let t=1;for(;t<e;)t*=2;return t}const ng={kernelName:Y.cd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{k:c,sorted:l}=r,d=Object(v.b)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),h=Object(v.b)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),f=o.shape,m=f[f.length-1];if(n.shouldExecuteOnCPU([o])||m<d||c>h){const e=n.readSync(o.dataId),[t,r]=Bs(e,f,o.dtype,c,l);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===c)return f[f.length-1]=0,[n.makeTensorInfo(f,o.dtype,[]),n.makeTensorInfo(f,"int32",[])];if(1===m)return[o,Fd({attrs:{shape:f,dtype:"int32",value:0},backend:n})];const x=n.texData.get(o.dataId),y=null!==x&&x.isPacked,w=y?n.unpackTensor(o):o,C=Ne.sizeFromShape(f)/m,I=Mu({inputs:{x:w},attrs:{shape:[C,m]},backend:n});y&&eg(n,w);const $=tg(c),S=tg(m);let k=null;const E=()=>null===k?[I,I]:[I,k],T=(e,t,r)=>{const o=E(),c=new Qf(r),l=[[m],[null===k?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],d=k;k=n.runWebGLProgram(c,o,"int32",l),eg(n,d)};for(let e=1;e<$;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)T(t,n,[C,S])}for(let e=S;e>$;e/=2){const t=E(),r=new Jf([C,e/2]),o=[[m],[null===k?1:0],[$]],c=k;k=n.runWebGLProgram(r,t,"int32",o),eg(n,c);const l=$/2,d=2*l;for(let e=l;e>=1;e/=2)T(d,e,k.shape)}let R=k;k=Hc({inputs:{x:k},backend:n,attrs:{begin:0,size:[C,c]}}),eg(n,R);let O=Jd({inputs:{x:I,indices:k},backend:n,attrs:{axis:1,batchDims:1}});eg(n,I);const A=f.slice(0,-1);A.push(c),R=k,k=Mu({inputs:{x:k},attrs:{shape:A},backend:n}),eg(n,R);const N=O;return O=Mu({inputs:{x:O},attrs:{shape:A},backend:n}),eg(n,N),[O,k]}};class rg{constructor(e,t,n,r,o,c){this.variableNames=["Image","Transforms"],this.outputShape=c;const l="nearest"===n?1:2;let d;switch(r){case"constant":default:d=1;break;case"reflect":d=2;break;case"wrap":d=3;break;case"nearest":d=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${d} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${d} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${d} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${l} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const og={kernelName:Y.dd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:image,transforms:o}=t,{interpolation:c,fillMode:l,fillValue:d,outputShape:h}=r,[f,m,x,v]=image.shape,[y,w]=null!=h?h:[m,x],C=new rg(m,x,c,l,d,[f,y,w,v]);return n.runWebGLProgram(C,[image,o],"float32")}};const ig={kernelName:Y.fd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:o}=n,{x:c}=t;Mo(c,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const l=r.readSync(c.dataId),{outputValues:d,outputShape:h,indices:f}=js(l,o,c.shape,c.dtype);return[r.makeTensorInfo(h,c.dtype,d),r.makeTensorInfo([f.length],"int32",f)]}};const ag={kernelName:Y.gd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:o}=t;let{axis:c}=r;c<0&&(c+=o.shape.length);const l=o,d=l.shape.length,h=o.shape[c],f=new Array(d-1);let m=0;for(let i=0;i<d;i++)i!==c&&(f[m++]=l.shape[i]);const x=[],v=new Array(d).fill(0),y=l.shape.slice();y[c]=1;const w=new Array(h);for(let i=0;i<w.length;i++){v[c]=i;const e=Hc({inputs:{x:l},backend:n,attrs:{begin:v,size:y}}),t=Mu({inputs:{x:e},backend:n,attrs:{shape:f}});w[i]=t,x.push(e)}return x.forEach((e=>n.disposeIntermediateTensorInfo(e))),w}};class sg{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,o=e.inSize,c=e.numSegments,l=c*Math.ceil(o/n);this.outputShape=[r,l];const d=4*Math.floor(n/4),h=n%4,f="\n        sumValue += dot(values, segFilter);\n    ";let m="";o%n>0&&(m=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let x="";o%n>0&&(x=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${m}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${x}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${c})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${c})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${d}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${f}\n        }\n\n        int inIdx = inOffset + ${d};\n        if (${1===h}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${f}\n        } else if (${2===h}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${f}\n        } else if (${3===h}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${f}\n        }\n        setOutput(sumValue);\n      }\n    `}}const ug={kernelName:Y.hd,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:o,segmentIds:c}=t,{numSegments:d}=r,h=o.shape.length,f=[];let m=0;const x=l.getAxesPermutation([m],h);let v=o;null!=x&&(v=Ku({inputs:{x:o},backend:n,attrs:{perm:x}}),f.push(v),m=l.getInnerMostAxes(1,h)[0]);const y=l.segment_util.computeOutShape(v.shape,m,d),w=Ne.sizeFromShape([v.shape[m]]),C=Mu({inputs:{x:v},backend:n,attrs:{shape:[-1,w]}});f.push(C);const I=Object(_e.a)(o.dtype),$=(e,t,r,o,c)=>{const d=e.shape[0],h=e.shape[1],m=l.segment_util.segOpComputeOptimalWindowSize(h,c),x=new sg({windowSize:m,inSize:h,batchSize:d,numSegments:c},t),output=n.compileAndRun(x,[e,r],o);if(f.push(output),output.shape[1]===c)return output;const v=Np({backend:n,attrs:{start:0,stop:c,step:1,dtype:"float32"}}),y=Yf({inputs:{x:v},backend:n,attrs:{reps:[h/m]}});f.push(v),f.push(y);return $(output,t,y,o,c)},S=Mu({inputs:{x:$(C,"unsortedSegmentSum",c,I,d)},backend:n,attrs:{shape:y}});let k=S;if(null!=x){f.push(S);const e=l.getUndoAxesPermutation(x);k=Ku({inputs:{x:k},backend:n,attrs:{perm:e}})}return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),k}},cg=[Ju,tc,rc,ic,uc,dc,hc,pc,vc,yc,Cc,$c,kc,Tc,Oc,_c,Fc,Lc,Bc,Mc,Wc,qc,Kc,Yc,nl,al,ll,Cu,fl,Cl,Ol,Dl,Pl,Ll,Bl,Ml,Ul,Vl,Gl,Zl,Ql,Jl,nd,id,ud,cd,hd,fd,gd,bd,xd,yd,Cd,$d,kd,Rd,Nd,Dd,Ld,jd,Wd,Gd,qd,Kd,Zd,eh,rh,ih,yu,ah,vl,uh,lh,hh,Su,fh,mh,bh,vh,wh,Ih,Sh,Eh,Oh,Nh,Fh,Ph,Lh,Bh,Uh,Wh,Vh,zh,Gh,Xh,Yh,Qh,up,Bu,lp,hp,fp,mp,Qc,xp,wp,Cp,kp,Tp,Tu,Rp,Op,Ap,_p,el,tp,Dp,Lp,Mp,ju,Wp,zp,Xp,Kp,Qp,ef,nf,of,sf,cf,df,pf,gf,bf,vf,wf,Xc,sp,If,$f,Sf,kf,Ef,Tf,Rf,Of,_f,Df,Bf,Mf,Uf,Wf,Vf,zf,ip,qu,Hf,qf,Zf,ng,og,Yu,ig,ag,ug,yp];for(const e of cg)Object(mn.d)(e);n(677);var lg,dg,a,hg=(e,t,n)=>new Promise(((i,s)=>{var r=u=>{try{o(n.next(u))}catch(e){s(e)}},a=u=>{try{o(n.throw(u))}catch(e){s(e)}},o=u=>u.done?i(u.value):Promise.resolve(u.value).then(r,a);o((n=n.apply(e,t)).next())})),pg=(lg=(e,t)=>{t.exports={version:"1.11.18",license:"MIT",main:"dist/index.cjs.js",typings:"dist/index.d.ts",files:["dist","src/tflite","src/models"],scripts:{start:'concurrently "yarn dev" "yarn types"',dev:"node ../../scripts/dev","build:only":"node ../../scripts/build",build:"yarn build:only && yarn types:build",types:"tsc -w","types:build":"tsc -p tsconfig.json",test:"jest --maxWorkers=1 --passWithNoTests",lint:"eslint -c ../../.eslintrc .","lint:fix":"yarn lint --fix",prepare:"yarn build",size:"size-limit",analyze:"size-limit --why",format:"prettier --write src/**/*.ts"},peerDependencies:{"@100mslive/hms-video":"^0.7.2"},name:"@100mslive/hms-virtual-background",author:"ashish17",module:"dist/index.js",devDependencies:{"@100mslive/hms-video":"0.9.18"},dependencies:{"@mediapipe/selfie_segmentation":"^0.1.1632777926","@tensorflow-models/body-segmentation":"^1.0.1","@tensorflow/tfjs-backend-webgl":"^3.3.0","@tensorflow/tfjs-converter":"^3.19.0","@tensorflow/tfjs-core":"^3.19.0","@webassemblyjs/helper-wasm-bytecode":"1.11.1","@webassemblyjs/wasm-gen":"1.11.1","gifuct-js":"^2.1.2","wasm-check":"^2.0.2"},eslintIgnore:["tflite.js","tflite-simd.js","tflite.wasm","tflite-simd.wasm","defineTFLite.ts","importing.test.ts"],gitHead:"b78d4abbfb1bb119dcdd29613484f22fbae5b149"}},()=>(dg||lg((dg={exports:{}}).exports,dg),dg.exports)),fg=`https://unpkg.com/${pg().name}/src`,gg="VBProcessor",mg=e=>new Promise((function(t,n){let i=document.createElement("script");i.src=e,i.onload=t,i.onerror=n,document.head.appendChild(i)})),bg="VBProcessor",xg=pg(),vg=class{constructor(e,t=!1){this.backgroundType="none",this.background=e,this.enableSharpening=t,this.backgroundImage=null,this.backgroundVideo=null,this.personMaskWidth=256,this.personMaskHeight=144,this.isVirtualBackground=!1,this.blurValue="10px",this.loadModelCalled=!1,this.tfLite=null,this.modelName="landscape-segmentation",this.outputCtx=null,this.input=null,this.output=null,this.timerID=0,this.imageAspectRatio=1,this.personMaskPixelCount=this.personMaskWidth*this.personMaskHeight,this.personMask=new ImageData(this.personMaskWidth,this.personMaskHeight),this.personMaskCanvas=document.createElement("canvas"),this.personMaskCanvas.width=this.personMaskWidth,this.personMaskCanvas.height=this.personMaskHeight,this.personMaskCtx=this.personMaskCanvas.getContext("2d"),this.filters={},this.gifFrames=null,this.gifFramesIndex=0,this.gifFrameImageData=null,this.tempGifCanvas=document.createElement("canvas"),this.tempGifContext=this.tempGifCanvas.getContext("2d"),this.giflocalCount=0,this.enableSharpening=t,this.log(bg,"Virtual Background plugin created"),this.setBackground(this.background)}init(){return hg(this,null,(function*(){this.loadModelCalled?yield this.tfLitePromise:(this.log(bg,"PREVIOUS LOADED MODEL IS ",this.tfLite),this.loadModelCalled=!0,this.tfLitePromise=hg(void 0,null,(function*(){let e=`${fg}/models/selfie_segmentation_landscape.tflite`,[t,n]=yield Promise.all([hg(void 0,null,(function*(){let e,t=`${fg}/tflite/tflite-simd.js`;yield mg(t);try{e=yield createTFLiteSIMDModule()}catch(n){console.warn("SIMD not supported. You may experience poor virtual background effect."),t=`${fg}/tflite/tflite.js`,yield mg(t),e=yield createTFLiteModule()}return e})),fetch(e)]),i=yield n.arrayBuffer(),s=t._getModelBufferMemoryOffset();return t.HEAPU8.set(new Uint8Array(i),s),t._loadModel(i.byteLength),console.debug(gg,"Input memory offset:",t._getInputMemoryOffset()),console.debug(gg,"Input height:",t._getInputHeight()),console.debug(gg,"Input width:",t._getInputWidth()),console.debug(gg,"Input channels:",t._getInputChannelCount()),t})),this.tfLite=yield this.tfLitePromise),this.enableSharpening&&this.initSharpenFilter()}))}isSupported(){return-1!==navigator.userAgent.indexOf("Chrome")||-1!==navigator.userAgent.indexOf("Firefox")||-1!==navigator.userAgent.indexOf("Edg")||-1!==navigator.userAgent.indexOf("Edge")}checkSupport(){let e={};return["Chrome","Firefox","Edg","Edge"].some((e=>-1!==navigator.userAgent.indexOf(e)))?e.isSupported=!0:(e.isSupported=!1,e.errType=m.g.PLATFORM_NOT_SUPPORTED,e.errMsg="browser not supported for plugin, see docs"),e}getName(){return xg.name}getPluginType(){return m.n.TRANSFORM}setBackground(e){return hg(this,null,(function*(){if(""===e)throw new Error("Invalid background supplied, see the docs to check supported background type");if("none"===e)this.log(bg,"setting background to :",e),this.background="none",this.backgroundType="none",this.isVirtualBackground=!1;else if("blur"===e)this.log(bg,"setting background to :",e),this.background="blur",this.backgroundType="blur",this.isVirtualBackground=!1;else if(e instanceof HTMLImageElement){this.log("setting background to image",e);let t=yield this.setImage(e);if(!t||!t.complete||!t.naturalHeight)throw new Error("Invalid image. Provide a valid and successfully loaded HTMLImageElement");this.isVirtualBackground=!0,this.backgroundImage=t,this.backgroundType="image"}else if(e instanceof HTMLVideoElement)this.log("setting background to video",e),this.backgroundVideo=e,this.backgroundVideo.crossOrigin="anonymous",this.backgroundVideo.muted=!0,this.backgroundVideo.loop=!0,this.backgroundVideo.oncanplaythrough=()=>hg(this,null,(function*(){null!=this.backgroundVideo&&(yield this.backgroundVideo.play(),this.isVirtualBackground=!0,this.backgroundType="video")}));else{if(console.log("setting gif to background"),this.gifFrames=yield this.setGiF(e),!(null!=this.gifFrames&&this.gifFrames.length>0))throw new Error("Invalid background supplied, see the docs to check supported background type");this.backgroundType="gif",this.isVirtualBackground=!0}}))}stop(){var e,t;this.isVirtualBackground&&(null==(e=this.backgroundImage)||e.removeAttribute("src"),null==(t=this.backgroundVideo)||t.removeAttribute("src"),"video"===this.backgroundType&&(this.backgroundVideo.loop=!1,this.backgroundVideo=null)),this.outputCtx&&(this.outputCtx.fillStyle="rgb(0, 0, 0)",this.outputCtx.fillRect(0,0,this.output.width,this.output.height)),this.gifFrameImageData=null,this.gifFrames=null,this.giflocalCount=0,this.gifFramesIndex=0}processVideoFrame(e,t,i){if(!e||!t)throw new Error("Plugin invalid input/output");this.input=e,this.output=t;let s=t.getContext("2d");if(s.canvas.width!==e.width&&(s.canvas.width=e.width),s.canvas.height!==e.height&&(s.canvas.height=e.height),"video"===this.backgroundType&&(this.backgroundVideo.width=e.width,this.backgroundVideo.height=e.height),this.outputCtx=s,this.imageAspectRatio=e.width/e.height,this.imageAspectRatio<=0)throw new Error("Invalid input width/height");"none"!==this.background||this.isVirtualBackground?(()=>{hg(this,null,(function*(){yield this.runSegmentation(i)}))})():(this.outputCtx.globalCompositeOperation="copy",this.outputCtx.filter="none",this.outputCtx.drawImage(e,0,0,e.width,e.height))}setImage(e){return hg(this,null,(function*(){return e.crossOrigin="anonymous",new Promise(((t,i)=>{e.onload=()=>t(e),e.onerror=i}))}))}setGiF(e){return fetch(e).then((e=>e.arrayBuffer())).then((e=>Object(f.parseGIF)(e))).then((e=>Object(f.decompressFrames)(e,!0)))}log(e,...t){console.info(e,...t)}resizeInputData(){this.personMaskCtx.drawImage(this.input,0,0,this.input.width,this.input.height,0,0,this.personMaskWidth,this.personMaskHeight);let e=this.personMaskCtx.getImageData(0,0,this.personMaskWidth,this.personMaskHeight),t=this.tfLite._getInputMemoryOffset()/4;for(let i=0;i<this.personMaskPixelCount;i++)this.tfLite.HEAPF32[t+3*i]=e.data[4*i]/255,this.tfLite.HEAPF32[t+3*i+1]=e.data[4*i+1]/255,this.tfLite.HEAPF32[t+3*i+2]=e.data[4*i+2]/255}infer(e){e||this.tfLite._runInference();let t=this.tfLite._getOutputMemoryOffset()/4;for(let i=0;i<this.personMaskPixelCount;i++)if("meet"===this.modelName){let s=this.tfLite.HEAPF32[t+2*i],e=this.tfLite.HEAPF32[t+2*i+1],a=Math.max(s,e),n=Math.exp(s-a),u=Math.exp(e-a);this.personMask.data[4*i+3]=255*u/(n+u)}else if("landscape-segmentation"===this.modelName){let s=this.tfLite.HEAPF32[t+i];this.personMask.data[4*i+3]=255*s}this.personMaskCtx.putImageData(this.personMask,0,0)}postProcessing(){this.outputCtx.globalCompositeOperation="copy",this.outputCtx.filter="none",this.isVirtualBackground?this.outputCtx.filter="blur(4px)":this.outputCtx.filter="blur(8px)",this.drawPersonMask(),this.outputCtx.globalCompositeOperation="source-in",this.outputCtx.filter="none",this.outputCtx.drawImage(this.input,0,0),this.enableSharpening&&this.output.width>214&&this.output.height>120&&this.output.width<855&&this.output.height<720&&this.sharpenFilter(),this.drawSegmentedBackground()}sharpenFilter(){let e=this.outputCtx.getImageData(0,0,this.output.width,this.output.height),t=this.filters.convolute(e);this.outputCtx.putImageData(t,0,0)}drawPersonMask(){this.outputCtx.drawImage(this.personMaskCanvas,0,0,this.personMaskWidth,this.personMaskHeight,0,0,this.output.width,this.output.height)}drawSegmentedBackground(){this.outputCtx.globalCompositeOperation="destination-over",this.outputCtx.imageSmoothingEnabled=!0,this.outputCtx.imageSmoothingQuality="high",this.isVirtualBackground?"video"===this.backgroundType&&null!=this.backgroundVideo&&this.backgroundVideo.readyState>=4?this.fitVideoToBackground():"image"===this.backgroundType?this.fitImageToBackground():"gif"===this.backgroundType&&(this.giflocalCount>this.gifFrames[this.gifFramesIndex].delay/33?(this.gifFramesIndex++,this.gifFramesIndex>=this.gifFrames.length&&(this.gifFramesIndex=0),this.giflocalCount=0):this.giflocalCount++,this.fitGifToBackground()):this.addBlurToBackground()}runSegmentation(e){return hg(this,null,(function*(){this.tfLite&&(this.resizeInputData(),yield this.infer(e),this.postProcessing())}))}fitVideoToBackground(){this.fitData(this.backgroundVideo,this.backgroundVideo.videoWidth,this.backgroundVideo.videoHeight)}fitImageToBackground(){this.fitData(this.backgroundImage,this.backgroundImage.width,this.backgroundImage.height)}fitGifToBackground(){if(null==this.gifFrameImageData){let e=this.gifFrames[this.gifFramesIndex].dims;this.tempGifCanvas.width=e.width,this.tempGifCanvas.height=e.height,this.gifFrameImageData=this.tempGifContext.createImageData(e.width,e.height)}this.gifFrameImageData.data.set(this.gifFrames[this.gifFramesIndex].patch),this.tempGifContext.putImageData(this.gifFrameImageData,0,0),this.fitData(this.tempGifCanvas,this.gifFrameImageData.width,this.gifFrameImageData.height)}fitData(e,t,i){let s,n,a,r;t/i<this.imageAspectRatio?(s=t,n=t/this.imageAspectRatio,a=0,r=(i-n)/2):(n=i,s=i*this.imageAspectRatio,r=0,a=(t-s)/2),this.outputCtx.drawImage(e,a,r,s,n,0,0,this.output.width,this.output.height)}addBlurToBackground(){return hg(this,null,(function*(){let e="15px";this.input.width<=160?e="5px":this.input.width<=320?e="10px":this.input.width<=640?e="15px":this.input.width<=960?e="20px":this.input.width<=1280?e="25px":this.input.width<=1920&&(e="30px"),this.outputCtx.filter=`blur(${e})`,this.outputCtx.drawImage(this.input,0,0,this.output.width,this.output.height)}))}initSharpenFilter(){this.filters.tmpCanvas=document.createElement("canvas"),this.filters.tmpCtx=this.filters.tmpCanvas.getContext("2d"),this.filters.createImageData=(e,t)=>this.filters.tmpCtx.createImageData(e,t),this.filters.convolute=(e,t=[0,-1,0,-1,5,-1,0,-1,0],i)=>{let s=Math.round(Math.sqrt(t.length)),n=Math.floor(s/2),a=e.data,r=e.width,u=e.height,g=r,o=u,c=this.filters.createImageData(g,o),l=c.data,d=i?1:0;for(let e=0;e<o;e+=1)for(let c=0;c<g;c+=1){let p=4*(e*g+c);if(0!==a[p+3]&&c<g&&e<o){let o=e,h=c,f=0,m=0,x=0,v=0;for(let e=0;e<s;e++)for(let c=0;c<s;c++){let l=o+e-n,d=h+c-n;if(l>=0&&l<u&&d>=0&&d<r){let n=4*(l*r+d),b=t[e*s+c];f+=a[n]*b,m+=a[n+1]*b,x+=a[n+2]*b,v+=a[n+3]*b}}l[p]=f,l[p+1]=m,l[p+2]=x,l[p+3]=v+d*(255-v)}}return c}}},yg=((a=yg||{}).BLUR="blur",a.NONE="none",a.GIF="gif",a.IMAGE="image",a.VIDEO="video",a.CANVAS="canvas",a)},460:function(e,t,n){"use strict";n.d(t,"b",(function(){return o})),n.d(t,"a",(function(){return c}));var r=n(409);function o(...e){Object(r.b)().getBool("IS_TEST")||Object(r.b)().getBool("PROD")||console.warn(...e)}function c(...e){Object(r.b)().getBool("IS_TEST")||Object(r.b)().getBool("PROD")||console.log(...e)}},461:function(e,t,n){"use strict";n.d(t,"a",(function(){return r})),n.d(t,"b",(function(){return o}));class r{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class o{refCount(e){return c("refCount")}incRef(e){return c("incRef")}timerAvailable(){return!0}time(e){return c("time")}read(e){return c("read")}readSync(e){return c("readSync")}readToGPU(e,t){return c("readToGPU")}numDataIds(){return c("numDataIds")}disposeData(e,t){return c("disposeData")}write(e,t,n){return c("write")}move(e,t,n,r,o){return c("move")}memory(){return c("memory")}floatPrecision(){return c("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return c("dispose")}}function c(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},462:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var r=n(401),o=n(463);function c(e,t,n){const c=Object(r.c)(e,n);return Object(o.a)(e,t,c,n)}},463:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var r=n(402),o=n(453),c=n(404);function l(e,t,n,l){if(null==l&&(l=Object(o.r)(e)),"complex64"===l)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Object(o.A)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Object(o.c)(t);const e=Object(o.O)(t),r=Object(o.O)(n);Object(o.b)(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let i=0;i<n.length;++i){const e=n[i],r=i!==n.length-1||e!==Object(o.O)(t.slice(i));Object(o.b)(n[i]===t[i]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return Object(o.A)(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==l?Object(c.toTypedArray)(e,l):Object(o.m)(e,[],!0),r.a.makeTensor(e,t,l)}},491:function(e,t,n){"use strict";(function(e,r){let o;function c(){if(null==o){let t;if("undefined"!=typeof window)t=window;else if(void 0!==e)t=e;else if(void 0!==r)t=r;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}o=t}return o}function l(e,t){const n=function(){const e=c();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}n.d(t,"b",(function(){return c})),n.d(t,"a",(function(){return l}))}).call(this,n(27),n(263))},492:function(e,t,n){"use strict";n.d(t,"b",(function(){return d})),n.d(t,"a",(function(){return h})),n.d(t,"c",(function(){return f})),n.d(t,"d",(function(){return m}));n(409);var r=n(491),o=n(460);const c=Object(r.a)("kernelRegistry",(()=>new Map)),l=Object(r.a)("gradRegistry",(()=>new Map));function d(e,t){const n=x(e,t);return c.get(n)}function h(e){return l.get(e)}function f(e){const t=c.entries(),n=[];for(;;){const{done:r,value:o}=t.next();if(r)break;const[c,l]=o,[d]=c.split("_");d===e&&n.push(l)}return n}function m(e){const{kernelName:t,backendName:n}=e,r=x(t,n);c.has(r)&&o.b(`The kernel '${t}' for backend '${n}' is already registered`),c.set(r,e)}function x(e,t){return`${t}_${e}`}},493:function(e,t,n){"use strict";let r;function o(e){r=e}function c(nav){if(void 0!==r)return r;if(nav||"undefined"!=typeof navigator&&null!=navigator){if(nav||(nav=navigator),"ReactNative"===nav.product)return!0;const a=nav.userAgent||nav.vendor||("undefined"!=typeof window?window.opera:"");if(!a){const e=nav;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))}return!1}function l(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}n.r(t),n.d(t,"mockIsMobile",(function(){return o})),n.d(t,"isMobile",(function(){return c})),n.d(t,"isBrowser",(function(){return l}))},505:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.decompressFrames=t.decompressFrame=t.parseGIF=void 0;var r,o=(r=n(668))&&r.__esModule?r:{default:r},c=n(506),l=n(507),d=n(669),h=n(670);t.parseGIF=function(e){var t=new Uint8Array(e);return(0,c.parse)((0,l.buildStream)(t),o.default)};var f=function(e,t,n){if(e.image){var image=e.image,r=image.descriptor.width*image.descriptor.height,o=(0,h.lzw)(image.data.minCodeSize,image.data.blocks,r);image.descriptor.lct.interlaced&&(o=(0,d.deinterlace)(o,image.descriptor.width));var c={pixels:o,dims:{top:e.image.descriptor.top,left:e.image.descriptor.left,width:e.image.descriptor.width,height:e.image.descriptor.height}};return image.descriptor.lct&&image.descriptor.lct.exists?c.colorTable=image.lct:c.colorTable=t,e.gce&&(c.delay=10*(e.gce.delay||10),c.disposalType=e.gce.extras.disposal,e.gce.extras.transparentColorGiven&&(c.transparentIndex=e.gce.transparentColorIndex)),n&&(c.patch=function(image){for(var e=image.pixels.length,t=new Uint8ClampedArray(4*e),i=0;i<e;i++){var n=4*i,r=image.pixels[i],o=image.colorTable[r]||[0,0,0];t[n]=o[0],t[n+1]=o[1],t[n+2]=o[2],t[n+3]=r!==image.transparentIndex?255:0}return t}(c)),c}console.warn("gif frame does not have associated image.")};t.decompressFrame=f;t.decompressFrames=function(e,t){return e.frames.filter((function(e){return e.image})).map((function(n){return f(n,e.gct,t)}))}},506:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.loop=t.conditional=t.parse=void 0;t.parse=function e(t,n){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:r;if(Array.isArray(n))n.forEach((function(n){return e(t,n,r,o)}));else if("function"==typeof n)n(t,r,o,e);else{var c=Object.keys(n)[0];Array.isArray(n[c])?(o[c]={},e(t,n[c],r,o[c])):o[c]=n[c](t,r,o,e)}return r};t.conditional=function(e,t){return function(n,r,o,c){t(n,r,o)&&c(n,e,r,o)}};t.loop=function(e,t){return function(n,r,o,c){for(var l=[],d=n.pos;t(n,r,o);){var h={};if(c(n,e,r,h),n.pos===d)break;d=n.pos,l.push(h)}return l}}},507:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.readBits=t.readArray=t.readUnsigned=t.readString=t.peekBytes=t.readBytes=t.peekByte=t.readByte=t.buildStream=void 0;t.buildStream=function(e){return{data:e,pos:0}};var r=function(){return function(e){return e.data[e.pos++]}};t.readByte=r;t.peekByte=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return function(t){return t.data[t.pos+e]}};var o=function(e){return function(t){return t.data.subarray(t.pos,t.pos+=e)}};t.readBytes=o;t.peekBytes=function(e){return function(t){return t.data.subarray(t.pos,t.pos+e)}};t.readString=function(e){return function(t){return Array.from(o(e)(t)).map((function(e){return String.fromCharCode(e)})).join("")}};t.readUnsigned=function(e){return function(t){var n=o(2)(t);return e?(n[1]<<8)+n[0]:(n[0]<<8)+n[1]}};t.readArray=function(e,t){return function(n,r,c){for(var l="function"==typeof t?t(n,r,c):t,d=o(e),h=new Array(l),i=0;i<l;i++)h[i]=d(n);return h}};t.readBits=function(e){return function(t){for(var n=function(e){return e.data[e.pos++]}(t),r=new Array(8),i=0;i<8;i++)r[7-i]=!!(n&1<<i);return Object.keys(e).reduce((function(t,n){var o=e[n];return o.length?t[n]=function(e,t,n){for(var r=0,i=0;i<n;i++)r+=e[t+i]&&Math.pow(2,n-i-1);return r}(r,o.index,o.length):t[n]=r[o.index],t}),{})}}},508:function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));const r={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},509:function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return o}));const r="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:void 0!==e?e:e=>e();function o(){return new Promise((e=>r((()=>e()))))}}).call(this,n(265).setImmediate)},668:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r=n(506),o=n(507),c={blocks:function(e){for(var t=[],n=e.data.length,r=0,c=(0,o.readByte)()(e);0!==c&&c;c=(0,o.readByte)()(e)){if(e.pos+c>=n){var l=n-e.pos;t.push((0,o.readBytes)(l)(e)),r+=l;break}t.push((0,o.readBytes)(c)(e)),r+=c}for(var d=new Uint8Array(r),h=0,i=0;i<t.length;i++)d.set(t[i],h),h+=t[i].length;return d}},l=(0,r.conditional)({gce:[{codes:(0,o.readBytes)(2)},{byteSize:(0,o.readByte)()},{extras:(0,o.readBits)({future:{index:0,length:3},disposal:{index:3,length:3},userInput:{index:6},transparentColorGiven:{index:7}})},{delay:(0,o.readUnsigned)(!0)},{transparentColorIndex:(0,o.readByte)()},{terminator:(0,o.readByte)()}]},(function(e){var t=(0,o.peekBytes)(2)(e);return 33===t[0]&&249===t[1]})),d=(0,r.conditional)({image:[{code:(0,o.readByte)()},{descriptor:[{left:(0,o.readUnsigned)(!0)},{top:(0,o.readUnsigned)(!0)},{width:(0,o.readUnsigned)(!0)},{height:(0,o.readUnsigned)(!0)},{lct:(0,o.readBits)({exists:{index:0},interlaced:{index:1},sort:{index:2},future:{index:3,length:2},size:{index:5,length:3}})}]},(0,r.conditional)({lct:(0,o.readArray)(3,(function(e,t,n){return Math.pow(2,n.descriptor.lct.size+1)}))},(function(e,t,n){return n.descriptor.lct.exists})),{data:[{minCodeSize:(0,o.readByte)()},c]}]},(function(e){return 44===(0,o.peekByte)()(e)})),h=(0,r.conditional)({text:[{codes:(0,o.readBytes)(2)},{blockSize:(0,o.readByte)()},{preData:function(e,t,n){return(0,o.readBytes)(n.text.blockSize)(e)}},c]},(function(e){var t=(0,o.peekBytes)(2)(e);return 33===t[0]&&1===t[1]})),f=(0,r.conditional)({application:[{codes:(0,o.readBytes)(2)},{blockSize:(0,o.readByte)()},{id:function(e,t,n){return(0,o.readString)(n.blockSize)(e)}},c]},(function(e){var t=(0,o.peekBytes)(2)(e);return 33===t[0]&&255===t[1]})),m=(0,r.conditional)({comment:[{codes:(0,o.readBytes)(2)},c]},(function(e){var t=(0,o.peekBytes)(2)(e);return 33===t[0]&&254===t[1]})),x=[{header:[{signature:(0,o.readString)(3)},{version:(0,o.readString)(3)}]},{lsd:[{width:(0,o.readUnsigned)(!0)},{height:(0,o.readUnsigned)(!0)},{gct:(0,o.readBits)({exists:{index:0},resolution:{index:1,length:3},sort:{index:4},size:{index:5,length:3}})},{backgroundColorIndex:(0,o.readByte)()},{pixelAspectRatio:(0,o.readByte)()}]},(0,r.conditional)({gct:(0,o.readArray)(3,(function(e,t){return Math.pow(2,t.lsd.gct.size+1)}))},(function(e,t){return t.lsd.gct.exists})),{frames:(0,r.loop)([l,f,m,d,h],(function(e){var t=(0,o.peekByte)()(e);return 33===t||44===t}))}];t.default=x},669:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.deinterlace=void 0;t.deinterlace=function(e,t){for(var n=new Array(e.length),r=e.length/t,o=function(r,o){var c=e.slice(o*t,(o+1)*t);n.splice.apply(n,[r*t,t].concat(c))},c=[0,4,2,1],l=[8,8,4,2],d=0,h=0;h<4;h++)for(var f=c[h];f<r;f+=l[h])o(f,d),d++;return n}},670:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.lzw=void 0;t.lzw=function(e,data,t){var n,r,o,c,l,d,h,code,i,f,m,x,v,y,w,C,I=4096,$=t,S=new Array(t),k=new Array(I),E=new Array(I),T=new Array(4097);for(l=(r=1<<(f=e))+1,n=r+2,h=-1,o=(1<<(c=f+1))-1,code=0;code<r;code++)k[code]=0,E[code]=code;for(m=x=v=y=w=C=0,i=0;i<$;){if(0===y){if(x<c){m+=data[C]<<x,x+=8,C++;continue}if(code=m&o,m>>=c,x-=c,code>n||code==l)break;if(code==r){o=(1<<(c=f+1))-1,n=r+2,h=-1;continue}if(-1==h){T[y++]=E[code],h=code,v=code;continue}for(d=code,code==n&&(T[y++]=v,code=h);code>r;)T[y++]=E[code],code=k[code];v=255&E[code],T[y++]=v,n<I&&(k[n]=h,E[n]=v,0==(++n&o)&&n<I&&(c++,o+=n)),h=d}y--,S[w++]=T[y],i++}for(i=w;i<$;i++)S[i]=0;return S}},671:function(e,t){e.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function r(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function o(e){return!0===(e&&e.__isLong__)}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=o;var c={},l={};function d(e,t){var n,r,o;return t?(o=0<=(e>>>=0)&&e<256)&&(r=l[e])?r:(n=f(e,(0|e)<0?-1:0,!0),o&&(l[e]=n),n):(o=-128<=(e|=0)&&e<128)&&(r=c[e])?r:(n=f(e,e<0?-1:0,!1),o&&(c[e]=n),n)}function h(e,t){if(isNaN(e))return t?S:$;if(t){if(e<0)return S;if(e>=w)return O}else{if(e<=-C)return A;if(e+1>=C)return R}return e<0?h(-e,t).neg():f(e%y|0,e/y|0,t)}function f(e,t,n){return new r(e,t,n)}r.fromInt=d,r.fromNumber=h,r.fromBits=f;var m=Math.pow;function x(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return $;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var p;if((p=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===p)return x(e.substring(1),t,n).neg();for(var r=h(m(n,8)),o=$,i=0;i<e.length;i+=8){var c=Math.min(8,e.length-i),l=parseInt(e.substring(i,i+c),n);if(c<8){var d=h(m(n,c));o=o.mul(d).add(h(l))}else o=(o=o.mul(r)).add(h(l))}return o.unsigned=t,o}function v(e,t){return"number"==typeof e?h(e,t):"string"==typeof e?x(e,t):f(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}r.fromString=x,r.fromValue=v;var y=4294967296,w=y*y,C=w/2,I=d(1<<24),$=d(0);r.ZERO=$;var S=d(0,!0);r.UZERO=S;var k=d(1);r.ONE=k;var E=d(1,!0);r.UONE=E;var T=d(-1);r.NEG_ONE=T;var R=f(-1,2147483647,!1);r.MAX_VALUE=R;var O=f(-1,-1,!0);r.MAX_UNSIGNED_VALUE=O;var A=f(0,-2147483648,!1);r.MIN_VALUE=A;var N=r.prototype;N.toInt=function(){return this.unsigned?this.low>>>0:this.low},N.toNumber=function(){return this.unsigned?(this.high>>>0)*y+(this.low>>>0):this.high*y+(this.low>>>0)},N.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(A)){var t=h(e),div=this.div(t),n=div.mul(t).sub(this);return div.toString(e)+n.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var r=h(m(e,6),this.unsigned),o=this,c="";;){var l=o.div(r),d=(o.sub(l.mul(r)).toInt()>>>0).toString(e);if((o=l).isZero())return d+c;for(;d.length<6;)d="0"+d;c=""+d+c}},N.getHighBits=function(){return this.high},N.getHighBitsUnsigned=function(){return this.high>>>0},N.getLowBits=function(){return this.low},N.getLowBitsUnsigned=function(){return this.low>>>0},N.getNumBitsAbs=function(){if(this.isNegative())return this.eq(A)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},N.isZero=function(){return 0===this.high&&0===this.low},N.eqz=N.isZero,N.isNegative=function(){return!this.unsigned&&this.high<0},N.isPositive=function(){return this.unsigned||this.high>=0},N.isOdd=function(){return 1==(1&this.low)},N.isEven=function(){return 0==(1&this.low)},N.equals=function(e){return o(e)||(e=v(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&(this.high===e.high&&this.low===e.low)},N.eq=N.equals,N.notEquals=function(e){return!this.eq(e)},N.neq=N.notEquals,N.ne=N.notEquals,N.lessThan=function(e){return this.comp(e)<0},N.lt=N.lessThan,N.lessThanOrEqual=function(e){return this.comp(e)<=0},N.lte=N.lessThanOrEqual,N.le=N.lessThanOrEqual,N.greaterThan=function(e){return this.comp(e)>0},N.gt=N.greaterThan,N.greaterThanOrEqual=function(e){return this.comp(e)>=0},N.gte=N.greaterThanOrEqual,N.ge=N.greaterThanOrEqual,N.compare=function(e){if(o(e)||(e=v(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},N.comp=N.compare,N.negate=function(){return!this.unsigned&&this.eq(A)?A:this.not().add(k)},N.neg=N.negate,N.add=function(e){o(e)||(e=v(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,c=65535&this.low,l=e.high>>>16,d=65535&e.high,h=e.low>>>16,m=0,x=0,y=0,w=0;return y+=(w+=c+(65535&e.low))>>>16,x+=(y+=r+h)>>>16,m+=(x+=n+d)>>>16,m+=t+l,f((y&=65535)<<16|(w&=65535),(m&=65535)<<16|(x&=65535),this.unsigned)},N.subtract=function(e){return o(e)||(e=v(e)),this.add(e.neg())},N.sub=N.subtract,N.multiply=function(e){if(this.isZero())return $;if(o(e)||(e=v(e)),n)return f(n.mul(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned);if(e.isZero())return $;if(this.eq(A))return e.isOdd()?A:$;if(e.eq(A))return this.isOdd()?A:$;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(I)&&e.lt(I))return h(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,r=65535&this.high,c=this.low>>>16,l=65535&this.low,d=e.high>>>16,m=65535&e.high,x=e.low>>>16,y=65535&e.low,w=0,C=0,S=0,k=0;return S+=(k+=l*y)>>>16,C+=(S+=c*y)>>>16,S&=65535,C+=(S+=l*x)>>>16,w+=(C+=r*y)>>>16,C&=65535,w+=(C+=c*x)>>>16,C&=65535,w+=(C+=l*m)>>>16,w+=t*y+r*x+c*m+l*d,f((S&=65535)<<16|(k&=65535),(w&=65535)<<16|(C&=65535),this.unsigned)},N.mul=N.multiply,N.divide=function(e){if(o(e)||(e=v(e)),e.isZero())throw Error("division by zero");var t,r,c;if(n)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?f((this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?S:$;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return S;if(e.gt(this.shru(1)))return E;c=S}else{if(this.eq(A))return e.eq(k)||e.eq(T)?A:e.eq(A)?k:(t=this.shr(1).div(e).shl(1)).eq($)?e.isNegative()?k:T:(r=this.sub(e.mul(t)),c=t.add(r.div(e)));if(e.eq(A))return this.unsigned?S:$;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();c=$}for(r=this;r.gte(e);){t=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var l=Math.ceil(Math.log(t)/Math.LN2),d=l<=48?1:m(2,l-48),x=h(t),y=x.mul(e);y.isNegative()||y.gt(r);)y=(x=h(t-=d,this.unsigned)).mul(e);x.isZero()&&(x=k),c=c.add(x),r=r.sub(y)}return c},N.div=N.divide,N.modulo=function(e){return o(e)||(e=v(e)),n?f((this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high),n.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},N.mod=N.modulo,N.rem=N.modulo,N.not=function(){return f(~this.low,~this.high,this.unsigned)},N.and=function(e){return o(e)||(e=v(e)),f(this.low&e.low,this.high&e.high,this.unsigned)},N.or=function(e){return o(e)||(e=v(e)),f(this.low|e.low,this.high|e.high,this.unsigned)},N.xor=function(e){return o(e)||(e=v(e)),f(this.low^e.low,this.high^e.high,this.unsigned)},N.shiftLeft=function(e){return o(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?f(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):f(0,this.low<<e-32,this.unsigned)},N.shl=N.shiftLeft,N.shiftRight=function(e){return o(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?f(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):f(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},N.shr=N.shiftRight,N.shiftRightUnsigned=function(e){if(o(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?f(this.low>>>e|t<<32-e,t>>>e,this.unsigned):f(32===e?t:t>>>e-32,0,this.unsigned)},N.shru=N.shiftRightUnsigned,N.shr_u=N.shiftRightUnsigned,N.toSigned=function(){return this.unsigned?f(this.low,this.high,!1):this},N.toUnsigned=function(){return this.unsigned?this:f(this.low,this.high,!0)},N.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},N.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},N.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},672:function(e,t,n){"use strict";(function(e){var r=n(673),o=n(674),c=n(675);function l(){return h.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function d(e,t){if(l()<t)throw new RangeError("Invalid typed array length");return h.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=h.prototype:(null===e&&(e=new h(t)),e.length=t),e}function h(e,t,n){if(!(h.TYPED_ARRAY_SUPPORT||this instanceof h))return new h(e,t,n);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return x(this,e)}return f(this,e,t,n)}function f(e,t,n,r){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,n,r){if(t.byteLength,n<0||t.byteLength<n)throw new RangeError("'offset' is out of bounds");if(t.byteLength<n+(r||0))throw new RangeError("'length' is out of bounds");t=void 0===n&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,n):new Uint8Array(t,n,r);h.TYPED_ARRAY_SUPPORT?(e=t).__proto__=h.prototype:e=v(e,t);return e}(e,t,n,r):"string"==typeof t?function(e,t,n){"string"==typeof n&&""!==n||(n="utf8");if(!h.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');var r=0|w(t,n);e=d(e,r);var o=e.write(t,n);o!==r&&(e=e.slice(0,o));return e}(e,t,n):function(e,t){if(h.isBuffer(t)){var n=0|y(t.length);return 0===(e=d(e,n)).length||t.copy(e,0,0,n),e}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||(r=t.length)!=r?d(e,0):v(e,t);if("Buffer"===t.type&&c(t.data))return v(e,t.data)}var r;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function m(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function x(e,t){if(m(t),e=d(e,t<0?0:0|y(t)),!h.TYPED_ARRAY_SUPPORT)for(var i=0;i<t;++i)e[i]=0;return e}function v(e,t){var n=t.length<0?0:0|y(t.length);e=d(e,n);for(var i=0;i<n;i+=1)e[i]=255&t[i];return e}function y(e){if(e>=l())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+l().toString(16)+" bytes");return 0|e}function w(e,t){if(h.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var n=e.length;if(0===n)return 0;for(var r=!1;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case void 0:return K(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return Y(e).length;default:if(r)return K(e).length;t=(""+t).toLowerCase(),r=!0}}function C(e,t,n){var r=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return L(this,t,n);case"utf8":case"utf-8":return _(this,t,n);case"ascii":return D(this,t,n);case"latin1":case"binary":return P(this,t,n);case"base64":return N(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return B(this,t,n);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0}}function I(b,e,t){var i=b[e];b[e]=b[t],b[t]=i}function $(e,t,n,r,o){if(0===e.length)return-1;if("string"==typeof n?(r=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=o?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(o)return-1;n=e.length-1}else if(n<0){if(!o)return-1;n=0}if("string"==typeof t&&(t=h.from(t,r)),h.isBuffer(t))return 0===t.length?-1:S(e,t,n,r,o);if("number"==typeof t)return t&=255,h.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?o?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):S(e,[t],n,r,o);throw new TypeError("val must be string, number or Buffer")}function S(e,t,n,r,o){var i,c=1,l=e.length,d=t.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||t.length<2)return-1;c=2,l/=2,d/=2,n/=2}function h(e,i){return 1===c?e[i]:e.readUInt16BE(i*c)}if(o){var f=-1;for(i=n;i<l;i++)if(h(e,i)===h(t,-1===f?0:i-f)){if(-1===f&&(f=i),i-f+1===d)return f*c}else-1!==f&&(i-=i-f),f=-1}else for(n+d>l&&(n=l-d),i=n;i>=0;i--){for(var m=!0,x=0;x<d;x++)if(h(e,i+x)!==h(t,x)){m=!1;break}if(m)return i}return-1}function k(e,t,n,r){n=Number(n)||0;var o=e.length-n;r?(r=Number(r))>o&&(r=o):r=o;var c=t.length;if(c%2!=0)throw new TypeError("Invalid hex string");r>c/2&&(r=c/2);for(var i=0;i<r;++i){var l=parseInt(t.substr(2*i,2),16);if(isNaN(l))return i;e[n+i]=l}return i}function E(e,t,n,r){return Z(K(t,e.length-n),e,n,r)}function T(e,t,n,r){return Z(function(e){for(var t=[],i=0;i<e.length;++i)t.push(255&e.charCodeAt(i));return t}(t),e,n,r)}function R(e,t,n,r){return T(e,t,n,r)}function O(e,t,n,r){return Z(Y(t),e,n,r)}function A(e,t,n,r){return Z(function(e,t){for(var n,r,o,c=[],i=0;i<e.length&&!((t-=2)<0);++i)r=(n=e.charCodeAt(i))>>8,o=n%256,c.push(o),c.push(r);return c}(t,e.length-n),e,n,r)}function N(e,t,n){return 0===t&&n===e.length?r.fromByteArray(e):r.fromByteArray(e.slice(t,n))}function _(e,t,n){n=Math.min(e.length,n);for(var r=[],i=t;i<n;){var o,c,l,d,h=e[i],f=null,m=h>239?4:h>223?3:h>191?2:1;if(i+m<=n)switch(m){case 1:h<128&&(f=h);break;case 2:128==(192&(o=e[i+1]))&&(d=(31&h)<<6|63&o)>127&&(f=d);break;case 3:o=e[i+1],c=e[i+2],128==(192&o)&&128==(192&c)&&(d=(15&h)<<12|(63&o)<<6|63&c)>2047&&(d<55296||d>57343)&&(f=d);break;case 4:o=e[i+1],c=e[i+2],l=e[i+3],128==(192&o)&&128==(192&c)&&128==(192&l)&&(d=(15&h)<<18|(63&o)<<12|(63&c)<<6|63&l)>65535&&d<1114112&&(f=d)}null===f?(f=65533,m=1):f>65535&&(f-=65536,r.push(f>>>10&1023|55296),f=56320|1023&f),r.push(f),i+=m}return function(e){var t=e.length;if(t<=F)return String.fromCharCode.apply(String,e);var n="",i=0;for(;i<t;)n+=String.fromCharCode.apply(String,e.slice(i,i+=F));return n}(r)}t.Buffer=h,t.SlowBuffer=function(e){+e!=e&&(e=0);return h.alloc(+e)},t.INSPECT_MAX_BYTES=50,h.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}(),t.kMaxLength=l(),h.poolSize=8192,h._augment=function(e){return e.__proto__=h.prototype,e},h.from=function(e,t,n){return f(null,e,t,n)},h.TYPED_ARRAY_SUPPORT&&(h.prototype.__proto__=Uint8Array.prototype,h.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&h[Symbol.species]===h&&Object.defineProperty(h,Symbol.species,{value:null,configurable:!0})),h.alloc=function(e,t,n){return function(e,t,n,r){return m(t),t<=0?d(e,t):void 0!==n?"string"==typeof r?d(e,t).fill(n,r):d(e,t).fill(n):d(e,t)}(null,e,t,n)},h.allocUnsafe=function(e){return x(null,e)},h.allocUnsafeSlow=function(e){return x(null,e)},h.isBuffer=function(b){return!(null==b||!b._isBuffer)},h.compare=function(a,b){if(!h.isBuffer(a)||!h.isBuffer(b))throw new TypeError("Arguments must be Buffers");if(a===b)return 0;for(var e=a.length,t=b.length,i=0,n=Math.min(e,t);i<n;++i)if(a[i]!==b[i]){e=a[i],t=b[i];break}return e<t?-1:t<e?1:0},h.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},h.concat=function(e,t){if(!c(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return h.alloc(0);var i;if(void 0===t)for(t=0,i=0;i<e.length;++i)t+=e[i].length;var n=h.allocUnsafe(t),r=0;for(i=0;i<e.length;++i){var o=e[i];if(!h.isBuffer(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(n,r),r+=o.length}return n},h.byteLength=w,h.prototype._isBuffer=!0,h.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var i=0;i<e;i+=2)I(this,i,i+1);return this},h.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var i=0;i<e;i+=4)I(this,i,i+3),I(this,i+1,i+2);return this},h.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var i=0;i<e;i+=8)I(this,i,i+7),I(this,i+1,i+6),I(this,i+2,i+5),I(this,i+3,i+4);return this},h.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?_(this,0,e):C.apply(this,arguments)},h.prototype.equals=function(b){if(!h.isBuffer(b))throw new TypeError("Argument must be a Buffer");return this===b||0===h.compare(this,b)},h.prototype.inspect=function(){var e="",n=t.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,n).match(/.{2}/g).join(" "),this.length>n&&(e+=" ... ")),"<Buffer "+e+">"},h.prototype.compare=function(e,t,n,r,o){if(!h.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===r&&(r=0),void 0===o&&(o=this.length),t<0||n>e.length||r<0||o>this.length)throw new RangeError("out of range index");if(r>=o&&t>=n)return 0;if(r>=o)return-1;if(t>=n)return 1;if(this===e)return 0;for(var c=(o>>>=0)-(r>>>=0),l=(n>>>=0)-(t>>>=0),d=Math.min(c,l),f=this.slice(r,o),m=e.slice(t,n),i=0;i<d;++i)if(f[i]!==m[i]){c=f[i],l=m[i];break}return c<l?-1:l<c?1:0},h.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},h.prototype.indexOf=function(e,t,n){return $(this,e,t,n,!0)},h.prototype.lastIndexOf=function(e,t,n){return $(this,e,t,n,!1)},h.prototype.write=function(e,t,n,r){if(void 0===t)r="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)r=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(n)?(n|=0,void 0===r&&(r="utf8")):(r=n,n=void 0)}var o=this.length-t;if((void 0===n||n>o)&&(n=o),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");for(var c=!1;;)switch(r){case"hex":return k(this,e,t,n);case"utf8":case"utf-8":return E(this,e,t,n);case"ascii":return T(this,e,t,n);case"latin1":case"binary":return R(this,e,t,n);case"base64":return O(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return A(this,e,t,n);default:if(c)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),c=!0}},h.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var F=4096;function D(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<n;++i)r+=String.fromCharCode(127&e[i]);return r}function P(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<n;++i)r+=String.fromCharCode(e[i]);return r}function L(e,t,n){var r=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>r)&&(n=r);for(var o="",i=t;i<n;++i)o+=X(e[i]);return o}function B(e,t,n){for(var r=e.slice(t,n),o="",i=0;i<r.length;i+=2)o+=String.fromCharCode(r[i]+256*r[i+1]);return o}function M(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function j(e,t,n,r,o,c){if(!h.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>o||t<c)throw new RangeError('"value" argument is out of bounds');if(n+r>e.length)throw new RangeError("Index out of range")}function U(e,t,n,r){t<0&&(t=65535+t+1);for(var i=0,o=Math.min(e.length-n,2);i<o;++i)e[n+i]=(t&255<<8*(r?i:1-i))>>>8*(r?i:1-i)}function W(e,t,n,r){t<0&&(t=4294967295+t+1);for(var i=0,o=Math.min(e.length-n,4);i<o;++i)e[n+i]=t>>>8*(r?i:3-i)&255}function V(e,t,n,r,o,c){if(n+r>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function z(e,t,n,r,c){return c||V(e,0,n,4),o.write(e,t,n,r,23,4),n+4}function G(e,t,n,r,c){return c||V(e,0,n,8),o.write(e,t,n,r,52,8),n+8}h.prototype.slice=function(e,t){var n,r=this.length;if((e=~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),(t=void 0===t?r:~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),t<e&&(t=e),h.TYPED_ARRAY_SUPPORT)(n=this.subarray(e,t)).__proto__=h.prototype;else{var o=t-e;n=new h(o,void 0);for(var i=0;i<o;++i)n[i]=this[i+e]}return n},h.prototype.readUIntLE=function(e,t,n){e|=0,t|=0,n||M(e,t,this.length);for(var r=this[e],o=1,i=0;++i<t&&(o*=256);)r+=this[e+i]*o;return r},h.prototype.readUIntBE=function(e,t,n){e|=0,t|=0,n||M(e,t,this.length);for(var r=this[e+--t],o=1;t>0&&(o*=256);)r+=this[e+--t]*o;return r},h.prototype.readUInt8=function(e,t){return t||M(e,1,this.length),this[e]},h.prototype.readUInt16LE=function(e,t){return t||M(e,2,this.length),this[e]|this[e+1]<<8},h.prototype.readUInt16BE=function(e,t){return t||M(e,2,this.length),this[e]<<8|this[e+1]},h.prototype.readUInt32LE=function(e,t){return t||M(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},h.prototype.readUInt32BE=function(e,t){return t||M(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},h.prototype.readIntLE=function(e,t,n){e|=0,t|=0,n||M(e,t,this.length);for(var r=this[e],o=1,i=0;++i<t&&(o*=256);)r+=this[e+i]*o;return r>=(o*=128)&&(r-=Math.pow(2,8*t)),r},h.prototype.readIntBE=function(e,t,n){e|=0,t|=0,n||M(e,t,this.length);for(var i=t,r=1,o=this[e+--i];i>0&&(r*=256);)o+=this[e+--i]*r;return o>=(r*=128)&&(o-=Math.pow(2,8*t)),o},h.prototype.readInt8=function(e,t){return t||M(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},h.prototype.readInt16LE=function(e,t){t||M(e,2,this.length);var n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},h.prototype.readInt16BE=function(e,t){t||M(e,2,this.length);var n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},h.prototype.readInt32LE=function(e,t){return t||M(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},h.prototype.readInt32BE=function(e,t){return t||M(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},h.prototype.readFloatLE=function(e,t){return t||M(e,4,this.length),o.read(this,e,!0,23,4)},h.prototype.readFloatBE=function(e,t){return t||M(e,4,this.length),o.read(this,e,!1,23,4)},h.prototype.readDoubleLE=function(e,t){return t||M(e,8,this.length),o.read(this,e,!0,52,8)},h.prototype.readDoubleBE=function(e,t){return t||M(e,8,this.length),o.read(this,e,!1,52,8)},h.prototype.writeUIntLE=function(e,t,n,r){(e=+e,t|=0,n|=0,r)||j(this,e,t,n,Math.pow(2,8*n)-1,0);var o=1,i=0;for(this[t]=255&e;++i<n&&(o*=256);)this[t+i]=e/o&255;return t+n},h.prototype.writeUIntBE=function(e,t,n,r){(e=+e,t|=0,n|=0,r)||j(this,e,t,n,Math.pow(2,8*n)-1,0);var i=n-1,o=1;for(this[t+i]=255&e;--i>=0&&(o*=256);)this[t+i]=e/o&255;return t+n},h.prototype.writeUInt8=function(e,t,n){return e=+e,t|=0,n||j(this,e,t,1,255,0),h.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},h.prototype.writeUInt16LE=function(e,t,n){return e=+e,t|=0,n||j(this,e,t,2,65535,0),h.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):U(this,e,t,!0),t+2},h.prototype.writeUInt16BE=function(e,t,n){return e=+e,t|=0,n||j(this,e,t,2,65535,0),h.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):U(this,e,t,!1),t+2},h.prototype.writeUInt32LE=function(e,t,n){return e=+e,t|=0,n||j(this,e,t,4,4294967295,0),h.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):W(this,e,t,!0),t+4},h.prototype.writeUInt32BE=function(e,t,n){return e=+e,t|=0,n||j(this,e,t,4,4294967295,0),h.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):W(this,e,t,!1),t+4},h.prototype.writeIntLE=function(e,t,n,r){if(e=+e,t|=0,!r){var o=Math.pow(2,8*n-1);j(this,e,t,n,o-1,-o)}var i=0,c=1,sub=0;for(this[t]=255&e;++i<n&&(c*=256);)e<0&&0===sub&&0!==this[t+i-1]&&(sub=1),this[t+i]=(e/c>>0)-sub&255;return t+n},h.prototype.writeIntBE=function(e,t,n,r){if(e=+e,t|=0,!r){var o=Math.pow(2,8*n-1);j(this,e,t,n,o-1,-o)}var i=n-1,c=1,sub=0;for(this[t+i]=255&e;--i>=0&&(c*=256);)e<0&&0===sub&&0!==this[t+i+1]&&(sub=1),this[t+i]=(e/c>>0)-sub&255;return t+n},h.prototype.writeInt8=function(e,t,n){return e=+e,t|=0,n||j(this,e,t,1,127,-128),h.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},h.prototype.writeInt16LE=function(e,t,n){return e=+e,t|=0,n||j(this,e,t,2,32767,-32768),h.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):U(this,e,t,!0),t+2},h.prototype.writeInt16BE=function(e,t,n){return e=+e,t|=0,n||j(this,e,t,2,32767,-32768),h.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):U(this,e,t,!1),t+2},h.prototype.writeInt32LE=function(e,t,n){return e=+e,t|=0,n||j(this,e,t,4,2147483647,-2147483648),h.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):W(this,e,t,!0),t+4},h.prototype.writeInt32BE=function(e,t,n){return e=+e,t|=0,n||j(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),h.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):W(this,e,t,!1),t+4},h.prototype.writeFloatLE=function(e,t,n){return z(this,e,t,!0,n)},h.prototype.writeFloatBE=function(e,t,n){return z(this,e,t,!1,n)},h.prototype.writeDoubleLE=function(e,t,n){return G(this,e,t,!0,n)},h.prototype.writeDoubleBE=function(e,t,n){return G(this,e,t,!1,n)},h.prototype.copy=function(e,t,n,r){if(n||(n=0),r||0===r||(r=this.length),t>=e.length&&(t=e.length),t||(t=0),r>0&&r<n&&(r=n),r===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-t<r-n&&(r=e.length-t+n);var i,o=r-n;if(this===e&&n<t&&t<r)for(i=o-1;i>=0;--i)e[i+t]=this[i+n];else if(o<1e3||!h.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)e[i+t]=this[i+n];else Uint8Array.prototype.set.call(e,this.subarray(n,n+o),t);return o},h.prototype.fill=function(e,t,n,r){if("string"==typeof e){if("string"==typeof t?(r=t,t=0,n=this.length):"string"==typeof n&&(r=n,n=this.length),1===e.length){var code=e.charCodeAt(0);code<256&&(e=code)}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!h.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;var i;if(t>>>=0,n=void 0===n?this.length:n>>>0,e||(e=0),"number"==typeof e)for(i=t;i<n;++i)this[i]=e;else{var o=h.isBuffer(e)?e:K(new h(e,r).toString()),c=o.length;for(i=0;i<n-t;++i)this[i+t]=o[i%c]}return this};var H=/[^+\/0-9A-Za-z-_]/g;function X(e){return e<16?"0"+e.toString(16):e.toString(16)}function K(e,t){var n;t=t||1/0;for(var r=e.length,o=null,c=[],i=0;i<r;++i){if((n=e.charCodeAt(i))>55295&&n<57344){if(!o){if(n>56319){(t-=3)>-1&&c.push(239,191,189);continue}if(i+1===r){(t-=3)>-1&&c.push(239,191,189);continue}o=n;continue}if(n<56320){(t-=3)>-1&&c.push(239,191,189),o=n;continue}n=65536+(o-55296<<10|n-56320)}else o&&(t-=3)>-1&&c.push(239,191,189);if(o=null,n<128){if((t-=1)<0)break;c.push(n)}else if(n<2048){if((t-=2)<0)break;c.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;c.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;c.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return c}function Y(e){return r.toByteArray(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(H,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function Z(e,t,n,r){for(var i=0;i<r&&!(i+n>=t.length||i>=e.length);++i)t[i+n]=e[i];return i}}).call(this,n(27))},673:function(e,t,n){"use strict";t.byteLength=function(e){var t=l(e),n=t[0],r=t[1];return 3*(n+r)/4-r},t.toByteArray=function(e){var t,i,n=l(e),r=n[0],d=n[1],h=new c(function(e,t,n){return 3*(t+n)/4-n}(0,r,d)),f=0,m=d>0?r-4:r;for(i=0;i<m;i+=4)t=o[e.charCodeAt(i)]<<18|o[e.charCodeAt(i+1)]<<12|o[e.charCodeAt(i+2)]<<6|o[e.charCodeAt(i+3)],h[f++]=t>>16&255,h[f++]=t>>8&255,h[f++]=255&t;2===d&&(t=o[e.charCodeAt(i)]<<2|o[e.charCodeAt(i+1)]>>4,h[f++]=255&t);1===d&&(t=o[e.charCodeAt(i)]<<10|o[e.charCodeAt(i+1)]<<4|o[e.charCodeAt(i+2)]>>2,h[f++]=t>>8&255,h[f++]=255&t);return h},t.fromByteArray=function(e){for(var t,n=e.length,o=n%3,c=[],l=16383,i=0,h=n-o;i<h;i+=l)c.push(d(e,i,i+l>h?h:i+l));1===o?(t=e[n-1],c.push(r[t>>2]+r[t<<4&63]+"==")):2===o&&(t=(e[n-2]<<8)+e[n-1],c.push(r[t>>10]+r[t>>4&63]+r[t<<2&63]+"="));return c.join("")};for(var r=[],o=[],c="undefined"!=typeof Uint8Array?Uint8Array:Array,code="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0;i<64;++i)r[i]=code[i],o[code.charCodeAt(i)]=i;function l(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=e.indexOf("=");return-1===n&&(n=t),[n,n===t?0:4-n%4]}function d(e,t,n){for(var o,c,output=[],i=t;i<n;i+=3)o=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(255&e[i+2]),output.push(r[(c=o)>>18&63]+r[c>>12&63]+r[c>>6&63]+r[63&c]);return output.join("")}o["-".charCodeAt(0)]=62,o["_".charCodeAt(0)]=63},674:function(e,t){t.read=function(e,t,n,r,o){var c,l,d=8*o-r-1,h=(1<<d)-1,f=h>>1,m=-7,i=n?o-1:0,x=n?-1:1,s=e[t+i];for(i+=x,c=s&(1<<-m)-1,s>>=-m,m+=d;m>0;c=256*c+e[t+i],i+=x,m-=8);for(l=c&(1<<-m)-1,c>>=-m,m+=r;m>0;l=256*l+e[t+i],i+=x,m-=8);if(0===c)c=1-f;else{if(c===h)return l?NaN:1/0*(s?-1:1);l+=Math.pow(2,r),c-=f}return(s?-1:1)*l*Math.pow(2,c-r)},t.write=function(e,t,n,r,o,c){var l,d,h,f=8*c-o-1,m=(1<<f)-1,x=m>>1,rt=23===o?Math.pow(2,-24)-Math.pow(2,-77):0,i=r?0:c-1,v=r?1:-1,s=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(d=isNaN(t)?1:0,l=m):(l=Math.floor(Math.log(t)/Math.LN2),t*(h=Math.pow(2,-l))<1&&(l--,h*=2),(t+=l+x>=1?rt/h:rt*Math.pow(2,1-x))*h>=2&&(l++,h/=2),l+x>=m?(d=0,l=m):l+x>=1?(d=(t*h-1)*Math.pow(2,o),l+=x):(d=t*Math.pow(2,x-1)*Math.pow(2,o),l=0));o>=8;e[n+i]=255&d,i+=v,d/=256,o-=8);for(l=l<<o|d,f+=o;f>0;e[n+i]=255&l,i+=v,l/=256,f-=8);e[n+i-v]|=128*s}},675:function(e,t){var n={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==n.call(e)}},676:function(e,t,n){"use strict";(function(e){var t=n(409);const r=()=>n(464);let o;class c{constructor(){this.util=n(465),this.textEncoder=new this.util.TextEncoder}fetch(path,e){return null!=Object(t.b)().global.fetch?Object(t.b)().global.fetch(path,e):(null==o&&(o=r()),o(path,e))}now(){const time=e.hrtime();return 1e3*time[0]+time[1]/1e6}encode(text,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(text)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}}Object(t.b)().get("IS_NODE")&&!Object(t.b)().get("IS_BROWSER")&&Object(t.b)().setPlatform("node",new c)}).call(this,n(263))},677:function(e,t,n){(function(e){(function(){"use strict";var t;function n(a){var b=0;return function(){return b<a.length?{done:!1,value:a[b++]}:{done:!0}}}var r="function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,e){return a==Array.prototype||a==Object.prototype||(a[b]=e.value),a};var o=function(a){a=["object"==typeof globalThis&&globalThis,a,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof e&&e];for(var b=0;b<a.length;++b){var t=a[b];if(t&&t.Math==Math)return t}throw Error("Cannot find global object")}(this);function c(a,b){if(b)e:{var e=o;a=a.split(".");for(var t=0;t<a.length-1;t++){var n=a[t];if(!(n in e))break e;e=e[n]}(b=b(t=e[a=a[a.length-1]]))!=t&&null!=b&&r(e,a,{configurable:!0,writable:!0,value:b})}}function l(a){return(a={next:a})[Symbol.iterator]=function(){return this},a}function d(a){var b="undefined"!=typeof Symbol&&Symbol.iterator&&a[Symbol.iterator];return b?b.call(a):{next:n(a)}}function h(a){if(!(a instanceof Array)){a=d(a);for(var b,e=[];!(b=a.next()).done;)e.push(b.value);a=e}return a}c("Symbol",(function(a){function e(g,e){this.h=g,r(this,"description",{configurable:!0,writable:!0,value:e})}if(a)return a;e.prototype.toString=function(){return this.h};var t="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",n=0;return function b(g){if(this instanceof b)throw new TypeError("Symbol is not a constructor");return new e(t+(g||"")+"_"+n++,g)}})),c("Symbol.iterator",(function(a){if(a)return a;a=Symbol("Symbol.iterator");for(var b="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),e=0;e<b.length;e++){var t=o[b[e]];"function"==typeof t&&"function"!=typeof t.prototype[a]&&r(t.prototype,a,{configurable:!0,writable:!0,value:function(){return l(n(this))}})}return a}));var f="function"==typeof Object.assign?Object.assign:function(a,b){for(var e=1;e<arguments.length;e++){var t=arguments[e];if(t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(a[n]=t[n])}return a};c("Object.assign",(function(a){return a||f}));var m,x="function"==typeof Object.create?Object.create:function(a){function b(){}return b.prototype=a,new b};if("function"==typeof Object.setPrototypeOf)m=Object.setPrototypeOf;else{var v;e:{var y={};try{y.__proto__={a:!0},v=y.a;break e}catch(e){}v=!1}m=v?function(a,b){if(a.__proto__=b,a.__proto__!==b)throw new TypeError(a+" is not extensible");return a}:null}var w=m;function C(a,b){if(a.prototype=x(b.prototype),a.prototype.constructor=a,w)w(a,b);else for(var e in b)if("prototype"!=e)if(Object.defineProperties){var t=Object.getOwnPropertyDescriptor(b,e);t&&Object.defineProperty(a,e,t)}else a[e]=b[e];a.za=b.prototype}function I(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function $(a){if(a.m)throw new TypeError("Generator is already running");a.m=!0}function S(a,b){a.l={ma:b,na:!0},a.h=a.s||a.v}function k(a,b,e){return a.h=e,{value:b}}function E(a){this.h=new I,this.i=a}function T(a,b,e,t){try{var n=b.call(a.h.j,e);if(!(n instanceof Object))throw new TypeError("Iterator result "+n+" is not an object");if(!n.done)return a.h.m=!1,n;var g=n.value}catch(e){return a.h.j=null,S(a.h,e),R(a)}return a.h.j=null,t.call(a.h,g),R(a)}function R(a){for(;a.h.h;)try{var b=a.i(a.h);if(b)return a.h.m=!1,{value:b.value,done:!1}}catch(e){a.h.i=void 0,S(a.h,e)}if(a.h.m=!1,a.h.l){if(b=a.h.l,a.h.l=null,b.na)throw b.ma;return{value:b.return,done:!0}}return{value:void 0,done:!0}}function O(a){this.next=function(b){return $(a.h),a.h.j?b=T(a,a.h.j.next,b,a.h.u):(a.h.u(b),b=R(a)),b},this.throw=function(b){return $(a.h),a.h.j?b=T(a,a.h.j.throw,b,a.h.u):(S(a.h,b),b=R(a)),b},this.return=function(b){return function(a,b){$(a.h);var e=a.h.j;return e?T(a,"return"in e?e.return:function(e){return{value:e,done:!0}},b,a.h.return):(a.h.return(b),R(a))}(a,b)},this[Symbol.iterator]=function(){return this}}function A(a){return function(a){function b(e){return a.next(e)}function e(e){return a.throw(e)}return new Promise((function(t,n){!function g(r){r.done?t(r.value):Promise.resolve(r.value).then(b,e).then(g,n)}(a.next())}))}(new O(new E(a)))}function N(a){return a||Array.prototype.fill}I.prototype.u=function(a){this.i=a},I.prototype.return=function(a){this.l={return:a},this.h=this.v},c("Promise",(function(a){function b(e){this.i=0,this.j=void 0,this.h=[],this.u=!1;var t=this.l();try{e(t.resolve,t.reject)}catch(e){t.reject(e)}}function e(){this.h=null}function t(e){return e instanceof b?e:new b((function(t){t(e)}))}if(a)return a;e.prototype.i=function(e){if(null==this.h){this.h=[];var t=this;this.j((function(){t.m()}))}this.h.push(e)};var n=o.setTimeout;e.prototype.j=function(e){n(e,0)},e.prototype.m=function(){for(;this.h&&this.h.length;){var e=this.h;this.h=[];for(var t=0;t<e.length;++t){var n=e[t];e[t]=null;try{n()}catch(e){this.l(e)}}}this.h=null},e.prototype.l=function(e){this.j((function(){throw e}))},b.prototype.l=function(){function e(e){return function(r){n||(n=!0,e.call(t,r))}}var t=this,n=!1;return{resolve:e(this.I),reject:e(this.m)}},b.prototype.I=function(e){if(e===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(e instanceof b)this.L(e);else{e:switch(typeof e){case"object":var t=null!=e;break e;case"function":t=!0;break e;default:t=!1}t?this.F(e):this.s(e)}},b.prototype.F=function(e){var t=void 0;try{t=e.then}catch(e){return void this.m(e)}"function"==typeof t?this.M(t,e):this.s(e)},b.prototype.m=function(e){this.v(2,e)},b.prototype.s=function(e){this.v(1,e)},b.prototype.v=function(e,t){if(0!=this.i)throw Error("Cannot settle("+e+", "+t+"): Promise already settled in state"+this.i);this.i=e,this.j=t,2===this.i&&this.K(),this.H()},b.prototype.K=function(){var e=this;n((function(){if(e.D()){var t=o.console;void 0!==t&&t.error(e.j)}}),1)},b.prototype.D=function(){if(this.u)return!1;var e=o.CustomEvent,t=o.Event,n=o.dispatchEvent;return void 0===n||("function"==typeof e?e=new e("unhandledrejection",{cancelable:!0}):"function"==typeof t?e=new t("unhandledrejection",{cancelable:!0}):(e=o.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,e),e.promise=this,e.reason=this.j,n(e))},b.prototype.H=function(){if(null!=this.h){for(var e=0;e<this.h.length;++e)g.i(this.h[e]);this.h=null}};var g=new e;return b.prototype.L=function(e){var t=this.l();e.T(t.resolve,t.reject)},b.prototype.M=function(e,t){var n=this.l();try{e.call(t,n.resolve,n.reject)}catch(e){n.reject(e)}},b.prototype.then=function(e,t){function n(p,e){return"function"==typeof p?function(q){try{r(p(q))}catch(e){o(e)}}:e}var r,o,c=new b((function(p,e){r=p,o=e}));return this.T(n(e,r),n(t,o)),c},b.prototype.catch=function(e){return this.then(void 0,e)},b.prototype.T=function(e,t){function n(){switch(r.i){case 1:e(r.j);break;case 2:t(r.j);break;default:throw Error("Unexpected state: "+r.i)}}var r=this;null==this.h?g.i(n):this.h.push(n),this.u=!0},b.resolve=t,b.reject=function(e){return new b((function(t,n){n(e)}))},b.race=function(e){return new b((function(n,r){for(var o=d(e),c=o.next();!c.done;c=o.next())t(c.value).T(n,r)}))},b.all=function(e){var n=d(e),r=n.next();return r.done?t([]):new b((function(e,o){function c(q){return function(t){p[q]=t,0==--l&&e(p)}}var p=[],l=0;do{p.push(void 0),l++,t(r.value).T(c(p.length-1),o),r=n.next()}while(!r.done)}))},b})),c("Array.prototype.keys",(function(a){return a||function(){return function(a,b){a instanceof String&&(a+="");var e=0,t=!1,n={next:function(){if(!t&&e<a.length){var g=e++;return{value:b(g,a[g]),done:!1}}return t=!0,{done:!0,value:void 0}}};return n[Symbol.iterator]=function(){return n},n}(this,(function(b){return b}))}})),c("Array.prototype.fill",(function(a){return a||function(b,e,t){var n=this.length||0;for(0>e&&(e=Math.max(0,n+e)),(null==t||t>n)&&(t=n),0>(t=Number(t))&&(t=Math.max(0,n+t)),e=Number(e||0);e<t;e++)this[e]=b;return this}})),c("Int8Array.prototype.fill",N),c("Uint8Array.prototype.fill",N),c("Uint8ClampedArray.prototype.fill",N),c("Int16Array.prototype.fill",N),c("Uint16Array.prototype.fill",N),c("Int32Array.prototype.fill",N),c("Uint32Array.prototype.fill",N),c("Float32Array.prototype.fill",N),c("Float64Array.prototype.fill",N),c("Object.is",(function(a){return a||function(b,e){return b===e?0!==b||1/b==1/e:b!=b&&e!=e}})),c("Array.prototype.includes",(function(a){return a||function(b,e){var t=this;t instanceof String&&(t=String(t));var n=t.length;for(0>(e=e||0)&&(e=Math.max(e+n,0));e<n;e++){var g=t[e];if(g===b||Object.is(g,b))return!0}return!1}})),c("String.prototype.includes",(function(a){return a||function(b,e){if(null==this)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return-1!==this.indexOf(b,e||0)}}));var _=this||self;function F(a,b){a=a.split(".");var e,t=_;a[0]in t||void 0===t.execScript||t.execScript("var "+a[0]);for(;a.length&&(e=a.shift());)a.length||void 0===b?t=t[e]&&t[e]!==Object.prototype[e]?t[e]:t[e]={}:t[e]=b}function D(a){var b;return(b=_.navigator)&&(b=b.userAgent)||(b=""),-1!=b.indexOf(a)}var P=Array.prototype.map?function(a,b){return Array.prototype.map.call(a,b,void 0)}:function(a,b){for(var e=a.length,t=Array(e),n="string"==typeof a?a.split(""):a,g=0;g<e;g++)g in n&&(t[g]=b.call(void 0,n[g],g,a));return t},L={},B=null;function M(a){var b=a.length,e=3*b/4;e%3?e=Math.floor(e):-1!="=.".indexOf(a[b-1])&&(e=-1!="=.".indexOf(a[b-2])?e-2:e-1);var t=new Uint8Array(e),n=0;return function(a,b){function e(e){for(;t<a.length;){var n=a.charAt(t++),r=B[n];if(null!=r)return r;if(!/^[\s\xa0]*$/.test(n))throw Error("Unknown base64 encoding at char: "+n)}return e}j();for(var t=0;;){var n=e(-1),g=e(0),r=e(64),o=e(64);if(64===o&&-1===n)break;b(n<<2|g>>4),64!=r&&(b(g<<4&240|r>>2),64!=o&&b(r<<6&192|o))}}(a,(function(g){t[n++]=g})),n!==e?t.subarray(0,n):t}function j(){if(!B){B={};for(var a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),b=["+/=","+/","-_=","-_.","-_"],e=0;5>e;e++){var t=a.concat(b[e].split(""));L[e]=t;for(var n=0;n<t.length;n++){var g=t[n];void 0===B[g]&&(B[g]=n)}}}}var U="undefined"!=typeof Uint8Array,W=!(D("Trident")||D("MSIE"))&&"function"==typeof _.btoa;function V(a){if(!W){var b;void 0===b&&(b=0),j(),b=L[b];for(var e=Array(Math.floor(a.length/3)),t=b[64]||"",n=0,g=0;n<a.length-2;n+=3){var r=a[n],o=a[n+1],c=a[n+2],l=b[r>>2];r=b[(3&r)<<4|o>>4],o=b[(15&o)<<2|c>>6],c=b[63&c],e[g++]=l+r+o+c}switch(l=0,c=t,a.length-n){case 2:c=b[(15&(l=a[n+1]))<<2]||t;case 1:a=a[n],e[g]=b[a>>2]+b[(3&a)<<4|l>>4]+c+t}return e.join("")}for(b="";10240<a.length;)b+=String.fromCharCode.apply(null,a.subarray(0,10240)),a=a.subarray(10240);return b+=String.fromCharCode.apply(null,a),btoa(b)}var z,G=RegExp("[-_.]","g");function H(a){switch(a){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function X(a){if(!W)return M(a);G.test(a)&&(a=a.replace(G,H)),a=atob(a);for(var b=new Uint8Array(a.length),e=0;e<a.length;e++)b[e]=a.charCodeAt(e);return b}function K(){return z||(z=new Uint8Array(0))}var Y={},Z="function"==typeof Uint8Array.prototype.slice,Q=0,J=0;function ee(a){var b=0>a,e=(a=Math.abs(a))>>>0;a=Math.floor((a-e)/4294967296),b&&(b=(e=d(re(e,a))).next().value,a=e.next().value,e=b),Q=e>>>0,J=a>>>0}var te,ne="function"==typeof BigInt;function re(a,b){return b=~b,a?a=1+~a:b+=1,[a,b]}function oe(a,b){this.i=a>>>0,this.h=b>>>0}function ie(a){if(!a)return te||(te=new oe(0,0));if(!/^-?\d+$/.test(a))return null;if(16>a.length)ee(Number(a));else if(ne)a=BigInt(a),Q=Number(a&BigInt(4294967295))>>>0,J=Number(a>>BigInt(32)&BigInt(4294967295));else{var b=+("-"===a[0]);J=Q=0;for(var e=a.length,t=b,n=(e-b)%6+b;n<=e;t=n,n+=6)t=Number(a.slice(t,n)),J*=1e6,4294967296<=(Q=1e6*Q+t)&&(J+=Q/4294967296|0,Q%=4294967296);b&&(a=(b=d(re(Q,J))).next().value,b=b.next().value,Q=a,J=b)}return new oe(Q,J)}function ae(a,b){return Error("Invalid wire type: "+a+" (at position "+b+")")}function se(){return Error("Failed to read varint, encoding is invalid.")}function ue(a,b){return Error("Tried to read past the end of the data "+b+" > "+a)}function ce(){throw Error("Invalid UTF8")}function le(a,b){return b=String.fromCharCode.apply(null,b),null==a?b:a+b}var de,he,pe,fe=void 0,ge="undefined"!=typeof TextDecoder,me="undefined"!=typeof TextEncoder;function be(a){if(a!==Y)throw Error("illegal external caller")}function xe(a,b){if(be(b),this.V=a,null!=a&&0===a.length)throw Error("ByteString should be constructed with non-empty values")}function ve(){return pe||(pe=new xe(null,Y))}function ye(a){be(Y);var b=a.V;return null==(b=null==b||U&&null!=b&&b instanceof Uint8Array?b:"string"==typeof b?X(b):null)?b:a.V=b}function we(a,b){this.i=null,this.m=!1,this.h=this.j=this.l=0,Ce(this,a,b)}function Ce(a,b,e){e=void 0===e?{}:e,a.S=void 0!==e.S&&e.S,b&&(b=function(a){if("string"==typeof a)return{buffer:X(a),C:!1};if(Array.isArray(a))return{buffer:new Uint8Array(a),C:!1};if(a.constructor===Uint8Array)return{buffer:a,C:!1};if(a.constructor===ArrayBuffer)return{buffer:new Uint8Array(a),C:!1};if(a.constructor===xe)return{buffer:ye(a)||K(),C:!0};if(a instanceof Uint8Array)return{buffer:new Uint8Array(a.buffer,a.byteOffset,a.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}(b),a.i=b.buffer,a.m=b.C,a.l=0,a.j=a.i.length,a.h=a.l)}function Ie(a,b){if(a.h=b,b>a.j)throw ue(a.j,b)}function $e(a){var b=a.i,e=a.h,t=b[e++],n=127&t;if(128&t&&(n|=(127&(t=b[e++]))<<7,128&t&&(n|=(127&(t=b[e++]))<<14,128&t&&(n|=(127&(t=b[e++]))<<21,128&t&&(n|=(t=b[e++])<<28,128&t&&128&b[e++]&&128&b[e++]&&128&b[e++]&&128&b[e++]&&128&b[e++])))))throw se();return Ie(a,e),n}function Se(a,b){if(0>b)throw Error("Tried to read a negative byte length: "+b);var e=a.h,t=e+b;if(t>a.j)throw ue(b,a.j-e);return a.h=t,e}we.prototype.reset=function(){this.h=this.l};var ke=[];function Ee(){this.h=[]}function Te(a,b,e){for(;0<e||127<b;)a.h.push(127&b|128),b=(b>>>7|e<<25)>>>0,e>>>=7;a.h.push(b)}function Re(a,b){for(;127<b;)a.h.push(127&b|128),b>>>=7;a.h.push(b)}function Oe(a,b){if(ke.length){var e=ke.pop();Ce(e,a,b),a=e}else a=new we(a,b);this.h=a,this.j=this.h.h,this.i=this.l=-1,this.setOptions(b)}function Ae(a){var b=a.h;if(b.h==b.j)return!1;a.j=a.h.h;var e=$e(a.h)>>>0;if(b=e>>>3,!(0<=(e&=7)&&5>=e))throw ae(e,a.j);if(1>b)throw Error("Invalid field number: "+b+" (at position "+a.j+")");return a.l=b,a.i=e,!0}function Ne(a){switch(a.i){case 0:if(0!=a.i)Ne(a);else e:{for(var b=(a=a.h).h,e=b+10,t=a.i;b<e;)if(0==(128&t[b++])){Ie(a,b);break e}throw se()}break;case 1:Ie(a=a.h,a.h+8);break;case 2:2!=a.i?Ne(a):(b=$e(a.h)>>>0,Ie(a=a.h,a.h+b));break;case 5:Ie(a=a.h,a.h+4);break;case 3:for(b=a.l;;){if(!Ae(a))throw Error("Unmatched start-group tag: stream EOF");if(4==a.i){if(a.l!=b)throw Error("Unmatched end-group tag");break}Ne(a)}break;default:throw ae(a.i,a.j)}}Ee.prototype.length=function(){return this.h.length},Ee.prototype.end=function(){var a=this.h;return this.h=[],a},Oe.prototype.setOptions=function(a){a=void 0===a?{}:a,this.ca=void 0!==a.ca&&a.ca},Oe.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};var _e=[];function Fe(){this.j=[],this.i=0,this.h=new Ee}function De(a,b){0!==b.length&&(a.j.push(b),a.i+=b.length)}var Pe="function"==typeof Symbol&&"symbol"==typeof Symbol()?Symbol():void 0;function Le(a,b){return Pe?a[Pe]|=b:void 0!==a.A?a.A|=b:(Object.defineProperties(a,{A:{value:b,configurable:!0,writable:!0,enumerable:!1}}),b)}function Be(a,b){Pe?a[Pe]&&(a[Pe]&=~b):void 0!==a.A&&(a.A&=~b)}function Me(a){var b;return null==(b=Pe?a[Pe]:a.A)?0:b}function je(a,b){Pe?a[Pe]=b:void 0!==a.A?a.A=b:Object.defineProperties(a,{A:{value:b,configurable:!0,writable:!0,enumerable:!1}})}function Ue(a){return Le(a,1),a}function We(a,b){je(b,-51&(0|a))}function Ve(a,b){je(b,-41&(18|a))}var ze={};function Ge(a){return null!==a&&"object"==typeof a&&!Array.isArray(a)&&a.constructor===Object}var He,Xe,qe=[];function Ke(a){if(2&Me(a.o))throw Error("Cannot mutate an immutable Message")}function Ye(a){var b=a.length;(b=b?a[b-1]:void 0)&&Ge(b)?b.g=1:(b={},a.push((b.g=1,b)))}function Ze(a){var b=a.i+a.G;return a.B||(a.B=a.o[b]={})}function Qe(a,b){return-1===b?null:b>=a.i?a.B?a.B[b]:void 0:a.o[b+a.G]}function Je(a,b,e,t){Ke(a),et(a,b,e,t)}function et(a,b,e,t){a.j&&(a.j=void 0),b>=a.i||t?Ze(a)[b]=e:(a.o[b+a.G]=e,(a=a.B)&&b in a&&delete a[b])}function tt(a,b,e,t){var n=Qe(a,b);Array.isArray(n)||(n=He);var g=Me(n);if(1&g||Ue(n),t)2&g||Le(n,2),1&e||Object.freeze(n);else{t=!(2&e);var r=2&g;1&e||!r?t&&16&g&&!r&&Be(n,16):et(a,b,n=Ue(Array.prototype.slice.call(n)))}return n}function nt(a,b){var e=Qe(a,b),t=null==e?e:"number"==typeof e||"NaN"===e||"Infinity"===e||"-Infinity"===e?Number(e):void 0;return null!=t&&t!==e&&et(a,b,t),t}function ot(a,b,e,t,n){a.h||(a.h={});var g=a.h[e],r=tt(a,e,3,n);if(!g){var o=r;g=[];var c=!!(16&Me(a.o));r=!!(2&Me(o));var l=o;!n&&r&&(o=Array.prototype.slice.call(o));for(var d=r,h=0;h<o.length;h++){var p=o[h],f=b,q=!1;if(q=void 0!==q&&q,void 0!==(p=Array.isArray(p)?new f(p):q?new f:void 0)){var m=q=Me(f=p.o);r&&(m|=2),c&&(m|=16),m!=q&&je(f,m),f=m,d=d||!!(2&f),g.push(p)}}return a.h[e]=g,b=33|(c=Me(o)),c!=(b=d?-9&b:8|b)&&(d=o,Object.isFrozen(d)&&(d=Array.prototype.slice.call(d)),je(d,b),o=d),l!==o&&et(a,e,o),(n||t&&r)&&Le(g,2),t&&Object.freeze(g),g}return n||(n=Object.isFrozen(g),t&&!n?Object.freeze(g):!t&&n&&(g=Array.prototype.slice.call(g),a.h[e]=g)),g}function it(a,b,e){var t=!!(2&Me(a.o));if(b=ot(a,b,e,t,t),a=tt(a,e,3,t),!(t||8&Me(a))){for(t=0;t<b.length;t++){if(2&Me((e=b[t]).o)){var n=xt(e,!1);n.j=e}else n=e;e!==n&&(b[t]=n,a[t]=n.o)}Le(a,8)}return b}function at(a,b,e){if(null!=e&&"number"!=typeof e)throw Error("Value of float/double field must be a number|null|undefined, found "+typeof e+": "+e);Je(a,b,e)}function st(a,b,e,t,n){Ke(a);var g=ot(a,e,b,!1,!1);return e=null!=t?t:new e,a=tt(a,b,2,!1),null!=n?(g.splice(n,0,e),a.splice(n,0,e.o)):(g.push(e),a.push(e.o)),e.C()&&Be(a,8),e}function ut(a,b){return null==a?b:a}function ct(a,b,e){return e=void 0===e?0:e,ut(nt(a,b),e)}function lt(a,b,e,t){if(null!=a){if(Array.isArray(a))a=ht(a,b,e,void 0!==t);else if(Ge(a)){var g,n={};for(g in a)n[g]=lt(a[g],b,e,t);a=n}else a=b(a,t);return a}}function ht(a,b,e,t){var n=Me(a);t=t?!!(16&n):void 0,a=Array.prototype.slice.call(a);for(var g=0;g<a.length;g++)a[g]=lt(a[g],b,e,t);return e(n,a),a}function pt(a){return a.ja===ze?a.toJSON():function(a){switch(typeof a){case"number":return isFinite(a)?a:String(a);case"object":if(a)if(Array.isArray(a)){if(0!=(128&Me(a)))return Ye(a=Array.prototype.slice.call(a)),a}else{if(U&&null!=a&&a instanceof Uint8Array)return V(a);if(a instanceof xe){var b=a.V;return null==b?"":"string"==typeof b?b:a.V=V(b)}}}return a}(a)}function ft(a,b){128&a&&Ye(b)}function gt(a,b,e){if(e=void 0===e?Ve:e,null!=a){if(U&&a instanceof Uint8Array)return a.length?new xe(new Uint8Array(a),Y):ve();if(Array.isArray(a)){var t=Me(a);return 2&t?a:!b||32&t||!(16&t||0===t)?(4&(b=Me(a=ht(a,gt,4&t?Ve:e,!0)))&&2&b&&Object.freeze(a),a):(je(a,2|t),a)}return a.ja===ze?bt(a):a}}function mt(a,b,e,t,n,g,r){if(a=a.h&&a.h[e]){if(2&(t=Me(a))?t=a:(Ve(t,g=P(a,bt)),Object.freeze(g),t=g),Ke(b),r=null==t?He:Ue([]),null!=t){for(g=!!t.length,a=0;a<t.length;a++){var o=t[a];g=g&&!(2&Me(o.o)),r[a]=o.o}g=1|(g?8:0),((a=Me(r))&g)!==g&&(Object.isFrozen(r)&&(r=Array.prototype.slice.call(r)),je(r,a|g)),b.h||(b.h={}),b.h[e]=t}else b.h&&(b.h[e]=void 0);et(b,e,r,n)}else Je(b,e,gt(t,g,r),n)}function bt(a){return 2&Me(a.o)||Le((a=xt(a,!0)).o,2),a}function xt(a,b){var e=a.o,t=[];Le(t,16);var n=a.constructor.h;if(n&&t.push(n),n=a.B){t.length=e.length,t.fill(void 0,t.length,e.length);var g={};t[t.length-1]=g}0!=(128&Me(e))&&Ye(t),b=b||a.C()?Ve:We,g=a.constructor,Xe=t,t=new g(t),Xe=void 0,a.R&&(t.R=a.R.slice()),g=!!(16&Me(e));for(var r=n?e.length-1:e.length,o=0;o<r;o++)mt(a,t,o-a.G,e[o],!1,g,b);if(n)for(var c in n)mt(a,t,+c,n[c],!0,g,b);return t}function vt(a,b,e){null==a&&(a=Xe),Xe=void 0;var t,n=this.constructor.i||0,r=0<n,g=this.constructor.h,o=!1;if(null==a){var c=48,l=!0;r&&(n=0,c|=128),je(a=g?[g]:[],c)}else{if(!Array.isArray(a))throw Error();if(g&&g!==a[0])throw Error();var d=c=Le(a,0);if((l=0!=(16&d))&&((o=0!=(32&d))||(d|=32)),r){if(128&d)n=0;else if(0<a.length){var h=a[a.length-1];if(Ge(h)&&"g"in h){n=0,d|=128,delete h.g;var p,f=!0;for(p in h){f=!1;break}f&&a.pop()}}}else if(128&d)throw Error();c!==d&&je(a,d)}if(this.G=(g?0:-1)-n,this.h=void 0,this.o=a,n=(g=this.o.length)-1,g&&Ge(g=this.o[n])?(this.B=g,this.i=n-this.G):void 0!==b&&-1<b?(this.i=Math.max(b,n+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE,!r&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(e)for(b=l&&!o&&!0,r=this.i,l=0;l<e.length;l++)(o=e[l])<r?(n=a[o+=this.G])?yt(n,b):a[o]=He:(t||(t=Ze(this)),(n=t[o])?yt(n,b):t[o]=He)}function yt(a,b){if(Array.isArray(a)){var e=Me(a),t=1;!b||2&e||(t|=16),(e&t)!==t&&je(a,e|t)}}function wt(a,b,e){if(e){var t,n={};for(t in e){var g=e[t],r=g.ra;r||(n.J=g.xa||g.oa.W,g.ia?(n.aa=Rt(g.ia),r=function(e){return function(t,n,r){return e.J(t,n,r,e.aa)}}(n)):g.ka?(n.Z=Ot(g.da.P,g.ka),r=function(e){return function(t,n,r){return e.J(t,n,r,e.Z)}}(n)):r=n.J,g.ra=r),r(b,a,g.da),n={J:n.J,aa:n.aa,Z:n.Z}}}!function(a,b){if(b=b.R){De(a,a.h.end());for(var e=0;e<b.length;e++)De(a,ye(b[e])||K())}}(b,a)}je(qe,23),He=Object.freeze(qe),vt.prototype.toJSON=function(){return ht(this.o,pt,ft)},vt.prototype.C=function(){return!!(2&Me(this.o))},vt.prototype.ja=ze,vt.prototype.toString=function(){return this.o.toString()};var Ct=Symbol();function It(a,b,e){return a[Ct]||(a[Ct]=function(t,n){return b(t,n,e)})}function $t(a){var b=a[Ct];if(!b){var e=Wt(a);b=function(t,n){return Vt(t,n,e)},a[Ct]=b}return b}function St(a){var b=function(a){var b=a.ia;return b?$t(b):(b=a.wa)?It(a.da.P,b,a.ka):void 0}(a),e=a.da,t=a.oa.U;return b?function(n,g){return t(n,g,e,b)}:function(n,g){return t(n,g,e)}}function kt(a,b){var e=a[b];return"function"==typeof e&&0===e.length&&(e=e(),a[b]=e),Array.isArray(e)&&(Lt in e||At in e||0<e.length&&"function"==typeof e[0])?e:void 0}function Et(a,b,e,t,n,g){b.P=a[0];var r=1;if(a.length>r&&"number"!=typeof a[r]){var o=a[r++];e(b,o)}for(;r<a.length;){e=a[r++];for(var c=r+1;c<a.length&&"number"!=typeof a[c];)c++;switch(o=a[r++],c-=r){case 0:t(b,e,o);break;case 1:(c=kt(a,r))?(r++,n(b,e,o,c)):t(b,e,o,a[r++]);break;case 2:n(b,e,o,c=kt(a,c=r++),a[r++]);break;case 3:g(b,e,o,a[r++],a[r++],a[r++]);break;case 4:g(b,e,o,a[r++],a[r++],a[r++],a[r++]);break;default:throw Error("unexpected number of binary field arguments: "+c)}}return b}var Tt=Symbol();function Rt(a){var b=a[Tt];if(!b){var e=Pt(a);b=function(t,n){return zt(t,n,e)},a[Tt]=b}return b}function Ot(a,b){var e=a[Tt];return e||(e=function(e,t){return wt(e,t,b)},a[Tt]=e),e}var At=Symbol();function Nt(a,b){a.push(b)}function _t(a,b,e){a.push(b,e.W)}function Ft(a,b,e,t){var n=Rt(t),g=Pt(t).P,r=e.W;a.push(b,(function(e,t,o){return r(e,t,o,g,n)}))}function Dt(a,b,e,t,n,g){var r=Ot(t,g),o=e.W;a.push(b,(function(e,n,c){return o(e,n,c,t,r)}))}function Pt(a){var b=a[At];return b||(b=Et(a,a[At]=[],Nt,_t,Ft,Dt),Lt in a&&At in a&&(a.length=0),b)}var Lt=Symbol();function Bt(a,b){a[0]=b}function Mt(a,b,e,t){var n=e.U;a[b]=t?function(g,e,r){return n(g,e,r,t)}:n}function jt(a,b,e,t,n){var g=e.U,r=$t(t),o=Wt(t).P;a[b]=function(e,t,c){return g(e,t,c,o,r,n)}}function Ut(a,b,e,t,n,g,r){var o=e.U,c=It(t,n,g);a[b]=function(e,n,l){return o(e,n,l,t,c,r)}}function Wt(a){var b=a[Lt];return b||(b=Et(a,a[Lt]={},Bt,Mt,jt,Ut),Lt in a&&At in a&&(a.length=0),b)}function Vt(a,b,e){for(;Ae(b)&&4!=b.i;){var t=b.l,n=e[t];if(!n){var g=e[0];g&&(g=g[t])&&(n=e[t]=St(g))}if(!n||!n(b,a,t)){t=a,g=(n=b).j,Ne(n);var r=n;if(!r.ca){if(n=r.h.h-g,r.h.h=g,r=r.h,0==n)n=ve();else{if(g=Se(r,n),r.S&&r.m)n=r.i.subarray(g,g+n);else{r=r.i;var o=g;n=o===(n=g+n)?K():Z?r.slice(o,n):new Uint8Array(r.subarray(o,n))}n=0==n.length?ve():new xe(n,Y)}(g=t.R)?g.push(n):t.R=[n]}}}return a}function zt(a,b,e){for(var t=e.length,n=1==t%2,g=n?1:0;g<t;g+=2)(0,e[g+1])(b,a,e[g]);wt(a,b,n?e[0]:void 0)}function Gt(a,b){return{U:a,W:b}}var Ht=Gt((function(a,b,e){if(5!==a.i)return!1;var t=(a=a.h).i,n=a.h,g=t[n],r=t[n+1],o=t[n+2];return t=t[n+3],Ie(a,a.h+4),a=2*((r=(g<<0|r<<8|o<<16|t<<24)>>>0)>>31)+1,g=r>>>23&255,r&=8388607,Je(b,e,255==g?r?NaN:1/0*a:0==g?a*Math.pow(2,-149)*r:a*Math.pow(2,g-150)*(r+Math.pow(2,23))),!0}),(function(a,b,e){if(null!=(b=nt(b,e))){Re(a.h,8*e+5),a=a.h;var t=+b;0===t?0<1/t?Q=J=0:(J=0,Q=2147483648):isNaN(t)?(J=0,Q=2147483647):34028234663852886e22<(t=(e=0>t?-2147483648:0)?-t:t)?(J=0,Q=(2139095040|e)>>>0):11754943508222875e-54>t?(t=Math.round(t/Math.pow(2,-149)),J=0,Q=(e|t)>>>0):(b=Math.floor(Math.log(t)/Math.LN2),t*=Math.pow(2,-b),16777216<=(t=Math.round(8388608*t))&&++b,J=0,Q=(e|b+127<<23|8388607&t)>>>0),e=Q,a.h.push(e>>>0&255),a.h.push(e>>>8&255),a.h.push(e>>>16&255),a.h.push(e>>>24&255)}})),Xt=Gt((function(a,b,e){if(0!==a.i)return!1;var t=a.h,n=0,g=a=0,r=t.i,o=t.h;do{var c=r[o++];n|=(127&c)<<g,g+=7}while(32>g&&128&c);for(32<g&&(a|=(127&c)>>4),g=3;32>g&&128&c;g+=7)a|=(127&(c=r[o++]))<<g;if(Ie(t,o),!(128>c))throw se();return t=n>>>0,(a=2147483648&(c=a>>>0))&&(c=~c>>>0,0==(t=1+~t>>>0)&&(c=c+1>>>0)),t=4294967296*c+(t>>>0),Je(b,e,a?-t:t),!0}),(function(a,b,e){null!=(b=Qe(b,e))&&("string"==typeof b&&ie(b),null!=b&&(Re(a.h,8*e),"number"==typeof b?(a=a.h,ee(b),Te(a,Q,J)):(e=ie(b),Te(a.h,e.i,e.h))))})),qt=Gt((function(a,b,e){return 0===a.i&&(Je(b,e,$e(a.h)),!0)}),(function(a,b,e){if(null!=(b=Qe(b,e))&&null!=b)if(Re(a.h,8*e),a=a.h,0<=(e=b))Re(a,e);else{for(b=0;9>b;b++)a.h.push(127&e|128),e>>=7;a.h.push(1)}})),Kt=Gt((function(a,b,e){if(2!==a.i)return!1;var t=$e(a.h)>>>0,n=Se(a=a.h,t);if(a=a.i,ge){var r,g=a;(r=de)||(r=de=new TextDecoder("utf-8",{fatal:!0})),a=n+t,g=0===n&&a===g.length?g:g.subarray(n,a);try{var o=r.decode(g)}catch(e){if(void 0===fe){try{r.decode(new Uint8Array([128]))}catch(e){}try{r.decode(new Uint8Array([97])),fe=!0}catch(e){fe=!1}}throw!fe&&(de=void 0),e}}else{t=(o=n)+t,n=[];for(var c,l,d=null;o<t;)128>(c=a[o++])?n.push(c):224>c?o>=t?ce():(l=a[o++],194>c||128!=(192&l)?(o--,ce()):n.push((31&c)<<6|63&l)):240>c?o>=t-1?ce():128!=(192&(l=a[o++]))||224===c&&160>l||237===c&&160<=l||128!=(192&(g=a[o++]))?(o--,ce()):n.push((15&c)<<12|(63&l)<<6|63&g):244>=c?o>=t-2?ce():128!=(192&(l=a[o++]))||0!=l-144+(c<<28)>>30||128!=(192&(g=a[o++]))||128!=(192&(r=a[o++]))?(o--,ce()):(c=(7&c)<<18|(63&l)<<12|(63&g)<<6|63&r,c-=65536,n.push(55296+(c>>10&1023),56320+(1023&c))):ce(),8192<=n.length&&(d=le(d,n),n.length=0);o=le(d,n)}return Je(b,e,o),!0}),(function(a,b,e){if(null!=(b=Qe(b,e))){var t=!1;if(t=void 0!==t&&t,me){if(t&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(b))throw Error("Found an unpaired surrogate");b=(he||(he=new TextEncoder)).encode(b)}else{for(var n=0,g=new Uint8Array(3*b.length),r=0;r<b.length;r++){var o=b.charCodeAt(r);if(128>o)g[n++]=o;else{if(2048>o)g[n++]=o>>6|192;else{if(55296<=o&&57343>=o){if(56319>=o&&r<b.length){var c=b.charCodeAt(++r);if(56320<=c&&57343>=c){o=1024*(o-55296)+c-56320+65536,g[n++]=o>>18|240,g[n++]=o>>12&63|128,g[n++]=o>>6&63|128,g[n++]=63&o|128;continue}r--}if(t)throw Error("Found an unpaired surrogate");o=65533}g[n++]=o>>12|224,g[n++]=o>>6&63|128}g[n++]=63&o|128}}b=n===g.length?g:g.subarray(0,n)}Re(a.h,8*e+2),Re(a.h,b.length),De(a,a.h.end()),De(a,b)}})),Yt=Gt((function(a,b,e,t,n){if(2!==a.i)return!1;b=st(b,e,t),e=a.h.j,t=$e(a.h)>>>0;var g=a.h.h+t,r=g-e;if(0>=r&&(a.h.j=g,n(b,a,void 0,void 0,void 0),r=g-a.h.h),r)throw Error("Message parsing ended unexpectedly. Expected to read "+t+" bytes, instead read "+(t-r)+" bytes, either the data ended unexpectedly or the message misreported its own length");return a.h.h=g,a.h.j=e,!0}),(function(a,b,e,t,n){if(null!=(b=it(b,t,e)))for(t=0;t<b.length;t++){var g=a;Re(g.h,8*e+2);var r=g.h.end();De(g,r),r.push(g.i),g=r,n(b[t],a),r=a;var o=g.pop();for(o=r.i+r.h.length()-o;127<o;)g.push(127&o|128),o>>>=7,r.i++;g.push(o),r.i++}}));function Zt(a){return function(b,e){e:{if(_e.length){var t=_e.pop();t.setOptions(e),Ce(t.h,b,e),b=t}else b=new Oe(b,e);try{var n=Wt(a),g=Vt(new n.P,b,n);break e}finally{(n=b.h).i=null,n.m=!1,n.l=0,n.j=0,n.h=0,n.S=!1,b.l=-1,b.i=-1,100>_e.length&&_e.push(b)}g=void 0}return g}}function Qt(a){return function(){var b=new Fe;zt(this,b,Pt(a)),De(b,b.h.end());for(var e=new Uint8Array(b.i),t=b.j,n=t.length,g=0,r=0;r<n;r++){var o=t[r];e.set(o,g),g+=o.length}return b.j=[e],e}}function Jt(a){vt.call(this,a)}C(Jt,vt);var en=[Jt,1,qt,2,Ht,3,Kt,4,Kt];function tn(a){vt.call(this,a,-1,nn)}Jt.prototype.l=Qt(en),C(tn,vt),tn.prototype.addClassification=function(a,b){return st(this,1,Jt,a,b),this};var nn=[1],rn=Zt([tn,1,Yt,en]);function on(a){vt.call(this,a)}C(on,vt);var an=[on,1,Ht,2,Ht,3,Ht,4,Ht,5,Ht];function sn(a){vt.call(this,a,-1,un)}on.prototype.l=Qt(an),C(sn,vt);var un=[1],cn=Zt([sn,1,Yt,an]);function ln(a){vt.call(this,a)}C(ln,vt);var dn=[ln,1,Ht,2,Ht,3,Ht,4,Ht,5,Ht,6,Xt],hn=Zt(dn);function pn(a,b,e){if(e=a.createShader(0===e?a.VERTEX_SHADER:a.FRAGMENT_SHADER),a.shaderSource(e,b),a.compileShader(e),!a.getShaderParameter(e,a.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+a.getShaderInfoLog(e));return e}function fn(a){return it(a,Jt,1).map((function(b){var e=Qe(b,1);return{index:null==e?0:e,qa:ct(b,2),label:null!=Qe(b,3)?ut(Qe(b,3),""):void 0,displayName:null!=Qe(b,4)?ut(Qe(b,4),""):void 0}}))}function gn(a){return{x:ct(a,1),y:ct(a,2),z:ct(a,3),visibility:null!=nt(a,4)?ct(a,4):void 0}}function mn(a,b){this.i=a,this.h=b,this.m=0}function bn(a,b,e){return function(a,b){var e=a.h;if(void 0===a.s){var t=pn(e,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),n=pn(e,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),g=e.createProgram();if(e.attachShader(g,t),e.attachShader(g,n),e.linkProgram(g),!e.getProgramParameter(g,e.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+e.getProgramInfoLog(g));t=a.s=g,e.useProgram(t),n=e.getUniformLocation(t,"sampler0"),a.l={O:e.getAttribLocation(t,"aVertex"),N:e.getAttribLocation(t,"aTex"),ya:n},a.v=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,a.v),e.enableVertexAttribArray(a.l.O),e.vertexAttribPointer(a.l.O,2,e.FLOAT,!1,0,0),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),a.u=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,a.u),e.enableVertexAttribArray(a.l.N),e.vertexAttribPointer(a.l.N,2,e.FLOAT,!1,0,0),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),e.uniform1i(n,0)}t=a.l,e.useProgram(a.s),e.canvas.width=b.width,e.canvas.height=b.height,e.viewport(0,0,b.width,b.height),e.activeTexture(e.TEXTURE0),a.i.bindTexture2d(b.glName),e.enableVertexAttribArray(t.O),e.bindBuffer(e.ARRAY_BUFFER,a.v),e.vertexAttribPointer(t.O,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t.N),e.bindBuffer(e.ARRAY_BUFFER,a.u),e.vertexAttribPointer(t.N,2,e.FLOAT,!1,0,0),e.bindFramebuffer(e.DRAW_FRAMEBUFFER?e.DRAW_FRAMEBUFFER:e.FRAMEBUFFER,null),e.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT),e.colorMask(!0,!0,!0,!0),e.drawArrays(e.TRIANGLE_FAN,0,4),e.disableVertexAttribArray(t.O),e.disableVertexAttribArray(t.N),e.bindBuffer(e.ARRAY_BUFFER,null),a.i.bindTexture2d(0)}(a,b),"function"==typeof a.h.canvas.transferToImageBitmap?Promise.resolve(a.h.canvas.transferToImageBitmap()):e?Promise.resolve(a.h.canvas):"function"==typeof createImageBitmap?createImageBitmap(a.h.canvas):(void 0===a.j&&(a.j=document.createElement("canvas")),new Promise((function(e){a.j.height=a.h.canvas.height,a.j.width=a.h.canvas.width,a.j.getContext("2d",{}).drawImage(a.h.canvas,0,0,a.h.canvas.width,a.h.canvas.height),e(a.j)})))}function xn(a){this.h=a}ln.prototype.l=Qt(dn);var vn=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function yn(a,b){return b+a}function wn(a,b){window[a]=b}function Cn(a){if(this.h=a,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=a&&a.locateFile||yn,"object"==typeof window)var b=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if("undefined"==typeof location)throw Error("solutions can only be loaded on a web page or in a web worker");b=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.ha=b,a.options)for(var e=(b=d(Object.keys(a.options))).next();!e.done;e=b.next()){e=e.value;var t=a.options[e].default;void 0!==t&&(this.l[e]="function"==typeof t?t():t)}}function In(a){var b,e,t,n,g,r,o,c,l,d,f;return A((function(p){switch(p.h){case 1:return a.ga?(b=void 0===a.h.files?[]:"function"==typeof a.h.files?a.h.files(a.l):a.h.files,k(p,A((function(a){switch(a.h){case 1:return a.s=2,k(a,WebAssembly.instantiate(vn),4);case 4:a.h=3,a.s=0;break;case 2:return a.s=0,a.l=null,a.return(!1);case 3:return a.return(!0)}})),2)):p.return();case 2:if(e=p.i,"object"==typeof window)return wn("createMediapipeSolutionsWasm",{locateFile:a.locateFile}),wn("createMediapipeSolutionsPackedAssets",{locateFile:a.locateFile}),r=b.filter((function(e){return void 0!==e.data})),o=b.filter((function(e){return void 0===e.data})),c=Promise.all(r.map((function(e){var q=$n(a,e.url);if(void 0!==e.path){var t=e.path;q=q.then((function(e){return a.overrideFile(t,e),Promise.resolve(e)}))}return q}))),l=Promise.all(o.map((function(t){return void 0===t.simd||t.simd&&e||!t.simd&&!e?function(a){var b=document.createElement("script");return b.setAttribute("src",a),b.setAttribute("crossorigin","anonymous"),new Promise((function(e){b.addEventListener("load",(function(){e()}),!1),b.addEventListener("error",(function(){e()}),!1),document.body.appendChild(b)}))}(a.locateFile(t.url,a.ha)):Promise.resolve()}))).then((function(){var e,q,t;return A((function(n){if(1==n.h)return e=window.createMediapipeSolutionsWasm,q=window.createMediapipeSolutionsPackedAssets,t=a,k(n,e(q),2);t.i=n.i,n.h=0}))})),d=A((function(e){return a.h.graph&&a.h.graph.url?e=k(e,$n(a,a.h.graph.url),0):(e.h=0,e=void 0),e})),k(p,Promise.all([l,c,d]),7);if("function"!=typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return t=b.filter((function(t){return void 0===t.simd||t.simd&&e||!t.simd&&!e})).map((function(e){return a.locateFile(e.url,a.ha)})),importScripts.apply(null,h(t)),n=a,k(p,createMediapipeSolutionsWasm(Module),6);case 6:n.i=p.i,a.m=new OffscreenCanvas(1,1),a.i.canvas=a.m,g=a.i.GL.createContext(a.m,{antialias:!1,alpha:!1,va:"undefined"!=typeof WebGL2RenderingContext?2:1}),a.i.GL.makeContextCurrent(g),p.h=4;break;case 7:if(a.m=document.createElement("canvas"),!(f=a.m.getContext("webgl2",{}))&&!(f=a.m.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),p.return();a.K=f,a.i.canvas=a.m,a.i.createContext(a.m,!0,!0,{});case 4:a.j=new a.i.SolutionWasm,a.ga=!1,p.h=0}}))}function $n(a,b){var e,t;return A((function(n){return b in a.L?n.return(a.L[b]):(e=a.locateFile(b,""),t=fetch(e).then((function(g){return g.arrayBuffer()})),a.L[b]=t,n.return(t))}))}function Sn(a,b,e){var t,n,g,r,o,c,l,h,f,p,m,q,x,v;return A((function(y){switch(y.h){case 1:if(!e)return y.return(b);for(t={},n=0,g=d(Object.keys(e)),r=g.next();!r.done;r=g.next())o=r.value,"string"!=typeof(c=e[o])&&"texture"===c.type&&void 0!==b[c.stream]&&++n;1<n&&(a.M=!1),l=d(Object.keys(e)),r=l.next();case 2:if(r.done){y.h=4;break}if(h=r.value,"string"==typeof(f=e[h]))return x=t,v=h,k(y,function(a,b,e){var t;return A((function(n){return"number"==typeof e||e instanceof Uint8Array||e instanceof a.i.Uint8BlobList?n.return(e):e instanceof a.i.Texture2dDataOut?((t=a.v[b])||(t=new mn(a.i,a.K),a.v[b]=t),n.return(bn(t,e,a.M))):n.return(void 0)}))}(a,h,b[f]),14);if(p=b[f.stream],"detection_list"===f.type){if(p){for(var w=p.getRectList(),C=p.getLandmarksList(),I=p.getClassificationsList(),u=[],$=0;$<w.size();++$){var S=hn(w.get($)),E=void 0;E=void 0===E?0:E,S={la:{sa:ct(S,1),ta:ct(S,2),height:ct(S,3),width:ct(S,4),rotation:ct(S,5,0),pa:ut(Qe(S,6),E)},ea:it(cn(C.get($)),on,1).map(gn),ba:fn(rn(I.get($)))},u.push(S)}w=u}else w=[];t[h]=w,y.h=7;break}if("proto_list"===f.type){if(p){for(w=Array(p.size()),C=0;C<p.size();C++)w[C]=p.get(C);p.delete()}else w=[];t[h]=w,y.h=7;break}if(void 0===p){y.h=3;break}if("float_list"===f.type){t[h]=p,y.h=7;break}if("proto"===f.type){t[h]=p,y.h=7;break}if("texture"!==f.type)throw Error("Unknown output config type: '"+f.type+"'");return(m=a.v[h])||(m=new mn(a.i,a.K),a.v[h]=m),k(y,bn(m,p,a.M),13);case 13:q=y.i,t[h]=q;case 7:f.transform&&t[h]&&(t[h]=f.transform(t[h])),y.h=3;break;case 14:x[v]=y.i;case 3:r=l.next(),y.h=2;break;case 4:return y.return(t)}}))}function kn(a,b){for(var e=b.name||"$",t=[].concat(h(b.wants)),n=new a.i.StringList,g=d(b.wants),r=g.next();!r.done;r=g.next())n.push_back(r.value);g=a.i.PacketListener.implement({onResults:function(n){for(var r={},o=0;o<b.wants.length;++o)r[t[o]]=n.get(o);var c=a.listeners[e];c&&(a.I=Sn(a,r,b.outs).then((function(e){e=c(e);for(var p=0;p<b.wants.length;++p){var n=r[t[p]];"object"==typeof n&&n.hasOwnProperty&&n.hasOwnProperty("delete")&&n.delete()}e&&(a.I=e)})))}}),a.j.attachMultiListener(n,g),n.delete()}function En(a){return void 0===a&&(a=0),1===a?"selfie_segmentation_landscape.tflite":"selfie_segmentation.tflite"}function Tn(a){var b=this;a=a||{},this.h=new Cn({locateFile:a.locateFile,files:function(e){return[{simd:!0,url:"selfie_segmentation_solution_simd_wasm_bin.js"},{simd:!1,url:"selfie_segmentation_solution_wasm_bin.js"},{data:!0,url:En(e.modelSelection)}]},graph:{url:"selfie_segmentation.binarypb"},listeners:[{wants:["segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"object"==typeof window&&void 0!==window.navigator&&("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document)},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelSelection:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelSelection",fieldName:"int_value"},onChange:function(e){var t,n,g;return A((function(r){return 1==r.h?(t=En(e),n="third_party/mediapipe/modules/selfie_segmentation/"+t,k(r,$n(b.h,t),2)):(g=r.i,b.h.overrideFile(n,g),r.return(!0))}))}}}})}(t=Cn.prototype).close=function(){return this.j&&this.j.delete(),Promise.resolve()},t.reset=function(){var a=this;return A((function(b){a.j&&(a.j.reset(),a.s={},a.v={}),b.h=0}))},t.setOptions=function(a,b){var e=this;if(b=b||this.h.options){for(var t=[],n=[],g={},r=d(Object.keys(a)),o=r.next();!o.done;g={X:g.X,Y:g.Y},o=r.next())if(!((o=o.value)in this.l)||this.l[o]!==a[o]){this.l[o]=a[o];var c=b[o];void 0!==c&&(c.onChange&&(g.X=c.onChange,g.Y=a[o],t.push(function(t){return function(){return A((function(n){if(1==n.h)return k(n,t.X(t.Y),2);!0===n.i&&(e.u=!0),n.h=0}))}}(g))),c.graphOptionXref&&(o=Object.assign({},{calculatorName:"",calculatorIndex:0},c.graphOptionXref,{valueNumber:1===c.type?a[o]:0,valueBoolean:0===c.type&&a[o],valueString:2===c.type?a[o]:""}),n.push(o)))}0===t.length&&0===n.length||(this.u=!0,this.H=(void 0===this.H?[]:this.H).concat(n),this.F=(void 0===this.F?[]:this.F).concat(t))}},t.initialize=function(){var a=this;return A((function(b){return 1==b.h?k(b,In(a),2):3!=b.h?k(b,function(a){var b,e,t,n,g,r,o,c;return A((function(l){if(1==l.h)return a.h.graph&&a.h.graph.url&&a.fa===a.h.graph.url?l.return():(a.u=!0,a.h.graph&&a.h.graph.url?(a.fa=a.h.graph.url,k(l,$n(a,a.h.graph.url),3)):void(l.h=2));for(2!=l.h&&(b=l.i,a.j.loadGraph(b)),e=d(Object.keys(a.D)),t=e.next();!t.done;t=e.next())n=t.value,a.j.overrideFile(n,a.D[n]);if(a.D={},a.h.listeners)for(g=d(a.h.listeners),r=g.next();!r.done;r=g.next())o=r.value,kn(a,o);c=a.l,a.l={},a.setOptions(c),l.h=0}))}(a),3):k(b,function(a){var b,e,t,g,n,r;return A((function(o){switch(o.h){case 1:if(!a.u)return o.return();if(!a.F){o.h=2;break}b=d(a.F),e=b.next();case 3:if(e.done){o.h=5;break}return k(o,(0,e.value)(),4);case 4:e=b.next(),o.h=3;break;case 5:a.F=void 0;case 2:if(a.H){for(t=new a.i.GraphOptionChangeRequestList,g=d(a.H),n=g.next();!n.done;n=g.next())r=n.value,t.push_back(r);a.j.changeOptions(t),t.delete(),a.H=void 0}a.u=!1,o.h=0}}))}(a),0)}))},t.overrideFile=function(a,b){this.j?this.j.overrideFile(a,b):this.D[a]=b},t.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},t.send=function(a,b){var e,t,g,n,r,o,c,l,h,f=this;return A((function(p){switch(p.h){case 1:return f.h.inputs?(e=1e3*(null==b?performance.now():b),k(p,f.I,2)):p.return();case 2:return k(p,f.initialize(),3);case 3:for(t=new f.i.PacketDataList,g=d(Object.keys(a)),n=g.next();!n.done;n=g.next())if(r=n.value,o=f.h.inputs[r]){e:{var m=a[r];switch(o.type){case"video":var q=f.s[o.stream];if(q||(q=new mn(f.i,f.K),f.s[o.stream]=q),0===q.m&&(q.m=q.i.createTexture()),"undefined"!=typeof HTMLVideoElement&&m instanceof HTMLVideoElement)var x=m.videoWidth,v=m.videoHeight;else"undefined"!=typeof HTMLImageElement&&m instanceof HTMLImageElement?(x=m.naturalWidth,v=m.naturalHeight):(x=m.width,v=m.height);v={glName:q.m,width:x,height:v},(x=q.h).canvas.width=v.width,x.canvas.height=v.height,x.activeTexture(x.TEXTURE0),q.i.bindTexture2d(q.m),x.texImage2D(x.TEXTURE_2D,0,x.RGBA,x.RGBA,x.UNSIGNED_BYTE,m),q.i.bindTexture2d(0),q=v;break e;case"detections":for((q=f.s[o.stream])||(q=new xn(f.i),f.s[o.stream]=q),q.data||(q.data=new q.h.DetectionListData),q.data.reset(m.length),v=0;v<m.length;++v){x=m[v];var y=q.data,w=y.setBoundingBox,C=v,I=x.la,u=new ln;if(at(u,1,I.sa),at(u,2,I.ta),at(u,3,I.height),at(u,4,I.width),at(u,5,I.rotation),Je(u,6,I.pa),I=u.l(),w.call(y,C,I),x.ea)for(y=0;y<x.ea.length;++y){u=x.ea[y],C=(w=q.data).addNormalizedLandmark,I=v,u=Object.assign({},u,{visibility:u.visibility?u.visibility:0});var $=new on;at($,1,u.x),at($,2,u.y),at($,3,u.z),u.visibility&&at($,4,u.visibility),u=$.l(),C.call(w,I,u)}if(x.ba)for(y=0;y<x.ba.length;++y)C=(w=q.data).addClassification,I=v,u=x.ba[y],at($=new Jt,2,u.qa),u.index&&Je($,1,u.index),u.label&&Je($,3,u.label),u.displayName&&Je($,4,u.displayName),u=$.l(),C.call(w,I,u)}q=q.data;break e;default:q={}}}switch(c=q,l=o.stream,o.type){case"video":t.pushTexture2d(Object.assign({},c,{stream:l,timestamp:e}));break;case"detections":(h=c).stream=l,h.timestamp=e,t.pushDetectionList(h);break;default:throw Error("Unknown input config type: '"+o.type+"'")}}return f.j.send(t),k(p,f.I,4);case 4:t.delete(),p.h=0}}))},t.onResults=function(a,b){this.listeners[b||"$"]=a},F("Solution",Cn),F("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"}),(t=Tn.prototype).close=function(){return this.h.close(),Promise.resolve()},t.onResults=function(a){this.h.onResults(a)},t.initialize=function(){var a=this;return A((function(b){return k(b,a.h.initialize(),0)}))},t.reset=function(){this.h.reset()},t.send=function(a){var b=this;return A((function(e){return k(e,b.h.send(a),0)}))},t.setOptions=function(a){this.h.setOptions(a)},F("SelfieSegmentation",Tn),F("VERSION","0.1.1675465747")}).call(this)}).call(this,n(27))}}]);